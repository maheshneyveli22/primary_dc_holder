1) Cisco Packet Tracer - To simulate network topologies using CISCO devices 
Alternatives: GNS3, Cisco VIRL and EVE-ng 

2) Network Interface Card:(NIC) 
a) To connect to the network, you need Network Interface Card 
-> Mobile phones have built in network interface card 

b) To fnd the mac address of NIC in Windows:


1) Using getmac /v 

#####
C:\Users\gs1-maheswarane>getmac /v

Connection Name Network Adapter Physical Address    Transport Name
=============== =============== =================== ==========================================================
Ethernet        Intel(R) Ethern 6C-24-08-8B-CD-D0   Media disconnected
Wi-Fi           Intel(R) Wi-Fi  BC-6E-E2-B0-34-7A   \Device\Tcpip_{2C15D64A-4B8F-4452-AEF7-79DE9C88F471}
Bluetooth Netwo Bluetooth Devic BC-6E-E2-B0-34-7E   Media disconnected

C:\Users\gs1-maheswarane>
##############


2) Using ipconfig /all: 

#########
C:\Users\gs1-maheswarane>ipconfig /all

Windows IP Configuration

   Host Name . . . . . . . . . . . . : GS1-MAHESWAR-LX
   Primary Dns Suffix  . . . . . . . : corp.expeditors.com
   Node Type . . . . . . . . . . . . : Hybrid
   IP Routing Enabled. . . . . . . . : No
   WINS Proxy Enabled. . . . . . . . : No
   DNS Suffix Search List. . . . . . : gs1.ei
                                       corp.expeditors.com
                                       chq.ei
                                       expeditors.com
                                       expeditors
                                       expd

Ethernet adapter Ethernet:

   Media State . . . . . . . . . . . : Media disconnected
   Connection-specific DNS Suffix  . :
   Description . . . . . . . . . . . : Intel(R) Ethernet Connection (13) I219-V
   Physical Address. . . . . . . . . : 6C-24-08-8B-CD-D0
   DHCP Enabled. . . . . . . . . . . : No
   Autoconfiguration Enabled . . . . : Yes

Wireless LAN adapter Local Area Connection* 2:

   Media State . . . . . . . . . . . : Media disconnected
   Connection-specific DNS Suffix  . :
   Description . . . . . . . . . . . : Microsoft Wi-Fi Direct Virtual Adapter
   Physical Address. . . . . . . . . : BC-6E-E2-B0-34-7B
   DHCP Enabled. . . . . . . . . . . : Yes
   Autoconfiguration Enabled . . . . : Yes

Wireless LAN adapter Local Area Connection* 11:

   Media State . . . . . . . . . . . : Media disconnected
   Connection-specific DNS Suffix  . :
   Description . . . . . . . . . . . : Microsoft Wi-Fi Direct Virtual Adapter #2
   Physical Address. . . . . . . . . : BE-6E-E2-B0-34-7A
   DHCP Enabled. . . . . . . . . . . : No
   Autoconfiguration Enabled . . . . : Yes

Wireless LAN adapter Wi-Fi:

   Connection-specific DNS Suffix  . :
   Description . . . . . . . . . . . : Intel(R) Wi-Fi 6 AX201 160MHz
   Physical Address. . . . . . . . . : BC-6E-E2-B0-34-7A
   DHCP Enabled. . . . . . . . . . . : Yes
   Autoconfiguration Enabled . . . . : Yes
   Link-local IPv6 Address . . . . . : fe80::dace:1126:a2f6:fd96%5(Preferred)
   IPv4 Address. . . . . . . . . . . : 192.168.29.232(Preferred)
   Subnet Mask . . . . . . . . . . . : 255.255.255.0
   Lease Obtained. . . . . . . . . . : Thursday, May 23, 2024 10:48:27 AM
   Lease Expires . . . . . . . . . . : Friday, May 24, 2024 10:48:26 AM
   Default Gateway . . . . . . . . . : 192.168.29.1
   DHCP Server . . . . . . . . . . . : 192.168.29.1
   DHCPv6 IAID . . . . . . . . . . . : 62680802
   DHCPv6 Client DUID. . . . . . . . : 00-01-00-01-2B-53-AC-47-6C-24-08-8B-CD-D0
   DNS Servers . . . . . . . . . . . : 192.168.29.1
   NetBIOS over Tcpip. . . . . . . . : Enabled

Ethernet adapter Bluetooth Network Connection:

   Media State . . . . . . . . . . . : Media disconnected
   Connection-specific DNS Suffix  . :
   Description . . . . . . . . . . . : Bluetooth Device (Personal Area Network)
   Physical Address. . . . . . . . . : BC-6E-E2-B0-34-7E
   DHCP Enabled. . . . . . . . . . . : Yes
   Autoconfiguration Enabled . . . . : Yes

C:\Users\gs1-maheswarane>

###############


3) Servers, Clients, Ports and Protocols: 
a) Server: 
-> Computer That provides service 
-> Server can run multiple services and provide multiple services to client

b) Client: Computer that accesses service provided by server  
-> In client server model, client requests a file or service to the client and the server provides it 

c) Ports:  Server will be listening on different port numbers for different protocols 
eg: 
HTTP 80
HTTPS 443
FTP 21 and 20  

d) Protocol: 
-> Set of rules used for communication between devices 


4) Practical demonstration of Servers, Clients, Ports and Protocols: using packet tracer:
a) Lets have server and client 
b) For communication between client and server we need a physical cable or air(wireless) 
-> Physical connection - we can use cross over cable .
   standard ethernet cables cant be used for the same. 
-> We will use Fast Ethernet interface on pc and fast Ethernet interface on the server for connection 
c) Device Communication
To allow two devices to communicate with each other: we need two things: 
a) Ethernet address or Mac address pre-built into NICs
-> Every device that connects with physical ethernet or wireless needs a mac address 
-> MAC address is configured by default by the manufacturer 
-> It is 12 digit hex decimal number 

b) IP address: 
-> In networks a server which could be your home router will be allocating IP addresses to your pc using DHCP(Dynamic host configuration protocol) 
-> IP addresses will be assigned via DHCP or it can be configured statically 
-> In packet tracer, we wont have have dhcp , hence we need to assign ip addresses 

c) ping 
d) Services: 
HTTP/DHCP/DCHPv6/TFTP/DNS/SYSLOG/AAA/NTP/EMAIL/FTP/IoT/VM Management/Radius EAP 


4) Networking devices: Repeaters, Hubs, Switches and Routers:
a) Normally the signal that travels through the cable will attenuate:
-> Atttenuation referes to the reduction in the strength or intensity of a signal. The longer the distance the less strong a signal is.

b) Repeater: Repeats signal from one port to another[NO INTELLIGENCE] 

-> Repeater is an electronic device that receives signal and retransmits it. Repeaters are used to extend transmissions so that the signal can cover long distances or be received on the other side of an obstruction. 


c) HUB: Multiport repeater: Cisco fasthub 400 series/Netgear Hub [NO INTELLIGENCE]
-> Has RJ45 connectors on the front and got power on the back 
-> Hub is a multiport repeater. Mutiport repeater ie the hub simply repeats the signals 
-> Hub does not understand the frames it receives or the information that it receives. Hub simply amplifies the signal from one port to another 
---> So if traffic was received on port 1 of this hug, it would simply amplify the signal out of all of those ports  without understanding any of the details 

D) WIFI - Wireless Acces point supports WIFI 6(version of WIFI) 
-> WIFI network is a hub in the air 


e) SWITCH: CISCO Switch 3750/ TP link switch 
-> Has 48 ports 

-> Switch has intelligence while hub does not have intelligence 
-> Switch reads frames received on Ethernet. Switch uses Mac Address table 
-> Switch receives frames and they have the intelligence to only forward the frames out of the correct ports 

-> A Switch has a MAC address table, it has some intelligence and it learns where MAC addresses are in the network and  it only forwards frames out of the correct ports 


f) Bridge: intermediate device  between a switch and hub 
1) First we had repeaters, then hubs, then bridges, then switches 
-> Bridge = learns MAC addresses in software 
-> Switch = learns mac addresses more quickly using hardward ASICS(Application specific integrated circuits) ) 

2) Switch learns where their mac addresses are and then forward the traffic only out of relevant ports. 

3) Bridge is an intermediate device between switch and a hub.
Chronically:  Repeaters->Hubs->Bridges->Switches

4) Switch through many ports, helps to connect to many devices in our local area network.
-> Useful for sending traffic within a local area network


5) Switches operate on MAC addresses using layer 2 in OSI model 
-> Hubs are layer1 devices 

g) Then we have routers, which are layer 3 devices
which uses IP addresses to route from one network to another 

h) Overall Theme:
Routers: Intelligence based on IP 
Switches: Intelligence based on MAC address 
Repeaters/Hubs - Dumb devices 
Bridge - Intermediate between switch and Hub 


5) Networking Devices: Firewalls, IDS , IPS and WLC 
a) Router: 
CISCO 4321 router 

b) Switch:
CISCO 3560 switch 
CISCO 2960 switch 

c) ASA:
CISCO ASA 5505 -> Firewall 


d) Routers often have firewall functionality 
-> PCs too have firewally but that is software based 
-> ASA 5505 is hardware based firewall 


e) Network topology 
1) Topology 1: 
-> Here we can connect Internet directly to firewall , then to router , then to switch and then the inside end point devices 


Internet ---> ASA5505(Firewall)-->ISR4321(Router)-->3500-2FPS(Multilayer Switch1)---->EndpointDevices(Laptops and other computers) 


2) Topology 2:

Or we can connect internet directly to router, then to ASA firewall, then to switch and inside devices 

Internet -->ISR4321(Router)---> ASA5505(Firewall)-->3500-2FPS(Multilayer Switch1)---->EndpointDevices(Laptops and other computers) 

f) We have another device which looks the same: Wireless LAN controller(WLC-PT) 
-> Wireless LAN controller looks same like ASA, but it has different functionality 
-> WLC is used to manage access points(3702i) -> light weight access Point 

g) If we got only one access point, it makes sense to manage the access point directly using something called: Autonomous Access Point
->Autonomous means that you dont need a wireless LAN controller to manage it 
-> if we got 100 or 500 of these access points, then its going to be a lot of work to manually configure everyone  of these access points  
-> Hence rather than doing that, we use Light weight access points 
-> Some access points support both, so they can be either lightweight or be autonomous 

---A wireless access point (WAP) is a networking device that allows wireless-capable devices to connect to a wired network. It is simpler and easier to install ...----

h) If there are 500 access points, they will connect to Wireless LAN controller 
i) Wireless LAN controller does not have as many ports 
-> Wireless LAN controller and the bigger ones, does not have so many interfaces 
-> Wireless LAN controllers simply connect to switches 
-> So Access Points connect to switches, Wireless Lan controllers connects to Switches,  

eg:
Cisco Catalyst 9800 series Wireless Controllers 
CISCO Catalyst 9400 Series Switches 

j) Overall Idea:
Wireless LAN controller will manage Wireless Access points -> Rather than manually managing every one of the access points, you manage them through the wireless LAN controller 
-> Hence a wireless LAN contoller will manage 100 or 500 access points 


k) Then we have Next generation Firewalls, which support features Like IDS, IPS etc 

IDS - Intrusion Detection System
Analogy: like a dog, which helps protect by warning you when there is an attack taking place  and it does not stop the attacker 
-> IDS simply detects and alerts about attacks 

IPS - Intrucsion prevention system
-> It can alert you that there is a problem, but also block the attack so it can prevent the attack 


6) OSI and TCP/IP Models:
a) In previous version of CCNA we were taught that the OSI model consists of seven layers 

OSI MODEL 

7				All					Application 
6				People				Presentation
5				Sleeping			Session 
4				Through				Transport
3				Network				Network 
2				Dont				Datalink
1				Pass				Physical 


TCP/IP MODEL:
5-7			Application 
4			Transport 
3			Network 
2			Data Link 
1 			Physical 


b) In OSI model and TCP/IP model, they are talking about Protocol stack 
-> i.e They take Different protocols that do different things and they try and put it into neat layers 
-> It is always not possible to take protocols and put them neatly into individual layers because some developers have programmed the applications to do things that supposedly they should not be doing 
-> In CCNA course,we were told that specific layers talk to specific layers , but that does not happen always 
-> In real world things get more complicated 

c) Different layers by different people:

1) RFC1122 internet std3
Four layers:

Application 
Transport 
Internet 
Link 

2) CISCO Academy: 4 layers 
Application 
Transport 
Internetwork 
Network interface 


3) Kurose Forouzan: 5 layers
Application
Transport 
Network 
Datalink 
Physical 

4) Comer Kozierok: 4+ 1 layers 
Application 
Transport 
Internet 
Data Link(Network Interface) 
(Hardware) 

5) Stallings : 5 layers 
Application Host-to-Host or Transport 
Internet 
Network Access 
Physical 


6) Tanenbaum 5 layers 
Application 
Transport 
Internet 
Data Link 
Physical 

7) Arpanet Reference model 3 layers 
Application/PRocess
Host-to-Host 
Network Interface 


8) OSI model: 7 layers 
Application Presentation Session 
Transport 
Network 
Datalink 
Physical 


d) Layers where Networking People concentrate in OSI Model: 4 layers 
Transport 
Network 
Data Link 
Physical 

e) New Version of CCNA:
-> in new version of CCNA, they use this hybdrid model where they have taken parts of the OSI and added it to the TCP/IP model 
-> So rather than original model of just link layer or network interface layer, we have Data Link layer which is layer 2 and Physical layer which is layer 1 

f) For CCNA, 
We need to know both OSI and TCPIP model, but concentrate on the TCPIP model 
-> As a network engineer, we will concentrate on Layer1(Physical), Layer2(Data Link), Layer3(Network), Layer4(Transport) alone 


g) IPV4 : Internet Protocol Version 4 
TCP : Transmission Control protocol 
UDP: User Datagram protocol 
IPv6 : Internet Protocol Version 6 

h) TCP/IP Layers and Protocols/Devices 

Layer5-7 Application ---> HTTP, HTTPs, Telnet,FTP,TFTP etc 
Layer 4, Transport -> TCP/UDP 
Layer 3 Network ---> Router 
Layer 2 Data Link ---> Bridge/Switch
Layer 1 Physical---> Hub 

---Out of topic-----
6) After release of WIFI 6, things changed 
-> Previously everything acted as pure hub in air i.e only one person could communicate at a time 
---> Air in wifi network is like a hub 
---Out of topic-----


7) Bits, Frames, Packets, Segments and More:

TCP/IP Layers/ Protocols/Devices /Data 


Layer5-7 Application(applications ---> HTTP, HTTPs, Telnet,FTP,TFTP etc 
Layer 4, Transport(segments:Data of src/dest ports, dest port tells to what process data goes ) -> TCP/UDP 
Layer 3 Network(packets:Data of src/dest IP,PRO what tcp port 0x06 means TCP) ---> Router 
Layer 2 Data Link(frames:Data of src/dest mac address,,Type whether ipv4/ipv6) ---> Bridge/Switch
Layer 1 Physical(bits)---> Hub 

i) Bits:
When Data is sent at physical layer,we are sending zeroes and ones across the physical layer which is known as Bits

ii) Frames:
-> When we are sending data through an Ethernet Switch which is a layer two device, we are sending data as frames 
---> Frame is getting switched from one port on a switch to another 


iii) Packets:
-> At layer 3, data is sent the in the form of packets 
-> Router which is a layer 3 device will route packets from one interface to another 

iv) Segments:
-> At layer 4, data is sent in form of segments 


v) Applications
-> At layer 5to7, we have applications 

8) HTTP Captures:
a) On ethernet devices communicate using MAC address
-> MAC Address is the built in address of NIC 
b) Now in our topology we are hitting url and connecting from PC to the server
-> PC does not know mac address of server
-> MAC address of server can be found by going to config  of pc in packet tracer 
c) PC to know mac address of server, it will arp or request. 
ARP is address resolution protocol requesting the mac address 
-> It sends a request on who has this IP address so that it gets sent to the switch 
-> This request is called a broadcast frame, also we can notice that the destination mac:FFFF FFFF FFFF

d) PDU - Protocol Data Unit 
-> In PDU we can see that the target mac address is blank 

eg:
 Target MAC: 0000 0000 0000 
 Target IP: 10.1.1.100s
 
e) PC: sends broadcast asking for which device has this IP address: 
Now this is a broadcast and layer 2 switch which will flood the broadcase which basically sends it out of all ports,

-> devices that does not have the ip will drop the packet while the device having the IP will reply back

f) In our case server has that IP. 
-> THe inbound PDU for server is from the PC to a broadcast address but the reply from the server

tbc...


9) Port numbers:
a) Port numbers are assigned in various ways, based on three ranges:
1)  System Ports (0-1023), 
2)  User Ports (1024-49151), and 
3)  the Dynamic and/or Privat Ports (49152-65535); 

the different uses of these ranges are described in
[RFC6335]. According to Section 8.1.2 of [RFC6335], System Ports are 
assigned by the "IETF Review" or "IESG Approval" procedures described in 
[RFC8126]. User Ports are assigned by IANA using the "IETF Review" process, 
the "IESG Approval" process, or the "Expert Review" process, as per 
[RFC6335]. Dynamic Ports are not assigned.


b) EPHEMERAL PORT 
 An ephemeral port is a communications endpoint (port) of a transport layer protocol of the Internet protocol suite that is used for only a short period of time for the duration of a communication session.
 
c) Well Known ports:
HTTP     80
HTTPS    443
FTP      21
TFTP 	 69 
TELNET 	 23
SSH      22 
 
 
10) Binary 
a) Why do we care about binary:
i)  Access Control Lists : Permit or deny traffic based on an IP address 
-> We will match specific IP addresses based on a binary representation 
ii) Subnetting:
-> Determining what a subnet mask is for a specific network , you need to understand binary 

c) IP is reprsented in the form of two Octets 


7654 3210
0000 0000

d) Table to remember:

Base^Exponent   2^7		2^6		2^5		2^4		2^3		2^2		2^1		2^0
Binary 			 1		 1		 1		 1		 1		 1		 1		 1
Decimal   		128		64		32		16		 8		 4		 2		 1  



Decimal 255 is indicated as : 1111 1111 in binary 


11) Technique for Decimal to binary 


a) 128 
-> since it is 2^7, we can enable only that binary and else will be zero: 
-> SO binary will be: 1000 0000

b) 65
-> In that case, in table we have 64, so 65-64-1, so from 2^6, all will be 1 except 2^0
-> So binary will be 1111 1110


c) 192.168.1.72
 1100 0000 192
 1010 1000 168
 0000 0001   1
 0100 1000 72
 
d) 255.255.255.0
1111 1111
1111 1111
1111 1111
0000 0000

e) 192.168.1.249
1100 0000
1010 1000
0000 0000
1111 1001
 
 
12) IPv4 Address:
-> An IPv4 address is an address used to uniquely identify a device on an IP network 
-> it is 4 octets in length . meaning 4 times 8 bits 
-> 1 Octet is 8 bits 
 
 
13) Hexa decimal - why do we care:
a) Used in networking, everywhere 
b) MAC address is in Hexa decimal 
eg: Physical Address. . . . . . . . . : BC-6E-E2-B0-34-7A
c) IPv6 addresses are in Hexa decimal 
 Temporary IPv6 Address. . . . . . : 2405:201:e031:70a3:4b7:20e:94b9:5bef(Preferred)
   Link-local IPv6 Address . . . . . : fe80::dace:1126:a2f6:fd96%5(Preferred)
   
14) Configure MAC Addresses, ARP working and MAC address table population using Packet tracer 

a) In packet tracer, lets get a 3650 switch , PC , laptop and add them to topology via straight through cable 
b) CONNECT PC TO SWITCH: From PC's fast Ethernet interface connect to Switch's Gigabit Ethernet 1/0/1  interface
-> to show the interfaces connected in each device, go to Options->Preferences -> Always show port labels in logical workspace
c) CONNECT SWITCH TO LAPTOP: Switch's Gigabit 1/0/2 interface to laptop's fastethernet FA0
d) Switch needs a power supply, grab it and add to switch 
-> In CLI tab, we can see that the switch is booting up 
e) Now lets view the MAC addresses on the devices 
f) PC CONFIGURATION:
1) In PC1 grab FA0 and we can see mac address: 0040.0BEE.37A6, we will assign pc with IP: 10.1.1.1 and give it a subnet mask of 255.255.255.0 
2) In desktop command prompt, if we type ipconfig, you will be able to see the configured ip and subnet 
G) LAPTOP CONFIGURATION:
1) Configure Laptop with IP 10.1.1.2 and subnet mask: 255.255.255.0


############MAC ADDRESS Structure ############

0040.0BEE.37A6
a) Here 0040.0B which is the FIRST HALF is the vendor code - which is manufacturer's organization unique identifier (OUI) 
b) Here EE.37A6 which is the SECOND HALF  is a unique number or identifier for the mac address 

-> MAC address is a 48 bit number which has got twelve hexa decimal values 

############

h) Now in the lapto when we type: arp -a , it tells no arp entries 

eg:
C:\>arp -a
No ARP Entries Found

i) ARP : Address Resolution protocol 
-> ARP is used to find the MAC address of another device in the network 
-> In ethernet devices have mac addresses allocated to them by vendors 
-> If i want to talk to a particular device, i need the mac address of that particular device - in order to send the traffic onto the ethernet network 


->If the laptop pings the pc, It is basically going to send a broadcast into the network, saying "who has this IP address" and then the corresponding device(pc) replies back with its mac address 

j) Earlier when we typed: arp -a from 10.1.1.2, "No ARP Entries Found" since we have not done any ping or communication. 
-> Now lets try a ping of 10.1.1.1 from Laptop(10.1.1.2) 

-> Before trying ping lets note MAC address and IP of Laptop and PC:

LAPTOP:
IPv4 Address....................: 10.1.1.2
Physical Address................: 0003.E4C8.8735

PC:
IPv4 Address....................: 10.1.1.1
Physical Address................: 0040.0BEE.37A6

k) Ping ping pc(10.1.1.1) from Laptop(10.1.1.2) 

##############
C:\>ping 10.1.1.1

Pinging 10.1.1.1 with 32 bytes of data:

Reply from 10.1.1.1: bytes=32 time<1ms TTL=128
Reply from 10.1.1.1: bytes=32 time<1ms TTL=128

##############

l) Now check the arp -a in laptop(10.1.1.2) 

#####
C:\>arp -a
  Internet Address      Physical Address      Type
  10.1.1.1              0040.0bee.37a6        dynamic
#####

-> Now we see that arp table lists that 10.1.1.1 has MAC Address: 0040.0bee.37a6

--> At the same time when we check arp -a in pc(10.1.1.1) 

###
C:\>arp -a
  Internet Address      Physical Address      Type
  10.1.1.2              0003.e4c8.8735        dynamic
###

-> Thus we can see arp table of pinged device(desktop) is also populated with details of the device which  initiated the ping(laptop) 


m) if we change mac address of laptop and pc, then if laptop pings pc, we can see that the arp table is updated with the new mac addresses in both laptop and pc

n) Switch will have both new and old mac addresses in its arp table 

command:
> show mac address-table 

o) MAC addresses in arp table will time out after a period of time   

p) Switch learns where the mac addresses of devices are in the network and then basically switches the traffic from one mac address to another depending on who's talking to whom 


15) Numbers that are in HEXA DECIMAL:
a) MAC address 
b) IPv6 address 
c) DHCP client DUID 
d) Bluetooth Physical address 


16) HEXA DECIMAL CALCULATIONS: 
a) Network engineer should know three number systems:
1) Decimal (base 10 -ten numbers)
0,1,2,3,4,5,6,7,8,9
2) Binary(Base 2- two numbers) 
0 or 1 
3) Hexadecimal(Base16 -sixteen numbers) 
0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F 

HexaDecimal   - Decimal           BINARY
0					0			     0000
1					1				 0001
2					2				 0010
3					3				 0011
4					4				 0100
5                   5		  		 0101				
6					6			     0110
7					7			     0111
8					8			     1000
9					9			     1001
A					10			     1010
B					11			     1011
C					12			     1100
D					13			     1101
E					14			     1110
F				    15			     1111


Binary Decimal Table:
Base^Exponent   2^7		2^6		2^5		2^4		2^3		2^2		2^1		2^0
Binary 			 1		 1		 1		 1		 1		 1		 1		 1
Decimal   		128		64		32		16		 8		 4		 2		 1  



B) Steps for  decimal to hexa  decimal 
1) Convert to binary
2) Put the corresponding hexa number  table 



c) Decimal to Hexa decimal 
1) Convert to binary 
2) Put the correponding decimal number from table 


d) Decimal to hexa decimal:

a) 128 --->1000	0000  ---> 80
b) 255 --->1111 1111  ---> FF 
c) 224 --->1110 0000  ---> E0
d) 240 --->1111 0000  ---> F0

e) Why is conversion between Decimal to hexa decimal important 
--> In this example, broadcast address is in IPv4 


OUTLINE OF THIS LESSON:IP Addressing 
-> IP Addresses overview 
-> Address Classes 
- Class A - Class D
- Class B - Class E
- Class C 
- CIDR and how that changes address classes 
Special Address
- loopback address 
- local broadcast address 
Network Masks 


17) Overview of IP addresses:
a) IP Address is a layer3 logical address assigned by an administrator 
b) Unlike MAC addresses which is burnt into NICs by the manufacturer, an IP address is configured by an administrator 
c) The IP address may change within a subnet 
d) Eg: When using DHCP - Dynamic host configuration protocol, IP address resides at layer 3 of OSI model 
e) An IP address is used uniquely identify a device on the network 
-> Similar to how houses are uniquely identified in a street based on address 
f) An IP address is used by routers to determine where that device is 
g) So a router routes traffic to a destination IP address based on hierarchy of network and host 
h) IP Addresses on the internet has to be unique to each other 
i) RFC1918 addresses - private IP addresses 
-> 10.1.1.1 is an example of private IP address as specified in RFC 1918 
-> In lot of organizations today, private IP addresses are used internally and those addresses are natted where the network addresses are translated into the internet
j)  When we ping a particular website we get the following reply 
-> Here we can note that the DOMAIN name is translated to an IP address
-> Here google.com is translated by a protocol called DNS(Domain name service) to an IP address of 2404:6800:4002:822::200e
-> DNS is similar to using a phonebook where we translate human friendly names to phone numbers 

#########
ping google.com

Pinging google.com [2404:6800:4002:822::200e] with 32 bytes of data:
Reply from 2404:6800:4002:822::200e: time=40ms
Reply from 2404:6800:4002:822::200e: time=42ms
##########


18) IP Characteristics

-> Each website is resolved to a different IP address 
-> Apart from ping, we can also use nslookup which does DNS resolution of a domain name. 

IP CHARACTERISTICS 
a) IPv4 is a LAYER 3 PROTOCOL or network layer protocol 
b) IPv4 is CONNECTIONLESS PROTOCOL 
 -> Meaning no sessions are formed when traffic is transmitted 
 -> Transmitter simply sends data without notification to the receiver 
 -> No status information is sent back from the receiver to the transmitter 
  
c) On the other hand TCP - a CONNECTION ORIENTED PROTOCOL 
 -> While TCP is connection oriented. TCP sets up a session. 
 -> So before transmission takes place in TCP, 
   i) Transmitter sends  a SYN or synchronization message to the receiver 
   ii) Then receiver sends a SYN-ACK or synchronization acknowledgment message to the transmitter 
   ii) Then  Transmitter sends ACK message OR acknowledgment to the receiver 
     
   TRANSMITTER ----SYN-----------> RECEIVER 
   TRANSMITTER <---SYN-ACK-------- RECEIVER 
   TRANSMITTER ----ACK-----------> RECEIVER 
               
-> So before any data is transmitted, devices using TCP go through THREE-WAY HANDSHAKE: 
    SYN, SYN-ACK, ACK 
	
-> TCP has the ability to retransmt packets that go missing 
	
e) But IP on the other hand does not do any of that, PACKETS ARE TREATED INDEPENDENTLY  
 -> i.e each packet is treated independently of other packets 
 -> hence packet traffic can take different paths to reach a destination 
 -> Routers will route the traffic via different paths based on parameters like 1) LOAD BALANCING  2) BANDWIDTH 3)HOPCOUNT 
 
f) It is possible that packets from one session take divergent or different paths to get to a destination 

-> In general Routing protocols determine the best path or route from A to B 

-> Eg: RIP will base its routing decisions based on hop count, which is not good, hence RIP not used anymore 
-> Eg: OSPF will base its routing decisions based on bandwidth  to determine the best path 

g) IP is based on hierarchial addressing structure 
-> In ipv4 and ipv6 we have both network and host portion as part of the address 
-> Routers decide their routing decisions based on the network portion of the address, rather than the host portion of the address  

h) IP gives best effort delivery of packets 
-> i.e There is no guarantee of packet delivery. Any packet could be misdirected, duplicated or it could be lost in transmission when sent to a destination 

-> On the other hand TCP which is connection oriented protocol has the ability to retransmit missing packets 
-> UDP which is another layer 4 protocol does not retransmit packets 

i) No data recovery features in IP .
-> If packet gets corrupted for example, end devices need to handle that and not the routers in between 

j) SUMMARY:
-> IP has no built in sessions 
-> No data recovery 
-> No retransmissions 

k) Higher level protocols such as TCP need to handle : dropped packets, corrupted packets, misdirected packets  

19) IPv4 Address format:
a) 32 bit size
b) normally written in dotted decimal notation eg:10.1.1.1 
c) Each value of an ip is 8 bits in size which is also known as OCTET  
d) The total size of the address is 32 bits 
e) IP addresses have hierarchial structure to enable routing 
f) IP address consists of two main parts 
   1) NETWORK PORTION:
   2) HOST PORTION 
   
   
-> Routers do routing in similar way in which DHL or FedEx does routes parcel based on an address 
-> Routers route traffic to a destination address, when unicast packets are transmitted.  
-> Multicast packets use a different mechanism which does routing based on the source address   

Analogy:
DHL or FedEx does routes parcel based on destination address , similarly routers send packets to destinations based on the destination address in the packet 



20) Network Vs Host Portion 
a) IP Address Format Overview:
 
1) NETWORK ADDRESS PORTION(NETWORK ID): Identifies a specific network 
-> Routers maintain routing tables that contain the network addresses. 
--> Important: Routers build their routing tables based on the network address and not on the host address. 
-> Hence Routers dont route packets from one interface to another interace based on IP addresses. They do their routing based on network addresses. 
-> Routers will look at destination IP address in a packet and match  that to a network address in their routing table to determine how traffic should be routed 

2) HOST ADDRESS PORTION(host ID) : 
-> Host ID identifies specific end point on a network such as Server, printer, PC, Iphone, IPad or some other type of devices 

eg: When my ipad is communicating with server(cnn.com), IPad and server will have a TCP session established at layer 4,  but for the  IPad to communicate with the server 
routers need to route the traffic to the server and back again. 


STREET ANALOGY: To explain network and host 
-> In cities throughout the world, you have streets. eg: Oxford street. On the street we have multiple houses or offices. Each house has an individual house number. 
--> Each house number uniquely identifies that specific house on this street.
--> You will not have 2 houses with the same number on the same street. Hence house number needs to be unique on street in a city on the world 

-> To go to address, first we will look on the city first then street and then the House number 

-> Now continuing our analogy on how Routers route: First they will route traffic to a destination network and when traffic gets to that destination network then IP addresses are used to determine which host to forward 
the traffic to.

-> In a similar way: 10.1.1.0(network address) in the network, identifies a specific network somewhere in the world, while host addresses identifies individual devices on that network . suppose pc has host address:1, laptop 2, iphone 3, ipad 4. Then we can use it to identify the specific host. 
-> 5 devices are like 5 unique houses in oxford street example. 
--> like we dont have multiple houses with same house number, we wont have multiple end point devices with same ip address. 


3) Address Vs Network 
Street Names for going from A to B(Google Map) ===   Routers look at NETWORK ADDRESSES To go to remote destination. 
House Number to find exact House in a street   ===   ARP is used to find  host number for a specific host in a network 

4) Router's routing table is not populated with IP addresses, instead it is populated with Network addresses. 
-> Destination IP address in a packet is then matched to the routing table where routing table gets populated with Network addresses 
-> And then a determination is made to decide out of which port or interface of the router, the packet should be forwarded. 


21) IpV4 Address format(Street analogy) Classes:
FORMAT:
a) IP address is 32 bit binary number.
b) IP address is divided into 4 octets
c) Octer: 8 binary bits or 1 byte 

STREET ANALOGY 
a) It is possible to have same house number on different streets 
-> House 1 can be in Oxford street as well as Cambridge street. House 1 should not be appearing twice in Oxford street but it is permitted on different streets . The same  house number is permitted in different street.
-> In the same way it is possible to have number one on network 10.1.1.0/24  as well as 12.1.1.0/24. Similarly same number is permitted on different networks 


22) Address Classes: 
a) Address classes or classful networks are used in internet from 1981 until the introduction of Classless Interdomain Routing(CIDR) in 1993 
-> Prior to 1993, address classes were used to divided the IP version for address space into five address classes 
b) Address Classes 

1) Three classes: Class A, Class B, Class C were used for UNICAST TRAFFIC 
2) ClassD - used for Multicast traffic 
3) ClassE - reserved for future or experimental purposes 

c) Address Classes have been superseded in IP version 6.
Ipv6 - does not use address classes 
IPv4 - address classes replaced with CIDR 

d) CLASS A, CLASS B, CLASS C 
-> To accommodate different sizes of networks 
-> Aided in classification of networks 
-> Address classes were determined by the internet Assigned numbers Authority(IANA) 



e) CLASS A:
-> Suppports 16 million IP addresses 
-> As specified in IANA block list, apple owns 17.0.0.0/8 block.
---> Thus apple has 16 million public ip addresses that are part of class A address. 

f) In the original IP address format class A address consists of 8 network bits and 24 host bits 
-> Hence it is written as /8 denoting 8 network bits 

g) All these were fine, when internet was small, but it quickly becamae a limiting factor and thus multiple addresses were introduced with different size: network portions 
-> Hence we have class A, class B, Class C addresses 

h) Though classful addresses were replaced by CIDR(classless interdomain network), we may still come across commands that use the classful address format. 

eg: network command within routing protocols - RIP routing process 

22) Class A ,Class B, Class C, Class D, Class E addresses
-------------------------------------------------------------------
CLASS A
a) This is the first class of Classful IP addresses 
b) We are looking at first octet of an IPv4 address 
c) First octet always starts with binary 0 
d) Range : 0.0.0.0 to 127.255.255.255

First Octet Binary            Decimal
   0000 0000             =      0 (Reserved) 
   to 
   0111 1111             =     127(Reserved) 

e) Exception 1 - 127 is reserved for loopback 
-> You cannot configure an IP address: 127.0.0.1 on a PC 

f) Exception 2 - 0 is reserved for default network. 
-> Hence 0 cannot be used to configure an IP address on PC 
-> Hence we cannot configure your pc an ip address of 0.1.1.1 

f) Actual usable range after exceptions: 1.0.0.0 to 126.255.255.255 


First Octet Binary            Decimal
   0000 0000             =     1 (Start) 
   to 
   0111 1110            =     126(End) 
   

g) Class A: Network and Host portions 
 
0000 0000.0000 0000.0000 0000.0000 0000
<-------><----------------------------->
Network             host

-> here the first 8 bits denote Network and last 24 bits denote host

-> This is determied by IANA. 
-> So an address like 10.1.1.1 implies that it is Class A address. 
Here 10 indicates network and 1.1.1 indicates hot
-------------------------------------------------------------------
-------------------------------------------------------------------
CLASS B:
a) Starts with binary10(not decimal 10)
b) While in class A address, first bit is set to 0, In class B  the second bit position  in first octet is set to 0
c) Range: 128.0.0.0 to 191.255.255.255 

First Octet Binary            Decimal
   1000 0000             =     128 (Start) 
    ↑
   to 
   1011 1111            =     191(End) 
    ↑
	
d) Hence class B addreses are in range 128 to 191 in the first octet 
   

0000 0000.0000 0000.0000 0000.0000 0000
<------------------><------------------>
Network                   host


e) In class B, first 16 bits indicate network portion and second 16 bits indicate host portion 

-------------------------------------------------------------------

-------------------------------------------------------------------
CLASS C:
a) Starts with binary 110(not decimal 110)
b) While in class A address, first bit is set to 0, In class C  the third bit position  in first octet is set to 0
c) Range: 192.0.0.0 to 223.255.255.255 

First Octet Binary            Decimal
   1100 0000             =     192 (Start) 
     ↑
   to 
   1101 1111            =     223(End) 
     ↑
	
d) Hence class c addreses are in range 192 to 223 in the first octet 
   

0000 0000.0000 0000.0000 0000.0000 0000
<---------------------------><--------->
Network                          host


e) In class C, first 24 bits indicate network portion and last 8 bits indicate host portion 

 
 -------------------------------------------------------------------
 
 -------------------------------------------------------------------
CLASS D:
-> Class D addresses are different to Class A,B,C 

Class A,B,C = Unicast 
Class D= Multicast : One device talking to group of devices 

a) Starts with binary 1110(not decimal 1110)
b) While in class A address, first bit is set to 0, In class D  the Fourth bit position  in first octet is set to 0 
c) Range: 224.0.0.0 to 239.255.255.255 

First Octet Binary            Decimal
   1110 0000             =     224 (Start) 
      ↑
   to 
   1110 1111            =     239(End) 
      ↑
	
d) Hence class D addreses are in range 224 to 239 in the first octet 
   239.1.1.1 is a private multicast address which could be used internally within your organization

0000 0000.0000 0000.0000 0000.0000 0000
<---------------------------><--------->
Network                          host

e) OSPF protocol: Well known multicast address :224.0.0.5 and 224.0.0.6
-> These multicast in the 224 range are called link local multicasts, as these multicasts dont propagate off the local link or the local segment.  
f) Multicasts in this range are often used by Routing protocols such as RIP, OSPF 


e) In class D, first 24 bits indicate network portion and last 8 bits indicate host portion 

 
 -------------------------------------------------------------------
 
-------------------------------------------------------------------
CLASS E:


a)  Class E addresses starts with binary 1111(one, one, one , one ) 
b) Range: 240.0.0.0 to 255.255.255.255 
-> Here 255.255.255.255 is a reserved address for broadcast. 

c) Hence class E addreses are in range 240 to 255 in the first octet 
   

0000 0000.0000 0000.0000 0000.0000 0000
<---------------------------><--------->
Network                          host


-------------------------------------------------------------------
 

23) Special IPv4 Addresses and Directed Broadcast Address 

DIRECTED BROADCAST ADDRESSS:
a) Directed broadcast address is used by hosts to send data to all devices on a specific network. 
b) In Directed broadcast addresses, the entire host portion of the address is populated with binary ones. 

-> For example if we have a network of 172.31.0.0 then the directed broadcast address is 172.31.255.255 
-> Since it is class B address, first two octets denote network  and last two octets denote host portion of the address. 
c) Routers can be configured to route directed broadcasts 
-> It is DISABLED BY DEFAULT. 
-> By default directed broadcast are not routed from one physical interface to another physical interface or from one VLAN to another VLAN 
----> There are hacking utilities that we can download to launch denial of service attacks or DOS attacks by using Directed broadcasts 
--> Hence for security reasons, it is recommended that forwarding of directed broadcasts be disabled. 
-> Thus routers and switches dont forward directed broadcasts from one vlan to another. 

 
 
24) Local Broadcast Address and DHCP
 
 
 
 a) Used to communicate with all devices on the local network .
 b) Address is populated with all binary 1's 
    Binary:          1111 1111.1111 1111.1111 1111.1111 1111
	Decimal:		 255.255.255.255
c) This address is used by a host when requesting an IP address from DHCP server 

-----
DHCP is a client/server protocol that automatically provides an IP host with its IP address and related configuration such as subnet mask and default gateway 
-----


d) HOW LOCAL BROADCAST ADDRESS HELPS IN DHCP SERVER:
-> If host does not have IP address, when host device bootsup, it sends out a local broadcast to the local broadcast address.
-> Then the DHCP server hears that broadcast and then allocates an IP address to the host from a pool of IP addresses 

e) HOW DHCP WORKS AT HOME WIFI
-> At home you may have a broadband or DSL type router providing wireless connectivity at home 
-> When your host connects to that wireless network, DSL automatically allocates an ip address. 

f) Local broadcast addresses are always blocked by layer 3 devices such as routers and Layer 3 switches.
-> This functionality can be overridden by configuring DHCP FORWARDING or DHCP RELAY on routers and switches 

g) For example: If you have PC or device in VLAN10 , but your DHCP server was on different VLAN or different network(VLAN20) 
-> In this case, DHCP request from PC would not be received by the DHCP server by default. 
-> We need to configure IP forwarding or IP DHCP relay on the switch or router to forward the DHCP request to the DHCP server. 

-> In router  we will configure: ip-helper address and specify the DHCP server's IP address on the router or layer3 switch


PC--------------Switch/Router-----------------DHCP server 
VLAN10                                          VLAN20 

--> In our scenario, router or switch still blocks the local broadcast. So when it receives the local broadcast from a pc, it drops it, but sends a unicast dhcp request to the DHCP server on behalf of PC in VLAN10 
-> This then allows the router or switch to proxy the DHCP request on behalf of pc
-> We need to be aware that the traffic sent to 255.255.255.255 is dropped by routers or layer3switches and additional configuration is required on router/layer3switches  , if you want PCs in different VLANs to receive IP address from DHCP server  - because routers/layer3switches drop this broadcast address by default 

25) Local Loopback address:127.0.0.1 for IPv4 and ::1 for IPv6 
--> Useful for testing

a) A device can send a message to itself to verify that the TCP/IP stack is correctly installed on a machine. 
b) Loopback address: 127.0.0.1 
c) But we need to remember that anything in 127 is range in first octet is deemed as loopback address 
-> Which is often seen as one of the big design mistakes of IPv4 . 127 address is a class A address 
-> Class A addresses have 16 million host addresses. By choosing this address range for the Loop back address - We lost the use of potentially 16 million IP addresses 
-> THose addresses cant be allocated as public addresses on the internet. 


b) In IPv6 different loopback addess is used: ::1 

c) Ping to Loopback address: 127.0.0.1 
-> When we ping our IP address or loopback adress from our pc, we will reply for our ping 
-> But important to notice that: ANYTHING IN THE RANGE 127.X.X.X is also a loopback address
-> And anyone of those addresses could be used to test the TCP/IP stack

##########
C:\Users\gs1-maheswarane>ping ::1

Pinging ::1 with 32 bytes of data:
Reply from ::1: time<1ms
Reply from ::1: time<1ms
Reply from ::1: time<1ms
Reply from ::1: time<1ms

Ping statistics for ::1:
    Packets: Sent = 4, Received = 4, Lost = 0 (0% loss),
Approximate round trip times in milli-seconds:
    Minimum = 0ms, Maximum = 0ms, Average = 0ms

C:\Users\gs1-maheswarane>ping 127.125.123.12

Pinging 127.125.123.12 with 32 bytes of data:
Reply from 127.125.123.12: bytes=32 time<1ms TTL=128
Reply from 127.125.123.12: bytes=32 time<1ms TTL=128
Reply from 127.125.123.12: bytes=32 time<1ms TTL=128
Reply from 127.125.123.12: bytes=32 time<1ms TTL=128

Ping statistics for 127.125.123.12:
    Packets: Sent = 4, Received = 4, Lost = 0 (0% loss),
Approximate round trip times in milli-seconds:
    Minimum = 0ms, Maximum = 0ms, Average = 0ms

C:\Users\gs1-maheswarane>ping 127.0.0.1

Pinging 127.0.0.1 with 32 bytes of data:
Reply from 127.0.0.1: bytes=32 time<1ms TTL=128
Reply from 127.0.0.1: bytes=32 time<1ms TTL=128

Ping statistics for 127.0.0.1:
    Packets: Sent = 2, Received = 2, Lost = 0 (0% loss),
Approximate round trip times in milli-seconds:
    Minimum = 0ms, Maximum = 0ms, Average = 0ms
Control-C
^C
C:\Users\gs1-maheswarane>


##########

d) Thus we have wasted IP addresses by using full 127.x.x.x as loopback address in IPv4. 
-> But for IPv6, only ::1 is used as loopback address and hence no wastage of ip addresses 

e) Routers/Switches also have loopback addresses which have different concept to itself than the PCs 
f) Routers and Switches can also be configured with valid IP addresses as LOOPBACK INTERFACE 
-> Hence Routers/ Switches may have loopback interface such as Interface Loopback 0, configured with an IP address. For eg: 10.1.1.1/32 
g) Thus if network engineers refer to loopback address, it means they refer to Routers' loopback interface ip address and not 127.x.x.x 
THUS ROUTERS HAVE LOOPBACK ADDRESSES WHICH ARE NOT THE SAME AS THE LOCAL LOOPBACK ADDRESS 
h) Routers also support 127.x.x.x which helps us to verify the TCP/IP stack, but loopback interfaces are very useful for other things 
-> They are used by routing protocols such as OSPF 

26) RFC1918 - Private Addresses: 
a) RFC : request for comments are formal documents from IETF: Internet engineering task force which are drafted by committee of different vendors and are reviewed by interested parties 
-> RFCs are intended to become internet standards and final version of RFC will become an internet standard and thereafter no changes are permitted to that RFC 
-> However changes or updates can be made in the subsequent RFCs 
-> Thus we find that certain RFCs are superseded by other RFCs and therefore become obsolete 


b) Lot of information we study in networking, originally comes from RFCs 
-> It is important if you want to get into the nitty gritty or details of specific protocols 

-> RFCs can be boring to read :) .
-> However RFC1149 describing IP over AVIAN carriers is in humour and it tells how we can send data using pigeons 

c) Famous RFC: 1918 - discusses private IP addresses 
i) Private IP addresses are non-routable addresses on the internet 
ii) These addresses will be blocked by ISPs and thus cannot be used for sending traffic over the internet 
iii) Private IP addresses will be used internally by organizations and those ip addresses will be NATTed or Address Translated when traffic in sent into thhe internet
iv) RFC1918 define the private address space blocks for private internets 


10.0.0.0        -   10.255.255.255  (10/8 prefix)
172.16.0.0      -   172.31.255.255  (172.16/12 prefix)
192.168.0.0     -   192.168.255.255 (192.168/16 prefix)
 
 
 27) RFC1918 - ClassA,B,C and IPV4 Link Local addresses 
PRIVATE ADDRESSES OVERVIEW:
a) Private IP addresses are non routable on the internet 
b) 3 blocks of IP addresses:
- 1 Class A network 
- 16 Class B networks 
- 256 Class C networks 
c) Private IP Address Range:

10.0.0.0        -   10.255.255.255  (10/8 prefix)
172.16.0.0      -   172.31.255.255  (172.16/12 prefix)
192.168.0.0     -   192.168.255.255 (192.168/16 prefix)

d) Remember: If you are sending traffic internally  from IP address 10.1.1.1 to website such as google.com or facebook.com , your IP address has to be NATed to a public IP address such as 15.1.1.1 
-> Here 15.1.1.1 is a public class A address  and 10.1.1.1 is a private class A address. 


e) IP addresses in private address space will not be accepted by Internet service providers and therefore will not be routed onto the internet, Unless an ISP forgot to add an accesslist blocking traffic from these networks 
f) In this Example, my PC has an IP address of 192.168.29.232 which is not routable, but i am able to ping google.com which has a public ip address of 2404:6800:4002:819::200e
g) This is because my IP address is being NATed by my router when i send traffic to the internet. 
h) NATing - translates private IP address into publicly routable public ip address 
-> Hence we are able to use a private IP address in my local PC, but still able to access devices on the internet. 
-> My private Ip address is being NATed, when i traverse my local internet gateway which could be a simple router at home which helps us in connecting to the internet 


#####ipconfig#
Wireless LAN adapter Wi-Fi:

   Connection-specific DNS Suffix  . :
   IPv6 Address. . . . . . . . . . . : 2405:201:e031:70a3:9d2f:9bac:64c0:720f
   Temporary IPv6 Address. . . . . . : 2405:201:e031:70a3:b074:aea7:e3c7:2834
   Link-local IPv6 Address . . . . . : fe80::dace:1126:a2f6:fd96%5
   IPv4 Address. . . . . . . . . . . : 192.168.29.232
   Subnet Mask . . . . . . . . . . . : 255.255.255.0
   Default Gateway . . . . . . . . . : fe80::267:62ff:fea4:f855%5
                                       192.168.29.1

###########
##ping google.com####

C:\Users\gs1-maheswarane>ping google.com

Pinging google.com [2404:6800:4002:819::200e] with 32 bytes of data:
Reply from 2404:6800:4002:819::200e: time=41ms
Reply from 2404:6800:4002:819::200e: time=43ms
Reply from 2404:6800:4002:819::200e: time=41ms

Ping statistics for 2404:6800:4002:819::200e:
    Packets: Sent = 3, Received = 3, Lost = 0 (0% loss),
Approximate round trip times in milli-seconds:
    Minimum = 41ms, Maximum = 43ms, Average = 41ms
############


28) IPv4 Link - Local Addresses:
a) The next special IP address range is the IPv4 Link - Local Addresses or Dynamic Configuration of IPv4 Link-Local Addresses : RFC3927
b) MICROSOFT refers this address order configuration method as AUTOMATIC PRIVATE IP ADDRESS or APIPA 
c) This is used where a PC is configured for DHCP, but no DHCP servers are available. 
d) So when IP address cannot be allocated via DHCP, PC automatically chooses an IP address in the range: 169.254.0.0/16
e) This allows computers to use link local IP addresses for communication on a local segment. 

-> In old days of Networking, during windows 3.1 - if you wanted two PCs to communicate - we have to either allocate an IP address using DHCP  or manually configure the IP address on PCs to communicate with each other 
-> In these recent days, that is not necessary

f) Because IPv4 link local addresses will allow two computers to communicate with each other even when there are no DHCP servers available  
-> So if you have connected two PCs back to back using a cable - they will be able to communicate with each other without static IP configuration or DHCP configuration 
g) PC would simply use and IP address in this range and will be able to communicate with each other.  
h) Host or PCs will randomly generate the Host specific portion of IP address 
i) So a pc with IP address: 169.254.1.1 can communicate with another PC of IP address 169.254.1.2 and no manual configuration is required. 
-> In this example , we use consecutive addresses, but the addresses chosesn by the hosts are random 
j) We need to be careful with this address range, because it is not routable.
i.e. Hosts can communicate on the local link but their traffic is non-routable 
-> This can cause issues because users will be able to communicate with other devices on the loal segment or local link, but they will not be able to communicate with devices on the internet or devices in a different subnet 
k) So, if you type ipconfig on a pc, for example - and if we see that pc has an address in the range: 169.254.x.x   
 
-> Then it means that PC was not able to get an IP address via DHCP and dynamically allocated itself an IPv4 link local address
---> No DHCP server is available and thus an ip address was not alocated to this device 
------> THUS IT SIMPLY CHOSE AN ADDRESS FROM THE 169.254 address range. 

l) IPv4 Link - Local Addresses Range:
 
Range: 169.254.0.0/16 
       169.254.0.0 255.255.0.0
	   
	   
29) Subnet Masks:
a) What is a subnet mask:
-> A Subnet mask is used to determine network and host portion 
-> This allows a pc to determine whether a device it wants to communicate is a remote device or a local device.  

b) Example:
i) We have a PC with IP address: 10.1.1.1 and another PC with IP address of 10.1.2.1 

PC1(10.1.1.1)----------------------Router
PC1(10.1.1.1)----------------------PC2(10.1.2.1) 

ii) When the PC1 wants to forward traffic to PC2 , do the PC forward the traffic to the local segment  or does it forward it to its default gateway?
-> IF these two devices are in the same subnet , they can communicate directly - wihout the use of default gateway
-> But if they are on different subnets, PCs will forward their traffic to their default gateways which will do the InterVLAN routing, if they are on the local LAN   or route the traffic if the traffic is forwarded to a traditional router 
-> So a layer 3 switch may do the routing between two vlans or a router may route the traffic between these two devices if they are in different subnets 

c) HOW TO DETERMINE IF DEVICES ARE IN SAME SUBNET OR IN DIFFERENT SUBNETS:

i) NETWORK MASK:
-> Network mask allows a device to determine which is the host portion and network portion in an IP address.
-> This allows local PC to determine whether the device it wants to communicate with : is on a remote network (reachable only via default gateway) or if the device is on the local subnet 
-> Thus if the device in on same subnet - we dont need default gateway 
-> Thus if PC1 and PC2 are in same subnet - no default gateway is required. 
---> But if they are on different subnets - default gateway is required 

d) Class A, B and C networks have default masks, also known as natural masks 
-> In ClasA address, first octet is the network portion
-> In ClasB address, first two octets is the network portion
-> In ClasC address, first three octet is the network portion 
-> In ClasA address, first octet is the network
 -> In ClasA address, first octet is the network

   
   
ClassA: 255.0.0.0 
ClassB: 255.255.0.0 
ClassC: 255.255.255.0 

e) Subnetting example1:
-> Class A network that has not been subnetted would have an address/mask pair similar to: 10.1.1.1 255.0.0.0
1) Here default mask is 255.0.0.0 
2) Convert the address and mask to binary numbers 

10.1.1.1   0000 1010.0000 0001.0000 0001.0000 0001
255.0.0.0  1111 1111.0000 0000.0000 0000.0000 0000

1 - Network 
0 - Hosts 

-> Here we can see that network mask consists of continuous ones in the network portion 
---> 1 in binary in network mask indicates network 
---> 0 in binary in network mask indicates host 


3) Technique to find network and host portion in IP:

Portion where subnet is 255 i.e 1111 1111 is network portion and the rest is host portion 

4) Hence this device with IP: 10.1.1.1 is on network 10 and host is .1.1.1

f) Two Simple rules to find Netwok and host portion:
1) Any addres bits which have corresponding mask bit set to 1, represents the network ID
2) Any address bits that have correponding mask bits set to 0, represent the node ID or host portion 

Or in  other words:
 
Portion where subnet is 255 i.e 1111 1111 is network portion and the rest is host portion 



30) HOW DOES PCs CHECK IF HOSTS ARE LOCAL OR REMOTE USING SUBNET MASK: 

PC1(10.1.1.1)----------------------Router
PC1(10.1.1.1)----------------------PC2(10.1.2.1) 
255.255.0.0                         255.255.0.0

When PC1 wants to communicate with PC2:it does the following:
a) PC1 does a logical AND on the network portion of the address 
b) First it determines which portion of its address is the network portion 
c) Then it compares that to the network portion of the device that it wants to communicate with 
d) In our example for IP address: 10.1.1.1
Network portion is: 10.1 i.e the first two octets
e) PC1 checks the first two octets of the other device PC2 to see if it is the same as its own local network portion 
f) Here first two octets are in same in both devices, hence pc1 will send traffic to Pc2 directly and it will not try and send traffic to its default gateway 
g) To send traffic: PC1 will send an ARP message to the local segment requesting MAC address associated with IP address 10.1.2.1 
-> It will try to communicate with 10.1.2.1 on local segment directly and not send the traffic to default gateway 
-> Reason : Network portion of both IP addresses are the same 


31) Another Example:

PC1(10.1.1.1)----------------------Router
PC1(10.1.1.1)----------------------PC2(10.1.2.1) 
255.255.255.0                      255.255.255.0

a) Here PC1 will do a logical AND and check whether network portion of the device that it wants to communicate is the same as its network portion  
b) Based on subnet mask:PC1s network portion is 10.1.1. and PC2's network portion is: 10.1.2.
-> Here the network portion is different. PC1 knows that the device it wants to communicate is on a different subnet 
c) As the devices are in different subnet, PC1 will sends its traffic to its configured default gateway. 
d) PCs will send traffic to their default gateways when a default gateway is configured 

32) Discontiguous Network Mask:
a) Cisco and other vendors dont support discontiguous subnet masks
b) Discontiguous subnet mask will look like this:

11110000.1111 1111.0000 0110.1100 0000=240.255.3.191  

c) Only contiguous subnets masks are supported 

eg:
1111 1111.1111 1111.1100 0000.0000 0000 =255.255.192

d) Contiguous means: Continous 1s or continuous 0s

33) Rules for Subnet Mask:
a) They must start with binary 1s 
b) They must be contiguous 

34) CIDR(Classless interdomain Routing)
a) Introduced in 1993 and it replaces classful IP addresses 
b) Helps to use Variable length Subnet masks(VLSM )
c) Uses notation 10.0.0.0/8 rather than 10.0.0.0 255.0.0.0 notation 

/X Mask(CIDR Notation) 
d) In CIDR notation, we use /X masks

Dotted Decimal                                       Binary Bits
255.255.255.0                                            /24

Dotted Binary
1111 1111.1111 1111.1111 1111.1111 1111.0000 0000        /24

e) Here X is the number of binary 1s in subnet mask 
f) Other examples:
255.255.0.0 /16
8+  8
g) Here also masks must be contiguous 

35) Problem that CIDR solved?

Problems before CIDR:
We had classful A,B,C addresses
----------> Class A address 
-> supports 16 million host addresses  
-> Uses Mask: 255.0.0.0 
----------> Class B Address
-> Supports 65000 host addresses 
-> Uses mask: 255.255.0.0
----------> Class C Address 
-> Supports 254 host addresses 
-> Uses Mask: 255.255.255.0
 
PROBLEM:
a) What happens if a company wants to support 3000 hosts? 
-> Which of these three address classes would the company get? 
-> They could get class B, but that would waste a lot of IP addresses. 
-> Or they could get multiple class C addresses, but that means they are going to allocate many class C addresses.  -> Which has a negative effect on internet routing tables 

SOLUTION:
b) By moving subnet mask in CIDR 
-> While in class A,B,C subnet mask is set on the complete octet boundary, In CIDR subnet masks can be set somewhere in the middle 
c) CIDR subnet masks does not have to be on the octet boundary 

eg: 
Decimal: 225.224.0.0
Binary: 1111 1111.1110 0000.0000 0000.0000 0000

d) So 225.224.0.0 =/11
So Network portion is 11 bits and host portion is 21 bits 

e) CIDR was introduced in 1993 

36) What does Subnettting lessons cover:
a) How to subnet a network 
b) How to derive: maximum hosts that can be supported on a subnet 
c) Which address is the first address or last address 
d) What is the broadcast address for a specific subnet 


36) What is TELNET:
-> Telnet is an application protocol used on internet or LAN to provide a bidirectional interactive text-oriented communication facility using a virtual terminal connection 

37) What is Secure Shell(SSH) 
-> SSH is a cryptographic network protocol for operation network services securely over an unsecured network 

INITIAL DEVICE CONFIGURATION

38) How to connect to a CISCO router or switch - Physically  
a) Traditionally cisco router or switch would have only an RJ45 console port 
-> But these days they have USB ports. 
-> If we connect RJ45 other side of router directly to RJ45 port of laptop, port will be blown
b)Hence, We need to use crossover cable to connect one side to console port of router and other side we will connect to serial port using : DB9 to RJ45 connector , so . SO one side we will use RJ45 and other side of DB9 is connected to serial port of laptop 
-> Instead of using DB9 connector, they created built in DB 9 female connect on one side to RJ45 on the other side 

c) Now today's laptops dont have serial interfaces like this 
-> Hence to connect modern laptops without serial interface to router, we will use USB TO SERIAL CONVERTER and then connect serial to RJ45 cable to connect to router 

d) Now in more modern switches/routers, CISCO started adding USB connector which makes connecting to laptop easier 

---> Thus we have physically connected Laptop and Router 


39) How to connect to CISCO router and Two CISCO switches with laptop:
a) There are two ways to connect to the devices
b) First way: using USB to RJ45 rollover cable 
c) This router device will have 3 console conections 
d) Power up the Router: Cisco 4321 Integrated Services Router
e) Also we have 2 switches : Catalyst 3560- CG and Cx series. Lets power on them also 
f) Next we need to connect another  USB console cable to PC and connect to console of one of the switches .
ALso connect another USB to console of the another switch 
g) So we have 3 connections on LAPTOP
Laptop USB -> Console of router 
Laptop USB -> Console of switch1 
Laptop USB -> Console of Switch2 

h) Now we will use pUTTY in laptop to connect to the device 
--> Putty is a terminal emulation program

---> We use Putty only in Windows, For MAC/Linux we have built in terminal emulation program 

i) In Putty, we will choose serial interface ,
-> to specify which serial port-> go to laptop -> device manager -> Ports-> We can see the serial port  as COM7 
--> In putty specify SERIAL Line as : COM7 , leave everything else and default and click open 

ii) Now we will have a connection to switch in Putty 

c3560-CX>
c3560-CX>
c3560-CX>

iii) Now by default it will be user mode and type enable to go to privilege mode 

c3560-CX>
c3560-CX>en 
c3560-CX# 

i) This swithch: 3560-CX already has a configuration in it 
j) Then use: erase startup-config to erase the device 
k) Now in meanwhile we will connect router to one of the USB ports and switch to one of the USB serial ports and also connect the another switch 

l) Switch configuration:
1) hostname C3560CX 
2) copy running-config startup-config 
-> this commands saves running config in memory to hardrive, i.e we are saving the configuration 
3) wr  ->  is old command for saving:



40) Router Initial Configuration: 
a) In putty after physical connection, select serial and give Serial line with specified port 
b) We can configure the same in packet tracer: for ISR4321 and after clicking CLI, we can see that the router is booting up 

##
Would you like to enter the initial configuration dialog? [yes/no]: no


Press RETURN to get started!



Router>
###
c) Add a pc to my packet tracer topology and in connections select blue cable which is a console cable 
-> Using console cable , connect rs232 interface of pc to console  of router 

#########
-> In telecommunications, RS-232 is a standard introduced in 1960 for serial communication transmission of data 

-> A computer with an RS232 serial port can communicate with the serial port of an embedded system such as router, as an alternative to monitoring over ethernet 

###########



d) ROuters have auxillary ports and console ports 
-> Auxillary ports used in old days to connect modems to a router, so that you could phone the router to use an outer band connection configure it 

e) In desktop -> terminal, we can see that we are connected from pc to router by using packet tracer 

f) In packet tracer, lets add two switches 3560 and 3650 

g) Add another pc to the topology , connect rs232 of new pc to console port of 3560 switch 

h) On pc -> go to desktop --> terminal -> we can see switch booting up and we say no initial configuration dailog and enter privileged mode 

####

Cisco IOS Software, C3560 Software (C3560-ADVIPSERVICESK9-M), Version 12.2(37)SE1, RELEASE SOFTWARE (fc1)
Copyright (c) 1986-2007 by Cisco Systems, Inc.
Compiled Thu 05-Jul-07 22:22 by pt_team


         --- System Configuration Dialog ---

Would you like to enter the initial configuration dialog? [yes/no]: no


Press RETURN to get started!



Switch>en
Switch#
####


41) Build a basic CISCO network:  
a) Add two ISR4321 routers .
b) Add 3650 switch to the topology to physically cable these devices use a straight through copper cable from first gigabit ethernet of router to first gigabit ethernet of switch and also connect another router to switch 
c) Power the switch 
d) One diff between switch and routers, switch interfaces come up by default, but router interfaces dont come up by default .we need to use no shutdown command of router 

e) Configure the router 


########
Router>en
Router#conf t
Enter configuration commands, one per line.  End with CNTL/Z.
Router(config)#in
Router(config)#interface 
Router(config)#interface 
Router(config)#interface g
Router(config)#interface gigabitEthernet 
Router(config)#interface ?
  Dialer            Dialer interface
  Dot11Radio        Dot11 interface
  Ethernet          IEEE 802.3
  FastEthernet      FastEthernet IEEE 802.3
  GigabitEthernet   GigabitEthernet IEEE 802.3z
  Loopback          Loopback interface
  Port-channel      Ethernet Channel of interfaces
  Serial            Serial
  Tunnel            Tunnel interface
  Virtual-Template  Virtual Template interface
  Vlan              Catalyst Vlans
  range             interface range command
Router(config)#interface Gi
Router(config)#interface GigabitEthernet 0/0/1
Router(config-if)#end
Router#
%SYS-5-CONFIG_I: Configured from console by console

Router#show ip int brief
Interface              IP-Address      OK? Method Status                Protocol 
GigabitEthernet0/0/0   unassigned      YES unset  administratively down down 
GigabitEthernet0/0/1   unassigned      YES unset  administratively down down 
Vlan1                  unassigned      YES unset  administratively down down
Router#
#########


f) Configure and Bringing up interface in router 

#####
Router>en
Router#conf t
Enter configuration commands, one per line.  End with CNTL/Z.
Router(config)#int g
Router(config)#int gigabitEthernet 0/0/1
Router(config-if)#ip address 10.1.1.1
% Incomplete command.
Router(config-if)#ip address 10.1.1.1 255.255.255.0
Router(config-if)#no 
Router(config-if)#no sh
Router(config-if)#no shutdown 

Router(config-if)#
%LINK-5-CHANGED: Interface GigabitEthernet0/0/1, changed state to up

%LINEPROTO-5-UPDOWN: Line protocol on Interface GigabitEthernet0/0/1, changed state to up

#########

g) Now immediately we can see in packet tracer that interface is green for router 

h) edit host name and save the configuration

##########
Router(config-if)#no shutdown 

Router(config-if)#
%LINK-5-CHANGED: Interface GigabitEthernet0/0/1, changed state to up

%LINEPROTO-5-UPDOWN: Line protocol on Interface GigabitEthernet0/0/1, changed state to up

Router(config-if)#
Router(config-if)#exit
Router(config)#h
Router(config)#hostname R1
R1(config)#cop
R1(config)#copy ru
R1(config)#copy run
R1(config)#end
R1#
%SYS-5-CONFIG_I: Configured from console by console

R1#op
R1#cop
R1#copy ru
R1#copy running-config st
R1#copy running-config startup-config 
Destination filename [startup-config]? 
Building configuration...
[OK]
R1#
########


i) Now configure another Router R2

######
Router>en
Router#conf t
Enter configuration commands, one per line.  End with CNTL/Z.
Router(config)#host
Router(config)#hostname R2
R2(config)#int
R2(config)#interface ?
  Dialer            Dialer interface
  Dot11Radio        Dot11 interface
  Ethernet          IEEE 802.3
  FastEthernet      FastEthernet IEEE 802.3
  GigabitEthernet   GigabitEthernet IEEE 802.3z
  Loopback          Loopback interface
  Port-channel      Ethernet Channel of interfaces
  Serial            Serial
  Tunnel            Tunnel interface
  Virtual-Template  Virtual Template interface
  Vlan              Catalyst Vlans
  range             interface range command
R2(config)#interface Gi
R2(config)#interface GigabitEthernet 0/0/0
R2(config-if)#end
R2#
%SYS-5-CONFIG_I: Configured from console by console

R2#show ip int
GigabitEthernet0/0/0 is administratively down, line protocol is down (disabled)
  Internet protocol processing disabled
GigabitEthernet0/0/1 is administratively down, line protocol is down (disabled)
  Internet protocol processing disabled
Vlan1 is administratively down, line protocol is down
  Internet protocol processing disabled

R2#int
R2#inter
R2#con
R2#conf t
Enter configuration commands, one per line.  End with CNTL/Z.
R2(config)#int
R2(config)#interface gi
R2(config)#interface gigabitEthernet 0/0/0
R2(config-if)#no shutdown

R2(config-if)#
%LINK-5-CHANGED: Interface GigabitEthernet0/0/0, changed state to up

%LINEPROTO-5-UPDOWN: Line protocol on Interface GigabitEthernet0/0/0, changed state to up

R2(config-if)#ip address 10.1.1.2 255.255.255.0
R2(config-if)#end
R2#
%SYS-5-CONFIG_I: Configured from console by console

R2#wr
Building configuration...
[OK]
R2#
########


j) Now if we do ping from one router , ping will succed. for our topology 

R1<---->Switch S1<----->R2 


#######
Router>en
Router#conf t
Enter configuration commands, one per line.  End with CNTL/Z.
Router(config)#host
Router(config)#hostname R2
R2(config)#int
R2(config)#interface ?
  Dialer            Dialer interface
  Dot11Radio        Dot11 interface
  Ethernet          IEEE 802.3
  FastEthernet      FastEthernet IEEE 802.3
  GigabitEthernet   GigabitEthernet IEEE 802.3z
  Loopback          Loopback interface
  Port-channel      Ethernet Channel of interfaces
  Serial            Serial
  Tunnel            Tunnel interface
  Virtual-Template  Virtual Template interface
  Vlan              Catalyst Vlans
  range             interface range command
R2(config)#interface Gi
R2(config)#interface GigabitEthernet 0/0/0
R2(config-if)#end
R2#
%SYS-5-CONFIG_I: Configured from console by console

R2#show ip int
GigabitEthernet0/0/0 is administratively down, line protocol is down (disabled)
  Internet protocol processing disabled
GigabitEthernet0/0/1 is administratively down, line protocol is down (disabled)
  Internet protocol processing disabled
Vlan1 is administratively down, line protocol is down
  Internet protocol processing disabled

R2#int
R2#inter
R2#con
R2#conf t
Enter configuration commands, one per line.  End with CNTL/Z.
R2(config)#int
R2(config)#interface gi
R2(config)#interface gigabitEthernet 0/0/0
R2(config-if)#no shutdown

R2(config-if)#
%LINK-5-CHANGED: Interface GigabitEthernet0/0/0, changed state to up

%LINEPROTO-5-UPDOWN: Line protocol on Interface GigabitEthernet0/0/0, changed state to up

R2(config-if)#ip address 10.1.1.2 255.255.255.0
R2(config-if)#end
R2#
%SYS-5-CONFIG_I: Configured from console by console

R2#wr
Building configuration...
[OK]
R2#
######


42) IP Subnetting: 
-> This lesson helps us to learn the following:
PART1:
● What Subnet is this host on
● What is the last host on this subnet 
● Method1 - Binary Method 
● Method2 - Quick Method 

-> IP Address
	► Subnet Address
	► 1st Host Address 
	► Last Host Address 
	► Broadcast Address 
	

PART2:
● Creating Multiple subnets when given a specific network or subnet 
-> Subnet this network into atleast 10 subnets 
-> Subnet this network into subnets each having 10 hosts on them 


43) IP Subnetting - Problem:
 
Given a PC with IP address and Router 

PC1(192.168.10.18/24)-----------------(Router) 
► What IP address would router1 be configured with, if it is to use the first IP address in the same subnet as PC1
► What broadcast address is in use by PC1 
► What IP address would Router1 be configured with, if it is to use the last IP address in the same subnet as PC1?
► What Subnet is PC1 part of? 


44) BINARY-METHOD:RULES

1) To derive NETWORK/SUBNET ADDRESS, Fill Host Portion of address with binary 0s 
  --> i.e Identify subnet mask 
  i.e Identify network and host portion and fill host portion with binary 0s. 
2) To Derive BROADCAST ADDRESS, Fill the host portion of the address with binary 1s 
3) To derive FIRST HOST IN THE SUBNET, fill the host portion of the address with binary 0s except the last bit, which is set to binary 1
4) To derive LAST HOST IN THE SUBNET, fill the host portion of the address with binary 1s except for the last bit, which is set to binary 0 





a) EXAMPLE 1:

PC--------------------------------------ROUTER 
192.168.1.18/24 or 
192.168.1.18 with 
subnet mask: 255.2555.255.0 

NETWORK PORTION/SUBNET: 192.168.1.0
Host Portion: .18
BROADCAST: 192.168.1.FF = 192.168.1.255

Host: 0001 0010 = Dec 18
FIRST HOST: 0000 00001 = Decimal:1 =192.168.1.1
LAST HOST:  1111 11110 =128+64+32+16+8+4+2+0=254 =192.168.1.254

b) EXAMPLE 2: 
PC-----------------------------------Router 
172.16.35.123/20
172.16.35.123 255.255.240.0 

0 1
1 2
2 4
3 8
4 16
5 32
6 64
7 128



0010  0011 .0000 0000
0010  0000 .0000 0001
0010  1111 .1111 1110
0010  1111 .1111 1111


NETWORK PORTION/SUBNET: 172.16.32.0
FIRST HOST:    172.16.32.1
LAST HOST:     172.16.47.254
BROADCAST:     172.16.32.47.255


Example 3: 192.168.29.232/24

NETWORK PORTION/SUBNET: 192.168.29.0
FIRST HOST:    172.16.29.1
LAST HOST:     172.16.29.254
BROADCAST:     172.16.29.255
			   
			   
Example 4: 172.16.129.1/17

0 1
1 2
2 4
3 8
4 16
5 32
6 64
7 128

NETWORK PORTION/SUBNET: 172.16.1000 0000.0000 0000 172.16.128.0
FIRST HOST:    172.16.1000 0001.0000 0000   172.16.1000 0000.0000 0001 172.16.128.1
LAST HOST:     172.16.1000 0001.0000 0000   172.16.1111 1111.1111 1110 172.16.255.254
BROADCAST:     172.16.1000 0001.0000 0000   172.16.1111 1111.1111 1111 172.16.255.255


45)Quick Method - Rules 

short cut table 
128		64		32		16		8		4		2		1
128		192		224		240		248		252		254		255

-> Row 1: Decimal equivalents for binary values of an octet with first digit of binary 1 


EXAMPLE 1:
172.16.35.123/20
172.16.35.123  255.255.240.0

STEP 1: Find where subnet mask is not equal to 255: 240
STEP 2: Take note of that octet :240
STEP 3: Subtract mask value that is not 255 from 256 :256-240=16
STEP 4: Find where 35 is in the range of networks worked out in step3 
-> In step 3, we noted 256-240=16, so our networks is in multiples of 16 
-> So just staart at zero and go until you pass the value in the question

Networks in multiples of 16:
Ist network =0
2nd Network=16
3rd network =32
4th network =48 

-> Here 35 is between 32 and 48 

---> Thus we can infer that 182.16.35.123 is in network 172.16.32.0 
-> Thus we identified the SUBNET AS: 172.16.32.0 
-> Next subnet is: 172.16.48.0

STEP 5: 
BroadCast = NextNetwork -1 
=172.16.48.0 -172.16.47.255
First Host: subnet+1=172.16.32.1
Last Host: Broadcast-1
Broadcast: 172.16.47.254

46) Subnetting - best way
->Using binary method  and with extra shortcuts 

a) How to find NUMBER OF HostS= 2^n-2 
b) Count host bits from right to left 
C) how to find number of networks : 2^n 
d) Count network bits from left hand side to the right hand side 


47) Example Question: 
ABC Ltd has been allocated subnet 10.1.1.0/24 for a small office in London paul. The network administrator needs to split the subnet into smaller subnets. Each subnet needs to support 14 machines . 
Find Number of host 

Number of host -> 2^n -2 = 2^4-2 =16-2=14 
-> so 4 binary bits will allow us to support 14 hosts per subnet 
-> Thus we now know that we need to take 4 bits from host portion and allocate that to network portion, to create multiple subnets each with 14 hosts  

No of subnets formula 2^4=16 and each subnets supports 2^4-2 =14 


..Not able to understand...


48) Example 2:
ABC Ltd have been allocated subnet 10.128.192.0/18 for several offices in the USA. Paul a network administrator needs to split the subnet once again into smaller subnets. 
Paul requires 30 subnets with as many hosts possible 
---How to do that?  

STEP1: DECIDE WHICH FORMULA TO USE? 
-> Since we have been asked to find NETWORKS/SUBNETS we need to use the FORMULA 2^N and not 2^n-2 
-> Also we need to count bits from LEFT TO RIGHT HAND SIDE since we count right to left only for Host bits while finding number of hosts 

Step2: Workout HOW MANY BITS REQUIRED TO COVER THE NUMBER OF NETWORKS(30) that we have been asked for . 
-> Since in question they require: 30 subnets and using formula

Networks =2^n
32=2^5 
---> so we need 5 bits in binary . Using 5 bits we will end up with 32 subnets rather than 30 
--> THus we need to steal 5 bits from host portion of address and allocate it to the network portion 

STEP3: CONVERT HOST PORTION OF ORIGINAL NETWORK INTO BINARY
Original Network: 10.128.192.0/18 
Original Network in binary: 10.128.1100 0000.0000 0000



Network   |  Network/Host | Host 
10.128    |       19 2    |  0
10.128.11 | 00 0000.      |0000 0000

a)  Thus network portion is     : 10.128
		network/host portion is: 192  
		Host portion           : 0 





STEP4: ALLOCATE 5 BITS OF HOST GIVEN TO SUBNET PORTION 
-> Now we are going to take 5 bits from the host portion and allocate that to the subnet, so the network portion becomes:

Network  |subnet| Host 
10.128.11|00 000|0.0000 0000

AFTER ALLOCATION: 
-> Thus network portion is     : 10.128. 11
		subnet portion is      : 0 0000  
		Host portion           : 0.0000 0000 

-> Thus we have stolen 5 bits from host portion and allocated it to the subnet portion of address
-> Thus the total number of bits in network/subnet portion = 8+8+2+5=23 bits   
 
STEP5: WORKOUT THE NEW SUBNETS: 
-> To workout new subnets, go through various binary combinations for the subnet portion of the address 

		Network  |subnet| Host 
Ist		10.128.11|00 000|0.0000 0000 =10.128.192.0/23
2nd		10.128.11|00 001|0.0000 0000 =10.128.194.0/23
3rd		10.128.11|00 010|0.0000 0000 =10.128.196.0/23
4th		10.128.11|00 011|0.0000 0000 =10.128.198.0/23
...................................
Last	10.128.11|00 000|0.0000 0000 =10.128.254.0/23

49) Subnetting Lab 1:
CONFIGURE NETWORK AS FOLLLOWS:
1) You have been allocated subnet 192.168.1.0/24
Subnet this into 4 subnets as follows
2) Subnet1 for site1
3) Subnet2 for the link between R1 and the internet router 
4) Subnet3 for site2
5) Subnet4 for link between R2 and Internet router
6) Configure Routers as per instructions in diagram
7) Configure switches with second last ip address in subnet 
8) Configure the DHCP servers with the third last IP address in subnet. 
And configure the DHCP server to allocate ip addresses to clients 
9) Verify that PCs can access cisco.com and facebook.com using their browsers 

a) In this network, we need to subnet 192.168.1.0/24 into 4 subnets 


a) Take 192.168.1.0/24 and Subnet this into 4 subnets 
-> Determine network and host portion
-> Here 192.168.1 is network portion  and .0 is host portion 

network   | Host
192.168.1 | 0000 0000


b) We can't change network portion, but we can manipulate and change the host portion of the address.  
c) When we subnet, we steal bits from the host portion
-> We need to workout on how many bits are required for the subnets we need:


###
2 FORMULAE IN SUBNETS:
a) 2^n  -> used for when asked for subnets 
b) 2^n-2 -> used when asked for certain no of hosts
-> Used when we are asked to subnet the network say:192.168.1.0/24 and create as many subnets as possible, each having 4 hosts 
####


2^n=4, so n=2.
d) So we will steal 2 bits from host portion to accomodate 4 subnets 

d) After stealing, division comes like below 


network   |Subnet |Host
192.168.1 |.00    |00 0000

-> now network comes from /24 to /26 subnet 
i.e 192.168.1.0/26

e) Now we will apply different binary values for the subnet portion 

network   |Subnet |Host
192.168.1 |.00    |00 0000 =192.168.1.0/26
192.168.1 |.01    |00 0000 =192.168.1.64/26
192.168.1 |.10    |00 0000 =192.168.1.128/26
192.168.1 |.11    |00 0000 =192.168.1.192/26

f) Thus we have created 4 subnets as part of the exercise 

50) 
Given two IPs 10.1.1.1 and 10.1.2.2 
ARE DEVICES IN SAME SUBNET OR IN DIFFERENT SUBNET? 
a) Can these hosts ping each other, Are they on the same subnet?
-> We need SUBNET MASK to answer the question 
b) When one device want to ping another device, it needs to determine whether the other device is in the same subnet as itself .
-> It checks whether the other device is in same subnet, by checking the subnet mask and determines if the network  portion of the address is the same or different.
-> If the NETWORK PORTION IS SAME, MEANING ON SAME SUBNET, and if ethernet is used, then the device will send out an ARP, to workout which MAC address is associated with the IP address. 
-> If THE OTHER DEVICE IS ON DIFFERENT SUBNET, device will forward the traffic to its default gateway 

####ENABLING DEBUG IN ROUTER######

1) #ip packet 

2) disabling debug 
#un all 

3) debugging ping
#debug ip icmp

4) sh cdp nei
-> command shows if two devices are connected each other

##############

c) Thus Two devices can ping each other, if they are in same subnet

51) Can these two PC's ping each other 

PC1(10.1.255.1/17)----------PC2(10.1.128.2/17)

CONDITION FOR TWO DEVICES TO BE IN SAME SUBNET:
a) Network portion should match each other. 
-> We can identify network portion using SUBNET MASK 


CABLING AND PACKET FLOWS: 
52) How does data flow in HUBS, SWITCHES AND ROUTERS 
a) In this lesson, we will see how data flows through devices in the network 
-> How does data flow through a hub, switch or a router?
-> Is the data flooded out of all ports or is it only sent out of an individual port. 

b) Data in different devices 
SWITCH - frame 
ROUTER - packets 

c) We will see how data flows in a network 

d) Outline of this lesson:
1 Introduction to different tpes of communication in data network 
2 Unicast vd Multicast Vs Broadcast traffic 
3 CSMA/CD
    CS- Carrier sense 
	MA - Multiple access
	
	CD - Collision detection 
	
4 Bridges/Switches/Routers 
5 How PACKETS FLOW through those different devices 

53) Basic types of communication 
a) Unicast: One to one 
-> One device speaks to one other device
-> One to one communication 

b) Broadcast: One to All
-> One device sends traffic to all devices in the same subnet or in the entire network 
-> Broadcast to the local subnet means that all devices in the same subnet receive the broadcast 
-> Broadcast to all hosts means broadcast goes to all the devices in the entire network 

-> In real world implementations, broadcasts are blocked by layer 3 devices such as routers, layer3 switches 
-> Broadcast can cause problems, hence they are contained or limited 

---> Broadcast can be useful, if 2 windows machines are configured with same name. You will receive warning about that because broadcast is sent by those devices on the local network.

-> Since broadcast caused lot of problems in IPv4 networks, broadcast support has been removed in IPv6 

c) Multicast: One to Some 
-> One device can speak to many devices, but it gets rid of some of the issues related to broadcast  
-> While broadcast sends traffic to people that dont necessarily want the traffic, Multicast sends traffic to only those devices that subscribe to the multicast. 
-> Analogy: Broadcast is like a spammer while multicast is like a subscription service 


54) Ethernet History 
a) OSI model Overview:

Layer4 - Transport - TCP/UDP 
Layer3 - Network Layer - IPv4 or IPv6 address 
Layer2 - Datalink layer : Mac Address 
Layer1 - Physical : RJ 45



 
b) Ethernet was born in 1970s 
-> Robert Metcalf was one of them involved in Ethernet development and started a company 3 com in 1979 which was subsequenlty purchased by HP 

c) Ethernet and networking is very young when compared to telephony environments
-> While ALexander grapham bell invented telephony systems long ago before Ethernet was invented 

HISTORY OF ETHERNET: 
-> In original ethernet implementation, network architecture that was in use was a Bus topology
-> Each bus topology, each device is connected to a single cable and clients therefore share a comunication line or bus 
-> This is similar to telephone party line where we use telephone cable to provide telephone services to remote areas. 
--> In that example, you would have a single cable and multiple telephones would hang off the so called party line. 
-> Now before you made a call in those days, we have to listen to hear if anyone else was speaking. Hence before you make a call, you would pick your handset and listen and thus make sure no one else was using the line 
-> When someone made a call to that telephone line, all telephones connected to the party line would ring . The same thing happens in an Ethernet environment when using a 
bus topology 
-> When traffic is sent on that cable, it is received by all devices connected to the bus. This is the shared infrastructure and it means that - when any device on that network sends traffic, all other devices 
conneted to the same cable will receive the traffic 
-> When a device wants to speak or communicate, it needs to ensure that no other device is speaking. Otherwise collision can occur. 

--> In some of the original implementations of Ethernet, we had : 10base5 

10base5 or THICKNET:
-> It had maximum segment size of 500 meters 
10base2
-> Another physical implementation known as 10base2 has a maximum distance of 185 meters 
-> These early implementations of Ethernet use a bus topology - which means when a device on the cable sends a signal all devices connected to that cable will receive the signal 
 
 
55) 10base2, MAC addresses
-> Implementation of 10base2
-> 10base2 use coaxial cable and here 10 indicates that it had a maximum speed of 10mbps 
-> 2 indicates maximum segment length(185 meters) 
-> base means baseband
->  Ehternet 10Base2 uses coaxial cable. The sepcifications are different to the coaxial cable used in cable television 
--> coaxial cable running a baseband signal can only transmit or receive a single signal at any given time 
-> Broadband uses coaxial cable, that allows for multiple signals to be sent across the wire at any given time. 


Ethernet uses baseband signaling. i.e 10Base2 or 10Base5 in the past. In 10Base2, coaxial cable was used. 
-> BNC connectors were used to connect devices to the network. 
-> Single piece of cable which have BNC tconnectors will allow you to connect devices to a single cable. 
Multiple devices are connected across single cable and at the end you would have terminators to stop signals bouncing back.
-> When signal is transmitted across the wire, it should not bounce back and cause collisions. Hence terminator would terminate the signal, to ensure that it did not bounce back.   
--> The reason for doing this is, because baseband is used. 
-> Baseband only allows a single signal to be sent across the wire or cable at any time. 



 

56) MAC Address: 
a) Total 48 bits  = 6 bytes 
b) 3 bytes Organizationaly unique identifier(OUI)/ Network Interface controller(NIC) specific 


Most significant<------------OUI(3bytes)---->|<----NIC specific------------------>Least significant 

c) In OUI, firstbyte, that first 8 bits in MSB:
<------8bits------>
b8/b7/b6/b5/b4/b3/b2/b1 

-> Here b1 the least significant bit: if it has value 0 then it indicates unicast 
                                      if it has value 1 then it indicates multicast 
									  -> This bit is very helpful/efficient for Ethernet switches to know whether they should flood the frame out of all ports 
									  -> When multicast traffic is received by layer2 switch, that traffic is flooded out of all ports  
									  -> Whereas unicast traffic is not flooded 
									  -> Thus by reading b1, switch knows how to process traffic 
->b2 -> Second least significant bit in the first octet:
       ->0 globally unique(OUI enforced) 
       ->1 locally administered - means an administrator has changed the mac address. 	  


57) CSMA/CD: 
In ethernet when a bus topology is used , devices use carrier sense multiple access/collision detection    [CSMA/CD]

a) When a device wants to send traffic - it should first check to hear if any other device is speaking.  
-> Thus device will not communicate to the network if it hears another device. - This is called carrier sense 
CARRIER SENSE is essentially sensing the network to hear if another device is speaking. 
MULITPLE ACCESS means that any device can communicate across that segment as long as no other device is communicating 

-> In Ethernet we use distributed environment - where each device can communicate independently across the network without permission from other devices. 
-> However a device should only send traffic if no other device is speaking - in order to avoid collisions in an ethernet environment. 


b) If collisions happen in ethernet, there is an option in ethernet to detect collisions. 
-> When a device detects that a collision has taken place, it may send a backoff or jamming signal to indicate that a collision has taken place.   

c) In the given scenario, it may happen that if two devices want to communicate at exactly the same time - and if no devices are speaking at that time 

A --- C 
D --- B 


-> If A wants to communicate with C and  D with B , in line with CSMA/CD - Both A and D firstly checks if anyone is speaking 
--> They use carrier sense or CS too check the wire 
-> No devices are communicating on the network at this point of time . But because of multiple access the cable without permission from other device. 

-> But since it is baseband or 10base2 , only one signal is allowed across the wire at any given time.  Hence here collision takes place. 

d) If the trasmitting data station or pc detects another signal on the wire while transmitting its frame, it will stop transmitting that frame and then send a jamming signal 
as well as waiting a random period of time known as backoff delay before trying to send the signal again. 
-> This will prevent PCs or machines from repeatedly attempting to transmit at the same time. 

e) However probability of collisions becomes greater as the cable length increases and as more devices are added onto the network. 
-> Hence longer cable length and more devices  means more collisions 

f) So as you add more and more devices to this network and extend the cable length - the probability of collisions increases dramatically. 

58) OTHER ISSUES WITH 10 BASE2 APART FROM COLLISIONS
a) Cable Length - longer the cable, greater the signal degradation 
b) Cable breaks - cable break at any point would cause the entire network to fail 
c) 10base2 means 10 megabits per second ethernet 
-> This is not 10mbps for each device, it is shared between all devices on that segment. 
-> In addition because of collision, you can use only between 30 and 40%  utilization 
d) Collisions increase dramattically above the utilization 
e) SINGLE COLLISION DOMAIN - if collision takes place at any point in time in the network - all devices in the network are affected by that collision and would need to backoff 
f) SINGLE BROADCAST DOMAIN: - if device like A sends a broadcast,everyone in the network would receive the broadcast and would need to process the broadcast. 
-> When a device receives the broadcast, it will process it i.e it receives it on the network interface card and then forward it to the upper layers in the osi model  
-> Thus a CPU of PC will be interrupted when pc receives the broadcast , so if a device A starts sending many many broadcasts onto the network - those broadcasts will be received by all the devices in the network 
and every device would be interrupted and would have to process the broadcast. 
-> If A was sending a broadcast, but the traffic was intended only for B - both C and D would still receive the broadcast, process it and drop it. 
-> The main problem here is : their CPUs were interrupted which will cause the CPU to slow down. 
g) --------------> Hence because of issues with maximum segment length/ maximum hosts on segment and cable breaks - 10BASE2 is replaced with 10BASET 
-> 10base2 is almost absent in today's networks 

59) 10BASET or Twisted pair Ethernet : Here 10 means 10MBPS  and Base means BASEBAND and not broadband and T means TWISTED PAIR with a maximum segment size of 100 meters
a) 10BaseT Uses unshielded twisted pair cables.  
-> Shielded twisted pair cables may be used in noisy environments especially when network cables are close to electric cables. 
10BaseT - refers to the use of cable that contains insulated copper wires twisted together in pairs with a maximum distance of 100 meters
b) Here cable is thinner and more flexible than coaxial cable which was used in both 10base2 or 10base5 networks 
c) Here we use RJ45 connectors for 10BaseT cables 

UNSHIELDED TWISTED PAIR(UTP)
d) UTP is a set of 4 pairs of wires in a pair being twisted around the other, to prevent electro magnetic interference  
4 pairs of wires make up the UTP which is used in Ethernet 
e) Each wire has a color coded plastic insulation and the wires are inside an outer jacket. 
f) In an ethernet environment, the wires connect to an RJ45 connector 
g) The advantage of UTP or untwisted pair is : its less expensive and easier to install than other cabling implementations 


60) Pin positions in RJ45 connector 
a) There are two main implementations T568A pair nad T568B pair . and there is slight difference with the pairing of cablings in each implementation 
b) TIA/EIA-568 was developed to define standards for telecommunications cabling systems. 
EIA means Electronic industry alliance which is a standards based organization.  
c) EIA-568C describes structured cabling standards 
d) Difference between A and B is the pairing of cabling. 


61) Straight through cables:
a) Straight through cable is a type of twisted pair copper cable used most oftne in LAN 
-> In a standard straight through cable, each pin on the connected on one end is connected to  the correponding pin on the other connector. 

--> In other words, pin 1 on the MDI device(PC) is  conneected to pin 1 of the MDIx device(HUB) 
b) MDI: MEDIA DEPENDENT INTERFACE IS AN ETHERNET PORT CONNECTION TYPICALLY USED ON NICS OF PCS 
c) MDI is also used by routers and can be used in Uplink ports of Ethernet switches 
d) In certain older switches we will see a button normally on the uplink port that allows you to change how that port operates 
-> We can change the mode from MDI to MDIX or back again. 
-> This helps to connect one switch to another switch using a straight through cable rather than using a crossover cable. 


e) HUBS - 10baseT 
-> In the past, you may have connected your pc to a hub using a straight through cable. 
f) Now straight through cables are used in situations where 
-> You connect: a pc to a switch 
              : PC to a bridge 
			  : PC to a hub 
f) In the past, when connecting devices of the same type such as two PCs, or two routers - a crossover cable will be used. 
g) When we have two MDI devices i.e two PCs which needs to communicate , hence a crossover cable will be required. 


62) CABLES TO USE AND CABLE CATEGORIES
a) Cross over cable - Gigabit T568B 
-> GigabitEthernet standard requires that all pins be connected 

b) STRAIGHT THROUGH CABLES:
-> Router to Switch 
-> PC to Switch 
-> PC to Bridge 
-> PC to Hub 

c) CROSS OVER CABLES: 
-> Router to Router 
-> Switch to Switch 
-> PC to PC 
-> Hub to Hub 

-> Bridge to switch 
-> PC to server 
-> Hub to Switch 
-> Router to Router 

d) Auto MDI/M
-> However today automatic  crossover or auto MDIX is widely used 
-> Auto MDIX was introduced in 1998 which made cross over cables obsolete. 

WHAT ARE MDI DEVICES 
-> Routers or PCs

WHAT ARE MDIX DEVICES:
-> Typically switches or hubs 
-> They are medium dependent cross over(MDIX) devices 

e) In the past, you would need to connect an MDI device such as PC to a switch or hub. 
-> In old days, certain ports would have a button to flip the role from MDIX to MDI which would allow you to connect a switch  to switch using a straight through cable. 

TODAY/CURRENTLY 
f) However today in a lot of cases, auto MDI/MDIX allows for automatic switching once a cable is connected.  
g)  The devices can auto detect the cable type whether crossover/straight through  , hence no need to worry as much about cable types today 
h) Eg: A straight through cable can be used between hubs  or between switches 
i) In the past, we have to use a cross over cable between two switches and that is not needed today. 
-> Straight through cables can be used between hubs and devices will workout which side is MDI and which side is MDIX 

CAVEAT
j) But this may not be true always: In onsite we may encounter an older cisco switch which does not support auto MDI/MDIX 
-> Hence we may need to use the correct cabling type between older devices 


CABLE CATEGORIES 
k) In general, higher the category - More twists and 
                                   - less susceptible the cable is to electromagnetic interference. 
								   - The more stringent the specifications are for cross talk and system noise 
								   - Higher cable categories typically support higher frequencies and higher speeds. 
								   
CAT1 - Previously used for telephones and modems 
     - Grade of unshielded twisted pair cabling designed for telephonic communications 
	 - Not suitable for data transmission . 
								   
								   
CAT2 - Previously used for telephones and data networks up to 4mbps   
CAT3 - Previously used for data networks up to 10mbps       
     - Now generally used for telephones   
CAT4 - defined upto 20MHZ with speed upto 16mbps 
CAT5 - defined upto 100MHZ with speed upto 10/100mbps when using 2 pairs and 1gbps when using 4 pairs 

CATEGORIES 1,2 4 ARE NO LONGER USED  AND CATEGORY 3 IS NO LONGER USED IN DATA NETWORKS  AND CATEGORY 5 IS ALSO NO LONGER USED. 

CAT5e - was an improvement of CAT5 
      - supports frequencies upto 100 MHZ and support 1gbps 
	  - Has maximum distance of 100 meters
	  - It is similar to cat5 but improved the CAT5 specification by reducing noise and signal interference. 
	  - Tightened crosstalk specifications and introduced new cross talk specifications
	  - Bandwidth of cat5 and cat53 are the same. 
	  - Physical cable construction is also same . 

CAT6 - supports frequencies upto 250MHZ and speed 10gbps but only upto 55 meters 
     - suitable for 10baseT, 100BaseTX for fast ethernet or 1000BaseT for gigabit Ethernet as well as 10Gigabit Ethernet 
     - increased number of pair twists per inch to reduce signal noise and interference 
	 - top specifications in cat6 guarantees 100 meter runs at 1 gbps 
	 - standardized cable for GigabitEthernet
	 - Backward compatible with CAT5, CAT5E or CAT3 
	 - Compared to cat5 or cat5e, cat6 has more stringent specifications for crosstalk and system noise 
	 
CAT6a - Augmented category6 defines frequencies upto 500 mhz and speed upto 10gbps  and 
      - Improvements in crosstalk with extended cable length of 100 meters 
	  
CAT7 - defined frequencies upto 600MHZ and supports 10gbps and cable length of 100 meters 
	 - Connectors can be TERA connectors rather than 8p,8c which we commonly refer to as RJ45 connector  
	 - Cables of CAT7 are protected by foil shield. 
	 - Twisting of pairs and no of turns per inch is also increased to protect from crosstalk  and in addition has 10 copper twinax 
	 - CAT7 is also known as ClassF 
	 
CAT7a - Frequencies upto 1000mhz and speed upto 40gbps for 100 meteres and 100gbps for 15 meters 
	  - Currently an ISO standard but not recognized by TIA/EIA 
	  
	  
RECOMMENDATIONS 
1) For brand new installations, it is recommended that CAT6a or CAT7 be used. 	  
2) if reusing existing CAT6 cabling, cable segments must be tested upto 350 megahertz and limited by TIA/EIA recommendations 

CAT8 - Next generation twisted pair cabling specification
	 - Can support upto 40gbps 
	 - technical recommendation for cat8 was released in march2018 and it has both class1 and class2 i.e CAT8.1 cables and CAT8.2 cables 

CAT8.1 - Fully backward compatible and interoperable with cat6a using RJ45 connectors 
CAT8.2 - Interoperable with cat7 cabling using RJ45 or TERA connectors 



62) Other Cables 
a) DIRECT ATTACHMENT CABLE(DAC) - Copper Twinax 
    - upto 15 meters 
	- Has small-form factor(SFPs) at both ends 
	- SFP is hot pluggable transceiver and may support various media types such as fiber or copper 
	-> This replaces GBICs or Gigabit interface converters 
	- DAC cable is inserted in SFP+ slot and supports 10gbps connection between two devices. 
	-> Other SFPs or SFP+ can support fiber which can go to greater lengths 
	- This cable allows 10gigabit copper connectivity between two devices over a short distance such as 7 meters 
	
b) ROLL OVER CABLE 
	- Special cable used in cisco environment 
	- Used to connect the consoles of networking devices 
	- helps to connect from the serial port of PC/Laptop to the console of a router or switch 
	- If we have serial port or COM port on the PC, you can connect directly to the console of a router or switch using roll over cable. 
	- However a lot of modern day PCs have serial ports, hence we need to get a USB to serial port converter which has a USB connection on one side and DB9 male connector on the other side, which allows to connect a DB9 female console cable to your pc with either RJ45 connector on other side or another db9 connector 
	- Most CISCO switches and router use an RJ45 connector. But we may come across devices from other vendors such as HP that use a DB9 connector for the console part. 
	- Thus a DB9 serial would connect to your pc and either an RJ45 or DB9 serial would be connected to the console of the networking device that you want to configure. 
	


HOW NETWORK DEVICES WORK 

63) Hub - 10baseT 
a) Hub is a layer 1 device in the OSI model and we will use a cat5 UTP cable with an RJ45 connector to connect your laptop or PC to a port on a hub 
b) Hubs are not very popular today and are superseded by switches 
c) Though hubs are not popular today, it is important to understand hub because wireless operates in the same way like a physical hub 
-> When you connect to a wiereless network, you will encounter the same issues that you would encounter when connecting to a physical hub. 
d) Hubs have multiple ports and thus multiple devices can be connected to a hub at the same time. 
e) Assume you are connecting your pc physically to a hub. Hubs have multiple ports and thus multiple devices can be connected to a hub at the same time. 
-> No of ports available depends on the hub model
-> Hub has various ports that you can connect devices to. 
-> Lets assume that our topology has 4 devices connected to a hub. and hub has 4 ports 
--> Important to realize that hub is a physical layer device and not inelligent. 
f) Hub is not intelligent and does not understand the frames going through it. 
-> Hub is basically a multiport repeater 
g) Hub will amplify or repeat the frames that it receives from one port out of all other ports. 
h) Physical topology of a hub is a star topology where you have a central device(hub) 
-> devices hanging off that central device acts as spokes 
i) All communication between devices happen through the central hub device 
j) If there are 4 devices A,B,C,D and one hub. if device A wants to communicate with device C - then it will not flow directly between two devices and traffic flows from A to Hub and then from Hub to C 
j) Advantages of using Hubs to UTP rather than 10Base2 or 10base5 which is Bus topology 
1 If a cable broke in topology, it would affect only the particular device and not affect the rest of the network . But in 10BaseT if a cable broke - it would affect all devices in the network 
2 Extend distances easily while a bus topology with 10baseT is limited in size
3 UTP cabling is cheaper 
4 easy to manage 


64) HOW DOES A HUB FORWARD TRAFFIC: 1
a) MAC addresses with 48 bits in length, but for simplicity lets represent mac addresses of devices by letters: A, B, C and D 
b) Lets assume A is sending traffic to C 

SA : Source address 
DA : Destination address 

SA:A 
DA:C 

c) If source mac address of frame is A and destination address of the frame is C. 

-> A sends frame to hub 

d) Then Hub which is a multiport repeater - has no understanding of the traffic it receives. 
-> Hub will simply amplify the signal and send the traffic/frames out of all ports 

e) If A is sending frame to C.  All devices except A will receive the  receive the fram except A will receive the frame. 
-> NICs of B, D will receive the frame , they will read that destination mac address is C and therefore frame is not destined to them and the Network interface cards of D and B will therefore drop the frame. 

-> Host C will accept the frame, because the frame is destined to it . NIC of PC C will read the destination MAC address, will see that the destination mac address of frame is at self , it will receive the frame - strip the layer2 headers and pass the packet to the higher layer protocols on the machine for further processing. 

f) Lets assume that A pings C, so it requires return traffic. 
-> Here C replies with frame with source MAC address being C  with SA: C and DA: A 
-> C sends that frame to the hub

g) What does HUB do with frame? 
-> Hub simply a multiport repeater, will just amplify the signal and sends it out of all ports  except the port on which it received. 
-> Frame is sent to D and B where it will be dropped since DA does not match themselves 
-> A accepts the frame as the DA:A is A and it then will strip layer2 headers , send the data to higher level protocols for further processing. 

h) Thus for a ping, A and C are communicating each other, but its important to realize that hub is a physical layer device which is a multiport repeater which amplifies frames out of all ports/interfaces 
-> Though PHYSICAL TOPOLOGY OF A HUB IS A STAR - logically it is a bus 


DIFFERENCE BETWEEN PHYSICAL AND LOGICAL TOPOLOGY IN NETWORKS 
-> Way the network is cabled physically is not necessarily the way the network is going to operate 
-> Important to remember that when a device sends traffic in a hub environment, all devices receive a frame . Thats exactly it works in 10base2 or 10base5 
-> hub operates in same way as 10base2 because when A sends a frame onto the network in hub, all devices receive the frame in the same way as 10 base2. 
->

i)  Just like in 10base2 environment where there is collision on network , it will affect all devices in network,it is a SINGLE COLLISION DOMAIN. A collision anywhere will cause devices to back off, sending a jamming signal and then attempt to transmit again

j) As the number of devices increases in hub environment, the number of collisions increases and network throughput goes down
k) In addition broadcasts are received by everyone as it is a SINGLE BROADCAST DOMAIN. 
-> It is single broadcast domain because all devices need to process broadcasts sent by every other device in the network.  
-> Broadcast traffic will flood through the entire network and interrupt the CPU of every host device  
-> A broadcast sent by B is received by everyone 
l) From BANDWIDTH point of view, this may be 10BaseT where 10 means 10mbps is shared between all devices 



############OSI model summary###############
LAYER1 = PHYSICAL 
  - RJ-45, HUB, Physical interface 
LAYER2 = Datalink 
  - MAC address 
LAYER3 - Network 
  - IP address 
LAYER4 - Transport 
  - TCP/UDP 


############################################
HUBS REPLACED BY BRIDGES
-> Hubs will amplify signals in all ports except the port in which they received. 
-> In recent days, HUBS ARE REPLACED BY SWITCHES 

-> WIRELESS networks acts like hubs. If you have a 54mbps wireless network. It is shared by all devices on wireless network.  

-> Overtime, hubs were replaced by bridges and bridges in turn have be replaced by switches 


66) WHAT IS A BRIDGE?
a) Bridge is a layer 2 device. It resides in data link layer of the OSI model.  
b) Bridges are more intelligent than hubs. 
c) Bridges use a MAC address Table to learn where devices are in the toplogy  
d) So rather than just repeating the signal and sending traffic out of all ports without understanding it, Bridges maintain a table with a list of MAC addresses learnt in the topology  
e) In our sample network, we have 4 devices A, B, C and D and the Hub is replaced by a bridge . So Bridge in connected to all devices A,B,C,D  and the topology is still star topology 
f) Bridges store MAC address in the MAC address table which is stored in the software 
g) Bridges are slow compared to modern day switches 
-> Bridges and switches operate in a similar way, but BRIDGES DO THE PROCESSING IN SOFTWARE WHEREAS SWITCHES DOES THE PROCESSING IN HARDWARE. 
h) Switches use ASIC or Application specific integrated circuit which allows high throughput, very quick table lookups and quick forwarding of traffic eften at line rate. 
-> In other words, switches dont slow the traffic down. 
i) Bridges were the predecessors to swithces and they do  things in software 
-> Bridges were lot slower, but from forwarding point of view, bridges and switches forward traffic in layer 2 segment in the same way Except the fact that bridges do it in software and switches do it in hardware 

67) What does Bridge do, when it receives a frame: 
-> In our sample network, we have 4 devices A, B, C and D . So Bridge in connected to all devices A,B,C,D  and the topology is still star topology 

a) Host A is sending traffic to HostC. The source mac address in the frame is A and destination mac address is C 

SA: A DA: C 

b) When the bridge boots up, its mac address table is empty 
-> In other words it does not contain dynamically learned MAC addresses. 
-> MAC addresses can be statically configured by an administrator. 
-> In this example, lets assume that mac addresses are going to be learnt dynamically. 


c) Initially MAC address table is empty. When a frame arrives on port 1 on the bridge, sent by hostA - bridge knows that host A is connected to port1 and can add MAC address A to its MAC address table. 
In mac address table, it creates a mapping saying that MAC address A can be found on Port1 



EG MAC TABLE 
A - Port1 


d) Thus bridge learnt where A is present in the topology , However it does not know where C is in the topology, because MAC address table does not have that information.  
-> Since bridge does not know where C is present, bridge will send the frame out of all ports except the port on which it was received to ensure that C receives the frame 
-> SInce the frame is sent out of all ports, both B and D receives a copy of the frame, but B and D will drop it since the frame is not destined to them . In other words NICs of B and D will read the destination MAC address and see if that is destined to C. 
-> The NIC of C will receive the frame, strip the layer2 headers and pass the information to higher level protocols because the destination mac address on the frame is C. 


68) How does a bridge forward traffic? 

In our sample network, we have 4 devices A, B, C and D . So Bridge in connected to all devices A,B,C,D  and the topology is still star topology 

a) In the similar way to our previous example: lets assume C replies to A. 
-> C sends a frame to the bridge. Bridge will read the source MAC address in the frame.  and then update the MAC address table with that information 

UPDATED MAC table:
A - Port1
C - Port3 


b) So bridge now knows that C is on port3 and A is on port1 

SA: C  DA: A 

c) Now unlike a hub, the bridge does not forward the frame out of all ports 
-> Destination is on portA. Bridge knows that mac address A is on port1, Hence it forwards frame outof port1 
-> The frame from C therefore goes only out of port1. 
-> It is not sent out of port2 or port4, because bridge knows that A is on port1. All subsequent frames from A and C will only use port1 and 3 
d) In other words, if A sends another frame to C it will go only out of port3.
final mac table 
A - port1 
B - port2 
C - Port3
D - port4 

d) advantages of bridges:
1 Each port is in a different collision domain 
SO a collision on port1 will not affect port3 
2 Each interface on a bridge is a separate collision domain 
-> in our example we have 4 collision domains .
-> If A and B were having a collision 
---> While hub is a single collision domain, bridge is a separate collision domain. 
-> The problem with collision is: if there is collision device needs to back off and try after some period of time 

-> The bandwidth and throughput of devices in single collision domain is lower than devices in separate collision domain 

3 BRIDGE IS STILL A SINGLE BROADCAST DOMAIN 
-> So if A sends A broadcast, it will be received by everyone in the topology 
-> Too many broadcast can slow down all devices on the network. 
4 Bridges process information in software rather than hardware -> Hence they will be slow compared to switches 


############OSI model summary udpated2 ###############
LAYER1 = PHYSICAL 
  - RJ-45, HUB, Physical interface 
LAYER2 = Datalink 
  - MAC address , BRIDGE 
LAYER3 - Network 
  - IP address 
LAYER4 - Transport 
  - TCP/UDP 


############################################


69) WHAT IS A SWITCH 
a) Switches are similar to bridges as they both reside at Layer 2 or the datalink layer of the OSI model 
b) big advantage of switching when compared to bridging is that processing can be done using Hardware which is called ASICs(Application specific integrated circuits) 
c) The number of ports supported by switches is also a lot higher 
-> Hundreds of ports are supported on certain switches where as in bridges you are limited to a few ports 
-> Switches are able to do this because processing is done in hardware and in actual fact these days processing is done at wire speed, which means that THERE IS NO DEGRADATION IN PERFORMANCE BETWEEN TWO DEVICES WHEN THEY ARE CONNECTED VIA A SWITCH. 

d) Switch Vs Bridge 
Switch: 
-> process in Hardware using ASICs  and faster 
-> Many ports 


Bridge: 
-> Process in software and slower 
-> Limited no of ports 

-> Bridges are replaced by switches in today's networks 


70) How do Switches forward traffic?
In this topology we have 4 host devices(A,B,C,D) connected to a Switch 

► Switches are layer2(Data link layer) devices  which has MAC address table similar to a bridge. 
► Network topology is also star topology where devices are cabled directly to ports on the switch. 

► Switch is similar to bridge, but much more powerful and quicker 

► If you have bridge environment and if you replaced bridge with a Switch - you will still have the same problems, but they would occur a lot quicker. 
► Thus bridge problems are not solved by switches. Switches simply increase the performance 

TRAFFIC FLOW IN SWITCH 
We will use easy to read mac addresses like A, B, C, D 

SA: A   DA: C
a) If A sends a frame to C and frame arrived at switch on port1 , what will switch do with the frame? 
-> Lets assume that the switch has just started up. So The mac address table is empty
-> MAC address table is empty means, it has not learnt where the devices are on the topology. 

MAC Address Table:
-----------------------------------------

-----------------------------------------

b) Now the switch, just like a bridge will flood the frame out of all ports except the source port
c) When the frame arrives at the switch to an unknown destination MAC address, the frame is flooded out of all ports except the port on which the frame arrived.  
d) However just like bridge, switch does not JUST flood the frame out of all ports , but it also learns where devices are in the topology 
-> Because the frames were received on port1  and the source MAC address in frame is A, that particular information is written to the mac address table of the switch  

MAC Address Table:
-----------------------------------------
A - port 0/1 
-----------------------------------------

e) The switch now knows that mac address A can be found on port1
f) When C replies to A, the frame would be received on port3 of the switch.  with SA:C and DA:A 
-> Then the switch will update its MAC address table with that information:

MAC Address Table:
-----------------------------------------
A - port 0/1 
C - port 0/3 
-----------------------------------------

-> Thus the switch knows that MAC address C can be found on port3 
-> In this case, since it knows that the destination MAC address is A, it will only send the traffic out of port1 and that's because A is found in mac address table as being available out of port1 

g) During the return journey, switch does not flood frame out of all ports 

h) Similar to bridge, all subsequent frames between A and C are forwarded only out of those 2 ports.
-> When A sends another frame to C  SA:A DA:C , the frame is sent only out of port3, because the switch knows that MAC address C can be found on port3 
-> When C replies sending traffic to a destination MAC address of A, switch forwards traffic only out of port1, because switch has already learnt that MAC address A can be found on port1  

i) Similar to bridge, each interface on the bridge is a SEPARATE COLLISION DOMAIN.   
-> so if a collision takes place in particular port/interface ,it would not affect other ports on the switch. 

j) Switch will FLOOD BROADCAST AND MULTICAST TRAFFIC BY DEFAULT, hence it is a SINGLE BROADCAST DOMAIN
-> If A sends a broadcast, that broadcast will be flooded out of all ports and will be received by all devices in the topology.

k) In Switch, We will have same issues as we would have in a bridge environment

k) Switches operate at much higher speeds and support a greater number of ports 

l) Broadcast will be flooded out of all ports except the ingress port because ingress port is not a broadcast address consisting of 8 hexadecimal Fs at layer2 

SA: A DA:FFFFFFFF

m) So when a switch receives the frame with a destination address of 8Fs, it will flood that frame out of all ports because this address of 8Fs at layer2 indicates everyone that it needs to be broadcasted, so switch will flood the frame out of all ports except the port on which it received. 

n) Broadcast addresses also indicate all devices rather than a single device, so the MAC address table is never populated with the broadcast address. 

o) ADVANTAGES OF USING SWITCHES OVER HUBS:
1) Switches support many ports and some can support 100s of ports 
2) Switches can operate at wire speed. 

The wire speed is the data transfer rate that a telecommunications standard provides at a reference point between the physical layer and the data link layer.

3) Each device is directly connected to a switch port 


71) What is half duplex and full duplex: 
a) If switch is running at 10mbps, it provides the full 10mbps to the pc connected to the port. 
-> Thus each device gets full bandwidth rather than sharing the bandwidth with other devices. 
-> Thus HUB SHARES THE BANDWIDTH while SWITCH DOES NOT SHARE THE BANDWIDTH
b)Even adding more devices to the switch does not degrade the throughput that each device gets.
c) In addition we can increase the speed by changing the duplex. 
d) By setting switch to dull duplex, the switch which has bandwidth of 20mbps can given you 20mbps
e) Hubs operated by CSMA/CD which is very similar to 10base2  provides shared bandwidth - has collisions whereas a switch with full duplex enabled , we can send and receive traffic at the same time. 

f) 

HALF DUPLEX - is like walky talky. where traffic can be sent at any one side at any given time. 
-> In half duplex only one party can transmit at any given time
-> If both parties try to transmit at the same time, there will be collision in half duplex. 

FULL DUPLEX - like landline telephone 
-> listen and speak at the same time. 
-> Send and receive traffic at the same time 

g) Hubs use Carrier Sense multiple accesses collision detection(CSMA/CD) or Half duplex where only one party can transmit at any given time

h) Individual ports on a switch can set those ports to use full duplex which means both pc and switch can transmit/receive at the same time. 

i) When we enable full duplex, collision detection is turned off because devices operate on that premise can send and receive at the same time. 
-> Hence there is no need to have collision detection as no collision detection will take place. 

j) However issues will be caused when one side is set to full duplex and other side is set to half duplex 
-> It is important to enable full duplex on both sides

k) Thus by replacing a hub with a switch and enabling full duplex, we can increase the throughput of the network   

l) Full Duplex is often negotiated automatically between devices 
-> Switch and PC will negotiate to use full duplex if they both support it 

m) In networks when one side chooses full duplex and the other side chooses half duplex , then it will cause many problems on that link . This happens because of incorrect negotiation between switch and pc. 
-> So if users complain slow throughput or bandwidth, check duplex on both sides and check if that has been negotiated correctly. 

n) Similarly speed can be negotiated between a switch and pc and that could also have incorrect negotiation. 
-> These days PCs have gig ports and thus the bandwidth can increase 

o) The throughput of switches is much much greater than hubs. Hence switches are preferred today over hubs and bridges. 

p) For awareness, in wireless networks access points tend to operate like hubs, which have a shared infrastructure which means shared bandwidth whereas with Switchs, devices have dedicated bandwidth 

############OSI model summary udpated3 ###############
LAYER1 = PHYSICAL 
  - RJ-45, HUB, Physical interface 
LAYER2 = Datalink 
  - MAC address , BRIDGE , SWITCH
LAYER3 - Network 
  - IP address 
LAYER4 - Transport 
  - TCP/UDP 


############################################

q) These days switches can also be operated at layer3, hence the term layer3 switches - but until now we saw only about pure layer2 switches 
r) Next we will look at routers and layer3 switches 

72) What is a ROUTER? 
a) Routers are layer3 devices which operate at the network layer of the OSI model. 
b) Routers dont make routing decisions based on MAC addresses. 
c) But rather Router uses IP addresses when determining out of which interface, traffic should be sent. 
d) Routers still use MAC addresses on Ethernet interfaces.  But the decision making process of which interface traffic should be transmitted out, is made based on IP addresses rather than MAC addresses. 
e) Router may have serial interfaces as well as Ethernet interfaces. 
f) An Ethernet interface uses a MAC address for forwarding of traffic at layer2
g) But a serial interface using ppp(point to point protocol) does not use MAC addresses. 
h) So when traffic arrives on one interface and routers need to determine out of which interface to foward the traffic  - that decision is made based on IP addresses rather than mac addresses. 

i) Network Topology:


PC_A--------                                          ----PC_B
10.1.1.1   |  F0/0                   F0/1            | 10.1.2.1
		   | 10.1.1.100            10.1.2.100        |
		   ---[-->]------►-Router----[-->]-----------
           |       G                   H             |
           |                                         |
PC_C--------                                         ----PC_D
 10.1.1.2                                          10.1.2.2
 
 Here [-->] indicates hub device 
 
-> In this Topology, rather than using full 48 bits MAC addresses, we will represent MAC address as single character for readability. 

j) DEVICES IN TOPOLOGY: 
-> First PC_A has MAC address A and IP address 10.1.1.1
-> Second PC_B has MAC address B and IP address 10.1.1.2
-> First PC_C has MAC address C and IP address 10.1.2.100
-> First PC_D has MAC address D and IP address 10.1.2.1 
-> We have router with 2 interfaces, Ist interface: F0/0 has IP address: 10.1.1.100 and MAC address: G 
IInd Interface F0/1 has IP address: 10.1.2.100 and MAC address of H. 

k) In this topology we use a subnet mask of /24 i.e. 255.255.255.0
l) For Simplicity PC_A,PC_C are connected to hub which in turn in connected to a router on F0/0
PC_B and PC_D are also connected to a hub which in turn is connected to a router on F0/1 
-> Router is therefore been configured with an IP address in the same subnet as hostA and hostC 

m) If FastEthernet in F0/1 interface is configured in same subnet as B and D 
-> When you configure an IP address on a router or layer3 switch, you configure IP address with the mask /24 

n) Once Ip address is configured, router will update its routing table to indicate that network 10.1.1.0/24 is directly connected to FastEthenet F0/0 
and network 10.1.2.0/24 ia directly connected to F0/1 

----------ROUTING TABLE---------------------
C           10.1.1.0/24 F0/0 
D           10.1.2.0/24 F0/1 

-------------------------------------------- 

0) Routers dont populate ROUTING TABLE USING IP ADDRESSES, but rather populate routing tables with network addresses 
-> Routers make routing decisions based on the network address rather than individual IP address.  

p) Thus routers in our sample topology are configured with IP addresses and /24 mask 
-> Based on below routing table, router knows that to get to network 10.1.1.0 , traffic should be sent out of interface fast ethernet  F0/0
-> And to get to network: 10.1.2.0 , traffic should be sent out of interface f0/1 

----------ROUTING TABLE---------------------
C           10.1.1.0/24 F0/0 
D           10.1.2.0/24 F0/1 

-------------------------------------------- 


73) How does Router forward traffic: 
a) For the same topology discussed in above lesson, how would traffic flow if device A sends traffic to device C? 
-> Lets assume that device A pings device C 

A's IP: 10.1.1.1 
B's IP: 10.1.1.2 

SA:A        DA:FFFFFFFF
SA:10.1.1.1 DA:10.1.1.2 


b) With regards to traffic flow from A to C, it is important to remember that IP is a layer3 technology and MAC addresses are used at Layer2 
c) PC_A needs to have a mapping between layer3 IP address and layer2 mac address 
-> It is because Ethernet is used in this environment and packet needs to be encapsulated at layer2 and sent to the wire.  
-> Thus in Ethernet a MAC address needs to be added at layer2 
-> As of now, PC_A does not know MAC address associated with IP address 10.1.1.2 which is device C 

-> TO remember: Ethernet is  layer2 technology and requires use of MAC addresses when traffic is sent into Ethernet segment. 


d) So before PC_A can send the traffic to network segment, it needs to know the MAC address associated with IP address 10.1.1.2 of PC_C
-> PC_A gets to know mac address of PC_C by using ARP protocol.
1) PC_A first checks its local ARP cache, to see if there is an existing entry mapping IP address 10.1.1.2 to a MAC address 
2) If there is not an existing entry on local machines arp cache, PC_A will send out a broadcast  to try and find out who has IP address 10.1.1.2 and that message is called an ARP request message. 
3) In this example, PC_A and PC_C are in same subnet.
So PC_A will send a broadcast to the local subnet asking for mac address of PC_C using an ARP request. 

e) ARP request from A to C:
-> Here Source Address is A and Destination Address is Broadcast. This is because A does not know who has IP address 10.1.1.2 
-> As we know, ARP is a message asking "who has this IP address" 
-> In our case IP address that is being referenced in packet is 10.1.1.2 where Source IP address is 10.1.1.1, source MAC address is A , destination mac address is a broadcast at layer 2

LAYER2 PORTION  of message | LAYER3 PORTION of message
SA: A DA: FFFFFFFF         | SA:10.1.1.1 DA: 10.1.1.2


-> before continuing with our example, lets look at real world example of ARP protocol.


####REAL world example of ARP############
a) In our pc, we can type arp -a and see the local arp cache 

---
C:\Users\gs1-maheswarane>arp -a

Interface: 192.168.29.232 --- 0x5
  Internet Address      Physical Address      Type
  192.168.29.1          00-67-62-a4-f8-55     dynamic
  192.168.29.116        7c-66-ef-ce-a6-43     dynamic
  192.168.29.255        ff-ff-ff-ff-ff-ff     static
  224.0.0.22            01-00-5e-00-00-16     static
  224.0.0.251           01-00-5e-00-00-fb     static
  239.255.255.250       01-00-5e-7f-ff-fa     static
  255.255.255.255       ff-ff-ff-ff-ff-ff     static
-----

b) In the above output, my pc ip is 192.168.29.232 
c) In our example, we have two dynamic mac addreses in our local arp cache. 

  192.168.29.1          00-67-62-a4-f8-55     dynamic
  192.168.29.116        7c-66-ef-ce-a6-43     dynamic

d) Our ip config output 

------------
Wireless LAN adapter Wi-Fi:

   Connection-specific DNS Suffix  . :
   IPv6 Address. . . . . . . . . . . : 2405:201:e031:70a3:9d2f:9bac:64c0:720f
   Temporary IPv6 Address. . . . . . : 2405:201:e031:70a3:110e:dbc4:520d:aa5d
   Link-local IPv6 Address . . . . . : fe80::dace:1126:a2f6:fd96%5
   IPv4 Address. . . . . . . . . . . : 192.168.29.232
   Subnet Mask . . . . . . . . . . . : 255.255.255.0
   Default Gateway . . . . . . . . . : fe80::267:62ff:fea4:f855%5
                                       192.168.29.1
-------------
e) In our arp -a output we can see mapping for Default gateway's IP address to relevant mac address:
 192.168.29.1          00-67-62-a4-f8-55     dynamic

f) command arp -d will allow me to delete arp entries in my local arp cache 
---
C:\Users\gs1-maheswarane>arp -d
---

g) if we do arp -a again, we can see No ARP entries found 

---
C:\Users\gs1-maheswarane>arp -a
No ARP Entries Found 
---

h) If i do arp -a again, we wil notice that entry has happened once again 
C:\Users\gs1-maheswarane>arp -a
192.168.29.1          00-67-62-a4-f8-55     dynamic

-> etnry has appeared again because we are sending traffic from our pc to default gateway 

i) If we do arp -a again, it shows the directed broadcast address for the subnet  

C:\Users\gs1-maheswarane>arp -a
192.168.29.1          00-67-62-a4-f8-55     dynamic
255.255.255.255       ff-ff-ff-ff-ff-ff     static

j) Now if i ping another IP address of 192.168.29.41   , initially there is no arp entry for this IP address, but when we pinged the ping succeeded  

Now we can notice that the arp entry has been added for ip address 
192.168.29.41
########################################### 

C:\Users\gs1-maheswarane>arp -a

Interface: 192.168.29.232 --- 0x5
  Internet Address      Physical Address      Type
  192.168.29.1          00-67-62-a4-f8-55     dynamic
  192.168.29.41         5c-3a-45-1c-93-73     dynamic
  192.168.29.116        7c-66-ef-ce-a6-43     dynamic
  192.168.29.255        ff-ff-ff-ff-ff-ff     static
  224.0.0.22            01-00-5e-00-00-16     static
  224.0.0.251           01-00-5e-00-00-fb     static
  239.255.255.250       01-00-5e-7f-ff-fa     static
  255.255.255.255       ff-ff-ff-ff-ff-ff     static
  
k) Moral of the story: Before traffic can be sent to an IP address on the local segment, ARP is required to create a mapping between layer3 IP address  and layer2 mac address 
###############


f)  MORAL OF THE STORY: Before traffic can be sent to an IP address on the local segment, ARP is required to create a mapping between layer3 IP address  and layer2 mac address 

g) Wireshark is a sniffing tool that helps us capture traffic of the local wire to see whats going on  
-> It is an invaluable tool for network engineer 

74) How is traffic routed within subnet 
1)  When a device wants to communicate with another device in same subnet, it will send a broadcast onto the local segment, to find the mac address of the device using the target IP adddress . 


ARP TRAFFIC START


ARP request: 
LAYER2 PORTION  of message | LAYER3 PORTION of message
SA: A DA: FFFFFFFF         | SA:10.1.1.1 DA: 10.1.1.2

2) In our scenario, A sends frame to the Hub which is a multiport repeater  . The hub will send the frame out of all ports, except the port on which it arrived 
-> So both the router and host C will receive the frame. 
--> NICs will only accept unicast traffic destined to their MAC address or they will accept broadcast traffic or multicast traffic. 

3) In our scenario, router has MAC address of G on interface FastEthernet 0/0. SO the router will receive the broadcast and forward the arp request to higher layer protocols 

4) Router with MAC address G will be able to see at layer3, that this is an ARP request for ip address 10.1.1.2  
-> But the router in this example is configured with IP addresses : 10.1.1.100 a  10.1.2.100 
-> So router will drop the frame, as the arp request is not for one of its ip addresses.

5) ROuters dont forward broadcasts , hence this broadcast is not forwarded out of Interface FastEthernet0/1  
-> Hence the broadcast recevied by router is dropped. 

6) The NIC of PC_C will receive the broadcast and see that this is an arp request for its ip address, so it then replies with an arp reply. 
-> PC_C will update its arp cache to show  that IP address 10.1.1.1 is associated with MAC address A and then it will send the frame to the hub. 

ARP response: 
LAYER2 PORTION  of message | LAYER3 PORTION of message
SA: C DA: A                | SA:10.1.1.2 DA: 10.1.1.1


7) The hub will forward out of all ports, because it is a multiport repeater 

8) Again router will receive a frame from the hub, but because the destination MAC address is A, and not MAC address of router which is G, the router will drop the frame. 

9) A also will receive a copy of the frame. 
-> When A receives a frame, it will accept it as the destination mac address is A. 
-> Then PC_A will update its arp cache  with an arp entry stating that IP address 10.1.1.2 has mac address C. 

10) Until this point, no user traffic has been transmitted. 
So far: Devices have simply worked out which MAC addresses are associated with the IP addresses. 

ARP TRAFFIC END 

PING TRAFFIC PART START

11) ping traffic can now be transmitted with a source mac address of A of PC_A and destination MAC address C of PC_C 
-> The destination mac address is already learnt through ARP. 

PING TRAFFIC from A to C flow : 

LAYER2 PORTION  of message | LAYER3 PORTION of message
SA: A DA: C                | SA:10.1.1.1 DA: 10.1.1.2 


12) When HuB receives  frame from PC_A, it will repeat it out of all interfaces except the interface it arrived on 
-> So router once again receives the frame, but it will drop it as its mac address is G, but the destination mac address for this frame is C  

13) PC_C will also receive the traffic and will accept it because the destination mac addresss is C. 

14) Then layer2 headers will be stripped and IP address information will be read by higher level protocols 

15) This is an ICMP echo packet , so the PC_C will reply with an echo reply message. 


PING RETURN TRAFFIC FROM C TO A:

LAYER2 PORTION  of message | LAYER3 PORTION of message
SA: C DA: A                | SA:10.1.1.2 DA: 10.1.1.1  

-> C will send the frame to hub with a source mac address of C, destination mac address of A  which detects MAC addresses based on arp cache entry 

16) When the frame is received by the hub, the hub will repeat it out of all ports,except the receiving port 
17) Router G receives the frame, but will drop it as the destination mac address is not matched 

18) When A receives the frame from Hub, it will accept it as the destination mac address A is matched. 
19) Now layer2 headers will be stripped and forwards the infromation to higher layer protocols 
20) In this case, it is an echo reply , hence the ping will show a success message. 


75) WHAT HAPPENS WHEN PC_A WANTS TO PING A REMOTE DEVICE IN A SEPARATE SUBNET: 


a) If PC_A with IP address: 10.1.1.1 wants to ping PC_B with IP address:10.1.2.1 in a DIFFERENT subnet , it would do the following 

b) First thing, PC will do is to check whether the IP address its trying to communicate is in a DIFFERENT SUBNET OR IN THE SAME SUBNET
-> PC will do this check by DOING A LOGICAL AND using the NETWORK MASK 
-> In our example the network/subnet mask is /24 and IP address of PC A is 10.1.1.1 and its trying to ping an ip address of 10.1.2.1/24 

-> Local pc checks if the localIP's network portion(10.1.1.0) and remote IP's network portion(10.1.2.0) are same. If it is same - then they are in same subnet, else they belong to different subnet. 
-> In our case , network portion of both addresses are different and thus local pc knows that the remote device is in a different subnet 

c) If the remote address belong to different subnet, PC will send the traffic to its default gateway in order to reach the remote subnet on which the device resides. 


d) In this example we assume that the remote device PC_A has default gateway configured. 
-> device A is configured with default gateway of the router: 10.1.1.100 

e) PC will first check if it has the router's MAC address in its local arp cache 
-> It does this because it needs to send the traffic to the router inorder to reach the remote device. 
-> Because this is an ethernet segment layer2, Layer2 MAC address is required for communication 
-> Ethernet requires that MAC address should be used at layer2 for transmission across an Ethernet network. 
-> Hence at layer2 mac address is required by the PC 
-> PC would have been configured with a default gateway of 10.1.1.100 which is an ip address at layer3 

f) Thus to get mac address, PC will send out a broadcast onto the segment asking "who has ip address" 10.1.1.100 
i.e it sends an arp request associated with ip address of default gateway 


PC'S ARP REQUEST: 
LAYER2 PORTION  of message | LAYER3 PORTION of message
SA: A DA: FFFFFFFF         | SA:10.1.1.1 DA: 10.1.1.100  

g) When the broadcast is received by the hub, it will flood it out of all ports , except the port on which they arrived. 

-> PC_C will receive broadcast at layer2, but when it reads layer3 information it will see that this is an arp rquest for 10.1.1.100 which is not its IP address . Hence PC_C wil drop the ARP request. 

h) When Router receives the broadcast, it will process the ARP request
-> Firstly it will receive the traffic at layer2 as it is a broadcast 
-> WHen it reads the layer3 information, it will see that this is an ARP request for its IP address. 
-> So the router will reply with its MAC address as arp reply for the arp request. 

ROUTER'S ARP REPLY 
LAYER2 PORTION  of message | LAYER3 PORTION of message
SA: A DA: a                | SA:10.1.1.100 DA: 10.1.1.1

-> The ARP reply is an unicast message so source mac address s G and Destination mac address is A

i) When ARP reply reaches hub from the router, HUB will once again flood the traffic out of all ports except the port on which it arrived. 
-> PC_C's NIC will drop the frame since it is not destined to it 
-> PC_A will receive the frame and upton receiving it will process the frame , because the destination mac address is itself. 
-> Thus at layer2 frame is accepted by NIC , layer2 infromation is stripped and forwarded to higher layer protocols 

j) Because this is an arp reply , its processed by higher level protocols and arp cache is updated with MAC address of the router 
k) So PC_A has mapping saying that its IP address 10.1.1.100 uses MAC address G 

PING TRAFFIC FROM A TO B 
LAYER2 PORTION  of message | LAYER3 PORTION of message
SA: A DA: G                | SA:10.1.1.1 DA: 10.1.2.1


K) PC_A knows that IP address of 10.1.1.100 is associated with MAC address of G
-> So pc can send traffic to the network destined for the remote PC 10.1.2.1 with source IP set to PC_A:10.1.1.1
-> Here we can notice that source addresss is A and destination address is G.  

l) The layer2 frame goes to the router and hence layer2 segment contains local segment MAC addresses 
-> Layer3 information contains the destination IP address or remote host  and the local PC_A 's IP address 

m) When frame reaches hub, hub will flood it to both G and C. C will drop the frame while the router will receive the frame at layer2 because it is destined to mac address of G 
-> Router will strip the layer2 information and reads layer3 information in the packet. 

n) If we are pinging google .com
LAYER2 PORTION  of message | LAYER3 PORTION of message
SA: A DA: G                | SA:10.1.1.1 DA: 74.125.233.54

where 74.125.233.54 is google's ip address

-> So we have destination mac address as router at layer 2, but destination IP will be pointing to google's IP 


76) SUMMARY: SENDING TRAFFIC FROM ONE SUBNET TO ANOTHER SUBNET 


LAYER2 PORTION  of message | LAYER3 PORTION of message
SA: A DA: G                | SA:10.1.1.1 DA: 10.1.2.1 


a) When sending traffic from one subnet to another subnet, layer3 headers contain source host IP address  and destination host IP address 
b) But at layer2, the source mac address is the local host  and the destination mac address is the local router on the local segment 
c) When the  frame gets to the router, router will strip layer2 headers and then read layer3 headers to determine what to do with the traffic 
d)  So the destination Ip address is 10.1.2.1, the router will firstly check if that is a local ip on router 
-> Since it is not local ip, it checks the routing table to determine if it knows where the destination IP address is present. 
-> From routing table, it determines that this IP address 10.1.2.1 is on subnet 10.1.2.0 which is out of F0/1 

---Routing table----
C 10.1.1.0/24 F0/0 
C 10.1.2.0/24 F0/1 

-------------------

e) The router therefore knows it needs to send the traffic to host 10.1.2.1 out of port/interface F0/1, 
-> Then it checks the ARP cache to see if it has entry for 10.1.2.1  

f) In this case, lets assume that router does not have an ARP entry mapping IP address 10.1.2.1 to MAC address B 
-> To find that it sends a broadcst on to the local segment requesting the MAC address of IP address: 10.1.2.1
-> It will send out an ARP request messsage, the hub will be flooded  out of its ports and both B and D will receive the frame. 



BROADCAST FOR ARP REQUEST: 
LAYER2 PORTION  of message | LAYER3 PORTION of message
SA: H DA: FFFFFFFF         | SA:10.1.2.100 DA: 10.1.2.1

-> Here 10.1.2.100 is the gateway or router's IP 

g) PC_D with IP address 10.1.2.2 will receive thrame at layer2, because it is a broadcast message, but at higher layers PC_D will drop the traffic because it is an ARP request of another device's IP address 

h) THus PC_D drops the frame while PC_B receives it at layer2, send it to higher protocol layers . Higher layer protocols will see that this is an arp request for local IP address of this host. 
-> So PC_B will process ARP request and send back an ARP reply 

ARP REPLY FROM PC_B to ROUTER 
LAYER2 PORTION  of message | LAYER3 PORTION of message
SA: B DA: H                | SA:10.1.2.1 DA: 10.1.2.100
 
i) The ARP reply will be sent to the HUB with source mac address B and destination MAC address of router: H 
-> Router is the device that requested mac address of PC. 
j) The MAC address of each interface of a router are different. In our scenario, MAC address used was H  
-> Hence PC will reply back to that MAC address

j) The IP address and MAC address of the routers F0/1 is used in reply from PC_B. 
-> When hub receives traffic, it floods it out of all of its ports. D will drop the frame , but the router will process the traffic because the MAC address is its local MAC address 
k) Thus the router's NIC will receive traffic at layer2, it will then process traffic at layer3 and  then it will update its local ARP cache, stating that IP address 10.1.2.1 as MAC address B. 
-> Thus the arp cache is updated in the router and the router can send original ping traffic to Host B  from Router H

PING TRAFFIC FROM H TO B 

LAYER2 PORTION  of message | LAYER3 PORTION of message
SA: H DA: B                | SA:10.1.1.1 DA: 10.1.2.1


K) AS A WHOLE:

1) From the beginning : for ping from A to B, when frame arrived at the router from Host A, it had source  address of A and destination mac address of G , Source IP address of 10.1.1.1 and destination ip address of 10.1.2.1 

Ist step 
LAYER2 PORTION  of message | LAYER3 PORTION of message
SA: A DA: G                | SA:10.1.1.1 DA: 10.1.2.1


2) When it now sends traffic out of F0/1, it rewrites the MAC address entries 
-> So the source mac address is H, the local router's interface is H which is local router's interface. 
Source IP Address is still PC_A: 10.1.1.1 and Destination IP address is still PC_B: 10.1.2.1 
-> THus it is important to remember that: 
WHEN TRAVERSING A ROUTER OR A LAYER3 SWITCH (MOVING FROM ONE VLAN TO ANOTHER) - THE LAYER 2 INFORMATION IS REWRITTEN WHILE THE LAYER3 INFORMATION IS LEFT THE SAME 
-> But everythime, traffic hops across a router or traffic is sent from one VLAN to another VLAN - layer2 information is rewritten in the frame 


Current step 
LAYER2 PORTION  of message | LAYER3 PORTION of message
SA: H DA: B                | SA:10.1.1.1 DA: 10.1.2.1


3) Next -> WHen traffic is received by the hub, it will flood it out of all ports , D will drop the frame because destination mac address wont be matched and B will receive the frame at layer2 because it is destined to itself and then it will process the layer3 and layer4 information 

-> Thus echo message will reach Backward

4) Now B is going to reply with an echo reply message 

l) B's ECHO REPLY MESSAGE:

LAYER2 PORTION  of message | LAYER3 PORTION of message
SA: B DA: H                | SA:10.1.2.1 DA: 10.1.1.1

-> B will reply with a echo reply, we can notice that echo reply is going to destination IP address of 10.1.1.1 which is host PC_A , source mac address is B and but the destination mac address is the router. 
-> device B is sending the traffic to its default gateway, because it would have also done it would have found that device is on different subnet and hence forwarding to default gateway 
-> In this case, we have configured the pc with default gateway of 10.1.2.100 


m) Hub will flood the traffic out of all ports, D drops the frame and router processes frame at layer2  because destination mac address is its local mac address. 

-> Then router strips layer2 information and reads layer3 information to determine if it knows where the destination address is. 

o) Seeing the routing table, router finds that the ip: 10.1.1.1 is in subnet 10.1.1.0/24 and that subnet is directly connected to F0/0 on the router  
p) So the destination ip address is in a subnet that is known by the router and it now knows out of which interface to send the traffic 
-> So router forwards the packet out of interface F0/0 

-> The router will rewrite the layer2 headers with source Mac address as G and destination mAC address as A
-> Thus layer3 information is same and layer2 information is rewritten. 
-> Router then forwards the frame to the hub 

Traffic after router: from HUB to HOST PC_A  
LAYER2 PORTION  of message | LAYER3 PORTION of message
SA: G DA: A                | SA:10.1.2.1 DA: 10.1.1.1

q) When a hub receives traffic, it will flood out of all ports , C drops the frame and A will receive the frame since the destination mac addresses match , it then processes the layer2 information, strip the layer2 information and forward it to higher layer protocols 
r) Higher layer protocols process the layer3 /layer4 and then ping will succeed 

s) in some cases, we can notice that the first ping fails. It is because of the arp request and replies that need to take place to populate the arp caches of devices between source and destination device.   

T) IMPORTANT TAKEAWAY:
-> When you ping across a router or a layer3 switch, layer2 information is updated/rewritten at each hop, but the layer 3 information remains the same unless NAT is used 

-> When you move from one vLAN to another VLAN on a layer3 switch or move from one interface to another on a router - layer3 information is not changed, but layer2 headers are rewritten 

L) Thus Router  - A LAYER 3 DEVICE MAKES ROUTING DECISIONS 
BASED ON IP ADDRESS AND REWRITES MAC ADDRESSES 
-> LAYER 3 SWITCH ALSO OPERATES AT THIS LAYER . Layer3 switch has layer2 capability as well as Layer3 capability 

############OSI model summary udpated4 ROUTER ###############
LAYER1 = PHYSICAL 
  - RJ-45, HUB, Physical interface 
LAYER2 = Datalink 
  - MAC address , BRIDGE , SWITCH
LAYER3 - Network 
  - IP address ,ROUTER , LAYER 3 SWITCH
LAYER4 - Transport 
  - TCP/UDP 


############################################


77) Duplex and Speed mismatch
a) Duplex and speed mismatch occurs when speed mismatch occur when auto-negotation fails or when manual configurations are mismatched. 
b) For eg: if one side is configured to use full duplex and other side is configured to use half-duplex, auto-negotation may fail becaue of physical problms in network such as cabling problems 
or Hub somewhere in network duplex mismatches do cause performance problemms  

c) Duplex Mismatch: 
	- Cause performance problems 
	
	-> Your pings may succeed, but movement of large files may be negatively affected and UDP may especially have problems with recovering from duplex mismatch
	
History	
d) Originally Ethernet was half duplex because devices were connected to hubs 


e) When there is duplex mismatch, the side that has half duplex will have late collisions on the connection 



78) Loopback interface:
a) In PCs loopback interface is used for testing your TCP/IP stack 
-> Looback address helps to test connectivity to the 127.0.0.1 ip address  

b) On a CISCO device loopback interface has an entirely different meaning 

c) We have a topology which has 3 routers: Router1, Router2 and Router3 configured with IP Addresses. 

d) In physical routers if cable got disconnected means, the interface will go down.

e) The difference between physical interface and loopbac interface is , loopback interface is a logical interface on router 

f) We can create loopback interface in router 
-> As soon as we can create loopback interface, the interface comes up. 

############
Router(config)#interface loopback 0

Router(config-if)#
%LINK-5-CHANGED: Interface Loopback0, changed state to up

%LINEPROTO-5-UPDOWN: Line protocol on Interface Loopback0, changed state to up
#########


g) I can give an IP address for the interface 
-> We are creating a /32 ip address 
-> In other words, this is the only IP address of that interface 
###
Router(config-if)#ip address 2.2.2.2 255.255.255.255
###

h) WHAT IS LOOPBACK INTERFACE ON ROUTER
a) Loopback interface is a logical interface on a router that wont go down unless you manually shutdown the interface 
b) Loopback interface has only one IP address but you could configure multiple IP addresses on that interface 

i) ADVANTAGES OF LOOPBACK INTERFACE 
1) Interface does not go down unless you explicitly shut it down 

WHY IS IT IMPORTANT:
-> When you telnet to a router, from another router. Eg if we telnet from Router R1 to Router R2, i could telnet to one of the gigabit interfaces on the router 

eg: telnet 10.1.1.2 

-> But FIRSTLY we need to remember which IP address is configured on which Router  
-> SECONDLY if for some reason, an interface went down by cable disconnectivity or some reason , we will have problem in telnetting back to the ip address , as the interface is down 

2) However if you have loopback IP address configured on the router and you advertise that loopback through a routing protocol such as ospf, you can telnet to that loopback using this network using the available network. 
3) Thus if one of the interface goes down, it is not a problem because you can still reach the loopback interface. 

c) Loopback interface can be pinged from other router  only if it is advertised via a routing protocol 
d) So we will enable eigrp in router R1

router eigrp 100
network 0.0.0.0

and similarly in other device R2

router eigrp 100 
network 0.0.0.0 

d) So once we establish neighbor relationship between eigrp neighbours, router1 can ping loopback of router 2

e) Then i can telnet to the loopback address of rotuer2 even though the wan interface is down 


a) We use loopback interface in routers, because Routing protocols such as Ospf use the loopback to determine router ids of the routers in the ospf network. 


79) Another reason to use loopback interface - OSPF 


TCP/UDP
80) TCP/IP Transport Layer 
-> TCP/IP transport layer is the layer4 of OSI model 
-> We will concentrate specifically on TCP and UDP protocol that reside in this layer. 

-> Comparison of UDP Vs TCP 
-> Port Numbers 
-> Details of UDP 
-> Details of TCP 
-> TCP 3 way handshake 
-> Windowing 
-> Sequence numbers 

a) IP - Internet protocol is connectionless 
-> IP Layer means layer3 or Network layer 
1) i.e Every packet is treated individually and separately by routers in the network 

PC1<-------INTERNET--------------->SERVER 

2) Individual packets from PC could take the upper path or they could traverse the lower link 
-> Traffic from one host(PC1) to another host(server) could take different paths , even though that traffic is part of the same conversation. 
-> The packets take different paths, depending on how the traffic is routed to the internet. 

3) This could mean that packets could go out of order 
-> Packet2 could arrive before packet1 

[P3][P2][P1]====>[P3][P1][P2] 

4) So the server needs a mechanism to re-order the packets into their origina sequence. 


b) IP also does not guarantee the delivery of packets 
-> Hence higher level protocols need to ensure re-ordering of packets and checking if the packets arrived successfully. 


81) UDP vs TCP 


UDP (User Datagram Protocol) 
a) UDP is connectionless like IP 
b) does not guarantee delivery of packets 
c) Requires higher layer protocols like application layer to ensure successful delivery of packets 
d) As an analogy UDP services are similar to using a regular mail offered by the post office. 
-> We will write letter, enclose it in envelope . In the same manner we will take our data, encapsulate it in UDP 
-> We will then post our letter, and hopefully the postal service would deliver the letter to the recipient. There is no guarantee that the letter will be collected/transported/delivered and opened by the recipient. Also sender of the mail does not get any acknowledgement or proof of delivery. Thus UNRELIABLE. 
----> Similarly in UDP environment , UDP at layer4 does not guarantee delivery. Higher level protocols like application layer need to ensure reliability and delivery acknowledgement

TCP(Transmission Control Protocol) 
a) TCP provides delivery acknowledgement and reliability 
b) But this reliability comes with the disadvantage of additional overhead 
c) As an analogy, TCP session can be seen as a telephone call. 
-> TCP is connection oriented.
1) Telephone1 makes call to Telephone2 and RINGS 
2) Telephone2 answers call, acknowledges by saying:HELLO ITS DAVID SPEAKING 
3) Telephone1 then notifies Telephone2 by saying: HELLO DAVID PETER HERE 

[telephone1]						[telephone2]
              initiate call 
             ---------------------->  Ring
			 acknowledges call 
            <---------------------- Hello Its David Speaking 
			indicate speaking 
Hello David ------------------------>
Peter here 

         <====COMMUNICATION===========>

d) Hence there is a 3 way handshake 
e) In TCP environment, information is not echoed. But it uses sequence number to ensure successful delivery. 

f) Lets see what a SOCKET is 
1) This term is often used in networking 
2) Socket is a combination of IP address of a host, port number used to identify application and the transport protocol used 
-> IP Address +portnumber + protocol => These three combine into one single entity called socket. 
3) Thus SOCKET is a combination of all these three things, used to identify connection between hosts 

g) TCP/UDP allow SESSION MULTIPLEXING 
-> i.e A Single computer(host) with single IP address is able to communicate with multiple servers or multiple devices and have multiple sessions simultaneously. 

h) A SESSION is created when SOURCE host needs to send data to a DESTINATION host
-> Replies are ofthen received but not mandatory 
-> session is created and controlled within the network application which contains the functionality of OSI layers 5 to 7 

i) When using reliable service like TCP, connection must first be established between sender and receiver 
-> TCP opens a connection and negotiate between various connection parameters before actually transmitting data. 
-> During data flow, TCP maintains reliable delivery of data and will close the connection once completed. 

j) SEGMENTATION: Information or Data may be SEGMENTED or broken up into smaller chunks for transmission across a physical medium 
-> MAXIMUM TRANSMISSION UNIT OR MTU of an outgoing interface depends on the physical medium 
  eg: MTU of Fast Ethernet is 1500 bytes 
  -> However TCP can theoretically support 65,495 bytes in a single packet. 
-> When that is sent to the lower layers of the OSI model , that will need to be broken up into fragments for transmission across the physical medium as it supports only 1500 bytes 

k) MAXIMUM SEGMENT SIZE OR MSS is the largest amount of data in bytes , that tcp is willing to send in a single segment. 
-> For best performance mss should be set small enough to avoid IP fragmentation which can lead to excessive retransmissions during packet loss 

m) TCP supports MSS and Path MTU discovery 
-> Sender and receiver can automatically determine what the  maximum transmission unit is on a path between them.
-> TCP will only put enough data into a single packet, that fits the MTU thus avoiding fragmentation of packets and also avoid overheads related to fragmentation 
-> Path MTU discovery is optional in IPv4, but become mandatory in IPv6 because of the efficiency it brings to the TCP transmission.  Also IPv6 does not support fragmentation on routers along the path between two hosts.  

-> UDP does not support this and require higher level protocols , to sort out the fragments . 


n) FLOW CONTROL:
-> TCP uses end-to-end flow control to avoid sender sending data too quickly , so that receiver can receive it and process it reliably. 
-> If sender sends data faster than what receiver can handle, receiver drops data and requires retransmission 
-> Retransmissions waste time and network resources due to which most flow control mechanisms try to maximize the transfer rate 

eg: You have a powerful and faster pc sending data to PDA which can only process data at a much lower rate. 

-> PDA should regulate the data flow.

o) In TCP, basic flow control is implemented by acknowledgements from the receiver, in receipt of the data transmitted. 
-> TCP uses SLIDING WINDOW to control flow of data  
-> Windowing will allow a receiving computer to advertise how much data, it is able to receive, before transmitting an acknowledgement to the sending computer. 
-> In each TCP segment, receiver will specify in the receive window field the amount of additional receive data in bytes, that it is willing to buffer for the connection.  
-> Sending host can only send upto that amount of data,before it must wait for an acknowledgement and windown size update from the receiving host. 
  
-> UDP does not implement flow control. VoiP which uses UDP , even though there is no physical connection between two  handsets involved in telephone call, call will stay up and the sender  will continue sending huge amounts of data, even if receiver cant proces the received data.  
-> UDP relies on higher layer protocols to implement flow control 

o) CONNECTION ORIENTED 
-> TCP is connnection oriented
-> TCP will establish session connection and maintain the connection during the entire transmission 
-> Once transmission is complete, session is terminated  

-> UDP is connectionless 
-> UDP does not set up sessions and will just send data in the hope that the receiver will receive it  

p) RELIABILITY
-> TCP implements reliability where every segment transmitted is acknowledged. 
-> If the segment went missing, it is retransmitted. 

-> UDP does not implement reliability and relies on higher layer protocols to implement any reliability if required. 
-> In certain cases like Voice Over IP or video transmitted over an IP infrastructure, reliability is not required. There is no point in retransmission of lost voice packets. 


82) COMPARISON: BETWEEN UDP AND TCP 
a) TCP is reliable / UDP is best effort-Unreliable 
b) ConnectionType: 
TCP is connection oriented, 3 way handshake/ UDP is connectionless and does not track data or ensure delivery of data 
c) Sequencing: 
TCP uses sequence numbers/ UDP does not use 

d) Applications that use:
TCP: HTTP, email, FTP/ UDP: Voice streaming  app like void, video streaming applications 


83) UDP:
a) UDP is a transport layer protocol 
b) access to layer3 without overhead of reliability mechanisms 
c) ideal for voip and video streaming apps 
d) connectionless where one way datagram is sent to destination without advanced notification to destination device 
e) No prior communication before transmission of data
-> Data just arrives at receiver and expected that receiver should handle the data 
f) Provides limited error checking 
-> UDP has optional checksum value which receiving device can use to test integrity of data 
g) UDP header also includes destination port number and if that datagram is directed to an inactive port on receiving device, a return message can be transmitted to indicate that the port is unreachable.   
h) Provides best effort delivery 
i) No data recovery features 

j) UDP HEADER: 

---------------------------------------------
16 bit source portNO| 16 bit destination port|
----------------------------------------------
16 bit UDP length   | 16 bit UDP checksum    |
----------------------------------------------
                  DATA                      |
----------------------------------------------

 UDP checksum  -> Optional in IPv4 and not optional in IPv6 


84) TCP:
a) TCP is a transport layer protocol  
b) Connection oriented 
-> before transmission of actual data, session is established between two devices 
c) Allows higher layer protocols access the network layer or IP layer 
d) TCP implements full duplex mode of operation 
-> TCP connection is a pair of virtual circuits one in each direction, which operate in full duplex mode. 
-> Transmitter can receive data at the same time, it is transmitting 
-> Both hosts in a conversion can transmit and receive at the same time. 
e) Error checking available in TCP - checksum available in datagram to verify that there is no corruption of data 
f) TCP segments are also numbered and sequenced so that destination can reorder segments and determine if data is missing . 
g) There is also acknowledgement of receipt of data so all data is acknowledged by the receiver 
-> If segments are not received by the receiver, the transmitter or sender can retransmit the segment or terminate the connection  if it determines that the receiver is no longer involved in the conversation. 
e) TCP implements data recovery features - in other words there can be retransmission of lost data. If there is no acknowledgement of a segment, the segment will be retransmitted. 
f) TCP segments are sent using IP packets 
g) TCP header will follow following IP header supplying information specific to the TCP protocol 


------------------------------------------------------
16bit source port      | 16bit destination port       |
-------------------------------------------------------
              32 bit sequence number                  |
--------------------------------------------------------
          32 bit acknowledgement number               |
---------------------------------------------------------
Header |Reserved |C|E|U|A|R|S|F|   Window Size        |
length |         |W|C|R|C|S|Y|I|                      |
       |         |R|E|G|K|T|N|N|                      |
---------------------------------------------------------
               Options                                |
---------------------------------------------------------
                Data                                  |
----------------------------------------------------------

h) TCP header has many more options than the UDP header 
1) 16 bit source port number - identifies the sending port 
2) 16 bit destination port - identifies the receiving port 
3)  32 bit sequence number 
       - If SYN bit is set, The sequence number of actual first databye are then this sequence number plus 1 
	   - If SYN bit is not set, then sequence number is the accumulated sequence number of the first data byte of this packet for the current session. 
4) 32 bit acknowledgement number - if ACK flag is set,then value of acknowledgement number is equal to next sequence number that receiver is expecting to receive 
      - This field acknowledges receipt of all prior bytes
      - The first ACK or acknowledgement send by each end, acknowledges the other end's initial sequence number   but no data 
5) Header Length or Data offset specifies the size of TCP header in 32 bit words 
	  - Minimum size of header is 5 words and maximum is 25 words 
	  - Minimum size of header is 20 bits and Maximum size of header is 60 bits in IPv4 which allows upto 40 bytes of options in the header 
	  
6) Reserved - Reserved field is set to 0 and is reserved for future use. 
7) FLAGS or Control bits available in TCP header 
   CWR - Congestion window reduced flag is part of congestion notification mechanism used in conjunction with ECE bit or flag 
   ECE - Echo congestion notification echo flag is also used in congestion notification. This can be used in quality of service where the network and the hosts communicate to indicate congestion, therefore letting the transmitter know that it needs to slowdown 
   URG -urgent flag can indicate that this segment is urgent and should be processed as soon as possible 
   ACK - acknowledgement flag is used for acknowledgement of data 
   PSH - push is the flag set by TCP sender to cause the TCP receiver to immediately pass that segment's data to the receiver's application socket, along with all other in order data that the receiver is yet to give to that application 
   RST - Resets the connection. In other words connection is torn down. 
   SYN - is used to synchronize sequence numbers.Only the first packet sent from each end will have this flag set. 
   FIN - finish means there is no more data from the sender 
8) Window Size:
-> 16bits in length 
-> Specifies the size of received window, which is the number of bytes that the receiver is currently willing to receive 
-> This is related to flow control 
9) 16 bit TCP checksum
-> 16 bits TCP checksum is used for error checking of the header and the data 
10) 16 bit urgent pointer
-> It is used along with URG flag, which when set on means that the 16 bit urgent pointer is used. 
-> This indicates an offset from the sequence number indicating the last urgent data byte
11) Options 
-> Various options are available in TCP 
-> out of scope of this course 
12) Data:
-> This is the data from higher layer protocols encapsulatd within the TCP header 


85) HOW LAYERS CONNECT TOGETHER:

Application 
Transport 
Network 
Datalink
Physical 

Lets look on how mappings work between different layers of the osi model 
a) At layer2 in an Ethernet2 frame, there is a field called TYPENUMBER - which allows host to differentiate between multiple layer 3 protocols 
-> We could be using IPv4 or IPv6 
   At Layer2, NIC needs to know, which layer3 protocol to send traffic  
b) AT Layer3 - A PROTOCOL NUMBER is used to differentiate
different protocols running at layer4. So in an IP header  - protocol field will denother whether TCP or UDP is being used at layer4 
c) At Layer4 - A PORT NUMBER is used to differentiate multiple applications being used at layer 7
-> Important to note at layer4, the way TCP or UDP know which application this traffic is destined is by the PORT NUMBER 
	  
	   
	   
85) Applications:
FILE TRANSFER APPLICATIONS: 
FTP file transfer protocol
TFTP trivial file transfer protocol 
NFS - Network file system 

EMAIL:
POP3 - Post office protocol to receive mail 
SMTP - Simple mail transfer protocol to send mail 
IMAP - Internet message access protocol for email retrieval 

REMOTE LOGIN: 
TELNET - sends traffic in clear text , hence insecure 
SSH - Secure shell , helps in secure connection to remote devices 

NETWORK MANAGEMENT: 
SNMP - Simple network management protocol 

NAME MANAGEMENT:
DNS - Domain name system which helps in use of names rather than IP addresses. 



86) PORT NUMBER:
a) When a PC is connecting to a webserver on internet , traffic will be sent from a source IP address  to a destinatioon IP Address 

PC1-------------(ROUTER)-------WEBSERVER
10.1.1.1						10.1.2.1


SA: 10.1.1.1:60000 | DA: 10.1.2.1:80 

->Source IP address in this transmission is: 10.1.1.1 to the server 10.1.2.1 

-> Traffic will be routed from the PC to the server and when the traffic arrives at the server, the server needs a way to differentiate which application to send this traffic 
-> Well known port numbers are used for various common day applications like HTTP .
-> Server 10.1.2.1 will be running web server application like IIS or apache which serves the web pages for the web browsers


b) Using Apache as an example: Apache server will be listening to traffic on port 80 which is well known port number for http 
-> Your browser will automatically open up a connection to the service IP address on that port number 

c) When traffic arrives at transport layer, TCp will send that traffic to port 80, the port to which apache server is listening on. 
-> Apache server at the application layer will process the data received.
-> PC will use random source portnumber in a specific range, which is dependent on the operating system. 

d) RANDOM PORT NUMBER IS USED AS SOURCE AND WELL KNOWN PORT IS USED AS DESTINATION 

e) When the reply from server is sent back to PC,the source address will be server's IP address and destination address will be PC's IP address 

SA: 10.1.2.1:80 | DA: 10.1.1.1:60000 


f) THe PC's web browser will be listening on this port: 60000
-> WHen the traffic arrives at the PC's transport layer which is TCP, TCP will push that traffic to port 60000  
-> Thus port numbers bind layers 4 to 7 

G) WELL KNOWN PORTS:
a) Well know port numbers are in the range: less than or equal to 1023 i.e <=1023 

-> DNS uses UDP on port53 to serve request i.e for name resolution, while TCP is used for the response data exceeds 512 bytes or for tasks such as Zone transfers 
-> Zone transfers are used for replication of databases containing DNS data across set of DNS servers 

-----------------------------------------------------
APPLICATION        |PORT NO | TRANSPORT LAYER 
-----------------------------------------------------
HTTP               | 80     | TCP
-----------------------------------------------------
FTP                | 21     | TCP
-----------------------------------------------------
FTP Data           | 20     | TCP
-----------------------------------------------------
Telnet             | 23     | TCP
-----------------------------------------------------
DNS                | 53     | TCP/UDP 
-----------------------------------------------------
TFTP               | 69     | UDP
-----------------------------------------------------
SNMP               | 161    | UDP
-----------------------------------------------------

   

-> IANA port numbers list : https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml


k) THREE RANGES OF PORT NUMBERS according to IANA 

Complete port range is from : 0 to 65535 

1) Well known ports: <=1023 
2) Registered ports: 1024 to 49151 
3) Dynamically assigned port numbers:49152 to 65535  

-> However vendor implmentations dont follow IANA recommendation 

l) Ephemeral Port numbers: 

1EPHEMERAL port numbers : They are short lived ports used for client side of a connection 

eg: When your pc initiatea a session to webserver an Ephemeral port will be used. 

2 These port numbers are temporary and last only for the duration of the session 
3 IANA suggests 49152 to 65535, 
4 However BSD uses ports 1024 to 4999
5 Linux uses ports 32768 to 61000 
6 Windows through server 2003 use: 1025 to 5000
	Windows Vista/7 uses IANA range. 
7 Free BSD uses IANA range since release 4.6 


m) Thus source port numbers used by hosts vary based on Vendor implementation and which ephemeral port numbers that vendor has decided to use. 


87) TCP - 3 WAY HANDSHAKE - ESTABLISHING A CONNECTION:

TOPOLOGY:

HOSTA--ROUTER1---{{{INTERNET}}}--ROUTER2---HOSTB 


-> When using TCP, devices must first establish a connection oriented session with a peer system. 
-> One machine will initiate the connection which must then be accepted by the other machine. 
-> Protocol software modules in the operating systems of host devices communicate with each other by sending messages across the network 
-> they send messages across the network to verify that the transfer is authorized and both sides are ready for transmission of data 

-> For this to  take place - a 3 way handshake occurs between the host devices during TCP  

HOSTA--ROUTER1---{{{INTERNET}}}--ROUTER2---HOSTB 

3 WAY HANDSHAKE - STEP 1
a) HostA initiating the session will set the SYN flag or SYN bit in the TCP header of the initial segment sent to Host B .i.e CTL=SYN is set to 1 
b) Host A will also choose an initial sequence number for eg: SEQ=100  
-> This is used to start the handshake process. 
c) This synchronization segment also specifies the port number to which sender wants to connect. 

            HOSTA   ========================> HOSTB 
SEND SYN SEQ=100, CTL=SYN
                   SYN set to 1 


3 WAY HANDSHAKE - STEP 2:
a) HOSTB on the right hand side will be waiting for a connection request from the remote client HOSTA 
b) When the SYN is received and accepted, HOSTB will send back a TCP segment with both the SYN and ACK flags set.
c) These are used to negotiate the connection and acknowledge receipt of the initial synchronization segment of the sender. 
d) B also sets an initial sequence number say 300 to indicate hte next sequence number of the next byte of data, it expects to receive from HOSTA 
e) HOSTB also sets the acknowledgement flag to 101, An ACK flag indicates the next portion of data , the host expects to receive 
-> HostA initially sets a sequence number of 100 and HostB (assuming window size of 1) sends back an acknowledgement of 101. 



            HOSTA   <======================== HOSTB 
Received SYN,Send SYN,ACK 
CTL=SYN, ACK  SEQ=300 ACK=101 
i.e SYN & ACK set to 1 


3 WAY HANDSHAKE - STEP 3:
a) Initiating Host - HostA has received the SYN from HOSTB and sends back a TCP segment with Control field set to ACK
b) HostA is therefore acknowledging the next segment it expects to receive from HostB in this case 301. 
-> Initially HostB sent a sequence number of 300 
-> So HostA is expecting next segment of 301 
c) HostA sets its sequence number to 101 , initial segment was 100, so the next one in this case is 101 
d) SYN flag is Unset so, it confirms that 3 way Handshake has completed successfully  




		 HOSTA   <======================== HOSTB
SYN received and 
Session Established
CTL=ACK  ACK=301 SEQ=101
ACK set to 1 and SYN=0 
-> SYN=0 confirms threeway handshake completed 
successfully 	 


88) TCP sql and ACk - in more detail 
-> Hosts choose initial sequence numbers randomly 
-> Sequence number and acknowledgements can cause lot of confusion - hence adding more explanation
->  Assume a window size of 1 
                  Window size is the maximum amount of data that the receiver can receive from a sender and process correctly 
				  ->Window size of 1 means we assume that only 1 segment can be transmitted at any given time, before an acknowledgement is received to acknowledge receipt of that segment 
			

 HOSTA   <========================> HOSTB

 
				  
a) Lets assume HostA starts with initial sequence number of 5 
-> Since we have window size of 1, only 1 segment can be sent from A to B 

 HOSTA   ========================> HOSTB
SEQNUM:5 


b) B successfully receives the segment from A and acknowledges the next segment that it wants to receive 
-> so rather than acknowledging receipt of sequence number of 5, it acknowledges for sequence number 6, which implies that all previous sequence numbers were received correctly 
-> SO B acknowledges in this case for sequence number 6.
-> Here B may start with an initial sequence number of 10. 
-> So in TCP header B tells that its initial sequence number is 10  and it successfully received sequence number 5 from A and expects seq number 6 from A in the next packet.  


 HOSTA  <======================== HOSTB
                                SEQnNUM:10, ACK NUM:6 
								
								
-> So lets assume  A successfully received the segment from B 

c) Now A will send segment6 to B  and A also acknowledges successful receipt of segment 10 from HOSTB and it expects seq num 11 from B 

 

 HOSTA   ========================> HOSTB
SEQNUM:6, ACK NUM=11  

-> So lets assume B successfully received the segment from A 

d) So after successfully receiving the segment, HOSTB will acknowledge for segment7  and it sends segment 11 to A 


 HOSTA  <======================== HOSTB
                                SEQnNUM:11, ACK NUM:7 
								
							
							
e) IMPORTANT POINTS:
a) Initial sequence number can differ:
b) ACK NUM indicate next sequence num that host expects to receive  

f) Flow control prevents an issue of sender, sending so much data which causes the buffers of the receiver to be overflowed 

->if  HOSTA is very powerful machine and HOSTB is older machine - it is possible that A can overrun the buffers of B by sending so much data 
-> Hence B needs a mechanism to tell A to slowdown, so that B can successfully process the traffic that it is receiving  

g) Consider another scenario for flow control 

1) Here Window size is 3, means that  HOSTA can send 3 segments of data before getting an acknowledgement.
-> The advantage of increasing the window size is that throughput  can increase dramattically because a host can send more data with few acknowledgements and therefore the round trip timers decrease dramatically
-> IN our example host sends 3 segments to B 

 HOSTA  <======================== HOSTB
								[Receive buffer full]

2) Lets assume that receive buffer of B is full and it cant handle that amount of data 
3) B will send a NOT READY indicator to A. It does this by setting window size to 0. 
-> Setting window size to 0, tells sender to stop sending data and wait for ready indicator received from receiver 


4) Assuming that HOSTB has now been ready to process the data in its receive buffer
-> HOSTB can send a ready indicator to A, to resume sending of datagrams 

HOSTA  <======================== HOSTB
				READY		[Receive buffer ready]
				
5) A resumes transmission by sending: 3 segments to B, as the window size is 3.  

6) Thus in the background, TCP host involved in conversation can negotiate various parameters and one of them is FLOW CONTROL : WHERE  receiver CAN TELL SENDER TO SLOW DOWN OR STOP SENDING DATA until receiver has buffer space available to receive transmitted segments 

7) This helps in communication between a very powerful fast machine and a slow or less powerful machine - where they can negotiate the rate of transmission   
								
89) TCP Acknowledgement/Windowing/Sliding Windows : 
a) In its basic form, TCP may have window size of 1 
-> Which means that for every individual segment transmitted by the sender , the receiver sends an acknowledgement for that individual segment 
-> Window size of 1 slows down the throughput dramatically because the sender cannot transmit anymore data until it receives acknowledgement on that single segment transmitted. 
b) TCP thus allows greater window sizes to allow more segments to be transmitted before receiving an acknowledgement. 

c) Window:
Window is the number of data segments, sender is allowed to send without getting acknowledgement from the receiver

d) Increased window size reduces time for transporting segments of data between A and B  
-> Thus increasing window size increase throughput dramatically 

e) In TCP rather than using fixed window size, hosts tend to use Slidng windows

SLIDING WINDOWS:
-> THEY START WITH SMALL WINDOW SIZE AND THEN EXPONENTIALLY INCREASE WINDOW SIZE TO GAUGE THE AMOUNT OF DATA THAT THE RECEIVER CAN RECEIVE AND WHAT THE NETWORK CAN HANDLE 
-> We would have noticed this while downloading a file from the internet . Initially the download speed is slow , but then it increases to a certain point over time 
-> This is because window size is initially small , but then increases exponentially until a packet is dropped or the receiving host handle the amount of data. 
-> IMPORTANT POINT: In sliding window, when packets get dropped by the network, the host will slow down because the window size will get reduced dramatically 

f) WINDOW SIZE:
-> In short: window size is either the window granted to the sender by the receiver 
-> Or a calculated window called the congestion window or CWND 
g) 
CONGESTION WINDOW(CWND) : It is initially set to very low value at connection establishment and then increases at exponential rate. 

-> For every LOST SEGMENT, CONGESTION WINDOW IS HALVED, after lost segment has been successfully retransmitted - the congestion window grows again until it reaches vaule of the half of the original congestion window. 
-> It then slows down its growth using an algorithm called congestion avoidance. 

h) Weighted Random Early Detection(WRED):
In quality of service, weighted random early detection can be used to improve efficiency of TCP transmissions across the link 
-> As packets are randomly dropped from various flows or various sessions going across an individual interface , rather than packets from multiple sends being droped at same time. 
-> This avoids an issue called Global Synchronization : where packets from multiple TCP sessions are dropped at the same time. THerefore multiple hosts reduce their window size and slowdown at the same time and then gradually increase their window size and throughput at the same time. 
-> We have many hosts slowing down and speeding up at the same time 
-> With WRED some hosts willbe slowing down and other hosts will be increasing their throughput because of random drops 

i) QUALITY OF SERVICE documentation contains more details about : WRED, Global Synchronization , Congestion window 

90) TCP SEQ and ACK 

HOSTA <----ROUTER1------{{INTERNET}}---ROUTER2----->HOSTB

a) In this example, HOSTA initiates a session with source port of 1024  and destination port of 23 which is telnet 

   HOSTA  ========================> HOSTB
            10bytes data 
			
------------------------
SOURCE PORT | DEST PORT|
1024        |   23	   |
------------------------


b) HOSTA sends 10 bytes of data with an initial sequence number of 10 

 HOSTA  ========================> HOSTB
            10bytes data 
			
---------------------------------
SOURCE PORT | DEST PORT| Seq Num |
1024        |   23	   |	10   |
------------------------------------			
			
c) HOSTB acknowledges receipt of the 10 bytes, by sending an acknowledgement number back to A of 11  
-> HostB also sets an initial sequence number of 5 
-> We can see that the port numbers are reversed 

 HOSTA  <======================== HOSTB
 
 
 --------------------------------------------
SOURCE PORT | DEST PORT| Seq Num |Ack Num  |
23          |  1024	   |	5   |	11	   |
----------------------------------------------	

d) IN PRACTICAL SCENARIOS,WINDOW SIZE IS NOT SET TO 1 OR 2, INSTEAD WINDOW SIZES ARE SET TO THE AMOUNT OF DATA THAT CAN BE TRANSMITTED IN BYTES 

Sample for 250 bytes of data :

 HOSTA  ========================> HOSTB
              250 bytes data 
 --------------------------------------------
SOURCE PORT | DEST PORT| Seq Num |Ack Num  |
1024        |  23      |	260  |	6	   |
----------------------------------------------	


e) HOSTBs acknowledgement for sequence number 261
->A sent 10 bytes earlier and now 250 bytes, hence 260 bytes of data 

 HOSTA  <======================== HOSTB
              
 --------------------------------------------
SOURCE PORT | DEST PORT| Seq Num |Ack Num  |
23          |  1024    |	6    |	261	   |
----------------------------------------------	


91) TLS:
a) Understanding SSL and TLS requires understanding the interaction between 3 players: 
CLIENT 
SERVER 
CERTIFICATE AUTHORITY 


######
1) Symmetric vs asymmetric encryption: 
-> Symmetric encryption uses the same key to both encrypt and decrypt data, 
-> while asymmetric encryption uses two different keys for the same purpose. 
-> Symmetric encryption is faster and easier to use than asymmetric encryption, but it is less secure. If the key is compromised, the data can be easily decrypted.

2) Self-signed TLS/SSL certificate:
-> A self-signed TLS/SSL certificate is not signed by a publicly trusted certificate authority (CA) but instead by the developer or company that is responsible for the website; 
-> as they are not signed by a publicly trusted CA, they are usually considered unsafe for public applications and websites.

#######

b) Steps: 


1) CERTIFICATE AUTHORITY:
-> It all starts with the Certificate authority . 
-> CA is the corner stone of TLS/SSL process 
->  CA has its own Asymmetric key pair . 
	A) CA has PUBLIC KEY and PRIVATE KEY 
	B) CA has a SELF-SIGNED CERTIFICATE 
	-> this certificate affirms the identity of this Particular Certificate authority 
	
	-> Certificate includes CA's public key 
		Orange certificate which identifies orange Certificate Authority is also signed in Orange. This is called self signed certificate   
		
2) SERVER: Server want to acquire a certificate
-> Server could be a website 
-> Server could be a SSL VPN client 
-> Server could be a SSL VPN termination point. 

-> Server is anything that wants to prove its identity and to do the same, it needs a certificate 
3)  To get a certificate, server will start by generating its own public and private key 
4)  Server will generate a CSR: Certificate Signing Request(CSR). CSR is a file that is used to request actual certificate 
	● CSR contains Server's public key . 
	● CSR is signed with Server's private key. This proves that CSR has the correlating private key to the public key inside it. 
5) Server gives signed CSR to Certificate Authority(CA) 
6)  CA inspects and validates information in CSR  and Thus verify Server's identity. 
	-> CA verifies Server's identity based on the type of Certificate the server purchased: DV, OV, or EV 
7) Once CA verifies Identity, CA creates certificate using information present inside CSR namely the public key  
    -> CA has Server's public key because it was included in the CSR 
8) CA signs Certificate using CA's private key.
   -> Signing certificate involves tying a particular set of asymmetric keys to a particular identity   
   -> THis identity is guaranteed by the certificate authority 
9) CA gives Certificate to User 
10) Server can use this Certificate to prove its identity for its clients.  or 
    Server can then provide Certificate to prove its identity 
	
-> After this, clients come into picture 
	
	
11) Client: 
	-> Client is simply an entity that wants to connect to server securely (Normal PC client) 
	-> Before the client connects to the server, Client already has : Web Browsers which already have CA certificates pre-installed. 
	   These pre-installed CA certificates comes bundled with various web browsers or sometimes with the operating system itself. 
    -> So, at this point we NO LONGER NEED THE CERTIFICATE AUTHORITY. 
	-> Everything else that happens is simply between Client and the Server 


12) Client requests Server's Certificate: 
	-> Now the client can make a request to server and ask for the server's certificate. 
	-> Upon receiving the certificate, there are two things that the client must verify 
	I) CLIENT HAS TO VALIDATE IF THE CERTIFICATE IS LEGITIMATE 
	   FYI: Certificates are just text inside a file. How do we know that text has not been changed. How do we know that text has not been simply typed via notepad.
	   -> Client will verify it by checking the signature using Certificate Authority's public key 
	   FYI: Signature was created using CA's private key, which means it can be verified using CA's public key. 
	        Public key was included in the  CA certificate, the client already has installed.
    II) VERIFY IF THE SERVER IS THE TRUE OWNER OF THE CERTIFICATE 	
	   FYI: Certificates are public knowledge. Everytime you connect to a new website - you are downloading that website's certificate. 
	   TO CHECK IF SERVER IS TRUE OWNER OF THE CERTIFICATE: CLIENT WILL MAKE SURE THAT THE SERVER HAS THE MATCHING PRIVATE KEY TO THE PUBLIC KEY THAT WAS PRESENTED IN THE SERVER CERTIFICATE. 
	   -> IN THEORY ONLY THE SERVER SHOULD HAVE THE MATCHING PRIVATE KEY AND IF THE SERVER MAKE SURE THAT IF IT HAS THE MATCHING PRIVATE KEY , THEN CLIENT CAN CONFIRM THAT SERVER IS THE TRUE OWNER OF THE CERTIFICATE 
	   
	
	-> Checking Certificate Revocation might involve CA, depending on the method the client uses: CRL, OCSP or OCSP stapling 
	
	
13) SSL Handshake: SSL handshake validates the following:
a) CLIENT HAS TO VALIDATE IF THE CERTIFICATE IS LEGITIMATE 
b) VERIFY IF THE SERVER IS THE TRUE OWNER OF THE CERTIFICATE 

c) As part of the handshake, client and server exchange pieces of information which allows the client to verify the above said two items viz: if certificate is legitimate and if server is true owner of certificate 
d) Handshake also allows client and server to establish cryptographic symmetric keys which is the outcome of Successful SSL handshake. 
e) Thus SSL/TLS Handshake produces Session Keys to protect bulk data transferred between client and server. 
f) There will be :
SYMMETRIC ENCRYPTION: One set of symmetric encryption keys to provide confidentiality 
MESSAGE AUTHENTICATION CODE(MAC): One set of symmetric MAC keys to provide integrity and authentication 
-> SSL handshake actually produces few more keys that these above. 
g) Session Keys create a secure tunnel within which data can be transferred securely between client and server

-> These 13 steps which we have seen so far is the 10000 foot view of the full TLS and sSL process 


	
	################
	
92) TLS part 2:
1)  TLS:
a) Understanding SSL and TLS requires understanding the interaction between 3 players: 
CLIENT 
SERVER 
CERTIFICATE AUTHORITY 


######
1) Symmetric vs asymmetric encryption: 
-> Symmetric encryption uses the same key to both encrypt and decrypt data, 
-> while asymmetric encryption uses two different keys for the same purpose. 
-> Symmetric encryption is faster and easier to use than asymmetric encryption, but it is less secure. If the key is compromised, the data can be easily decrypted.

2) Self-signed TLS/SSL certificate:
-> A self-signed TLS/SSL certificate is not signed by a publicly trusted certificate authority (CA) but instead by the developer or company that is responsible for the website; 
-> as they are not signed by a publicly trusted CA, they are usually considered unsafe for public applications and websites.

#######

b) Steps: 


1) CERTIFICATE AUTHORITY:
-> It all starts with the Certificate authority . 
-> CA is the corner stone of TLS/SSL process 
->  CA has its own Asymmetric key pair . 
	A) CA has PUBLIC KEY and PRIVATE KEY 
	B) CA has a SELF-SIGNED CERTIFICATE 
	-> this certificate affirms the identity of this Particular Certificate authority 
	
	-> Certificate includes CA's public key 
		Orange certificate which identifies orange Certificate Authority is also signed in Orange. This is called self signed certificate   
		
2) SERVER: Server want to acquire a certificate
-> Server could be a website 
-> Server could be a SSL VPN client 
-> Server could be a SSL VPN termination point. 

-> Server is anything that wants to prove its identity and to do the same, it needs a certificate 
3)  To get a certificate, server will start by generating its own public and private key 
4)  Server will generate a CSR: Certificate Signing Request(CSR). CSR is a file that is used to request actual certificate 
	● CSR contains Server's public key . 
	● CSR is signed with Server's private key. This proves that CSR has the correlating private key to the public key inside it. 
5) Server gives signed CSR to Certificate Authority(CA) 
6)  CA inspects and validates information in CSR  and Thus verify Server's identity. 
	-> CA verifies Server's identity based on the type of Certificate the server purchased: DV, OV, or EV 
7) Once CA verifies Identity, CA creates certificate using information present inside CSR namely the public key  
    -> CA has Server's public key because it was included in the CSR 
8) CA signs Certificate using CA's private key.
   -> Signing certificate involves tying a particular set of asymmetric keys to a particular identity   
   -> THis identity is guaranteed by the certificate authority 
9) CA gives Certificate to User 
10) Server can use this Certificate to prove its identity for its clients.  or 
    Server can then provide Certificate to prove its identity 
	
-> After this, clients come into picture 
	
	
11) Client: 
	-> Client is simply an entity that wants to connect to server securely (Normal PC client) 
	-> Before the client connects to the server, Client already has : Web Browsers which already have CA certificates pre-installed. 
	   These pre-installed CA certificates comes bundled with various web browsers or sometimes with the operating system itself. 
    -> So, at this point we NO LONGER NEED THE CERTIFICATE AUTHORITY. 
	-> Everything else that happens is simply between Client and the Server 


12) Client requests Server's Certificate: 
	-> Now the client can make a request to server and ask for the server's certificate. 
	-> Upon receiving the certificate, there are two things that the client must verify 
	I) CLIENT HAS TO VALIDATE IF THE CERTIFICATE IS LEGITIMATE 
	   FYI: Certificates are just text inside a file. How do we know that text has not been changed. How do we know that text has not been simply typed via notepad.
	   -> Client will verify it by checking the signature using Certificate Authority's public key 
	   FYI: Signature was created using CA's private key, which means it can be verified using CA's public key. 
	        Public key was included in the  CA certificate, the client already has installed.
    II) VERIFY IF THE SERVER IS THE TRUE OWNER OF THE CERTIFICATE 	
	   FYI: Certificates are public knowledge. Everytime you connect to a new website - you are downloading that website's certificate. 
	   TO CHECK IF SERVER IS TRUE OWNER OF THE CERTIFICATE: CLIENT WILL MAKE SURE THAT THE SERVER HAS THE MATCHING PRIVATE KEY TO THE PUBLIC KEY THAT WAS PRESENTED IN THE SERVER CERTIFICATE. 
	   -> IN THEORY ONLY THE SERVER SHOULD HAVE THE MATCHING PRIVATE KEY AND IF THE SERVER MAKE SURE THAT IF IT HAS THE MATCHING PRIVATE KEY , THEN CLIENT CAN CONFIRM THAT SERVER IS THE TRUE OWNER OF THE CERTIFICATE 
	   
	
	-> Checking Certificate Revocation might involve CA, depending on the method the client uses: CRL, OCSP or OCSP stapling 
	
	
13) SSL Handshake: SSL handshake validates the following:
a) CLIENT HAS TO VALIDATE IF THE CERTIFICATE IS LEGITIMATE 
b) VERIFY IF THE SERVER IS THE TRUE OWNER OF THE CERTIFICATE 

c) As part of the handshake, client and server exchange pieces of information which allows the client to verify the above said two items viz: if certificate is legitimate and if server is true owner of certificate 
d) Handshake also allows client and server to establish cryptographic symmetric keys which is the outcome of Successful SSL handshake. 
e) Thus SSL/TLS Handshake produces Session Keys to protect bulk data transferred between client and server. 
f) There will be :
SYMMETRIC ENCRYPTION: One set of symmetric encryption keys to provide confidentiality 
MESSAGE AUTHENTICATION CODE(MAC): One set of symmetric MAC keys to provide integrity and authentication 
-> SSL handshake actually produces few more keys that these above. 
g) Session Keys create a secure tunnel within which data can be transferred securely between client and server

-> These 13 steps which we have seen so far is the 10000 foot view of the full TLS and sSL process 




2) HTTPS
-> Without https communication between client and server is in plain text 
-> HTTPS helps to send data in encrypted fashion. HTTPS is an extension of HTTP protocol 
a) In HTTPS data is sent in encrypted form using TLS. TLS is transport layer security 
b) How TLS handshake works :
STEP 1: Just like http, browser establishes a tcp connection with server using via 3 way handshake : TCP SYN + TCP SYN +ACK+ TCP ACK


1. TCP Handshake 
         Client                        Server
 		 |---------------TCP SYN ----->|
		 |<------TCP SYN+ACK ----------|
		 |---------------TCP ACK ----->|
	.......Connection establishedd...............
	
	
STEP2: This is where TLS handshake begins 

2. Certificate check or hello phase of tls handshake: 

        i) Process sends a CLIENT HELLO to the server. In this hello message, browser tells the following to the server: What TLS version can the browser support? like TLS1.2, TLS1.3 etc 
		ii) What cybersuite the browser supports. Cyber suite is a set of encryption algorithms to use to encrypt data. 
		iii) After receiving client hello, the server chooses the cybersuite and the TLS version to use, based on the options it got from client. 
		iv) The chosen information about cybsersuite and TLS version is sent in SERVER HELLO message which is sent from server to the client 
		v) Server then SENDS CERTIFICATE to the client. Certificate includes lot of things. Important among them are: public key of the server . 
		   Client uses the public key in asymmetric encryption 
-> In asymmetric encryption, piece of data that is encrypted by a public key can only be decrypted by the private key 
       vi) This concludes  Step 2, which is the hello phase of the tls handshake 
	   vii) At this point, client has a server certificate, client/server has agreed on the TLS version/Cyber suite to use.   

         Client                        Server
	     |---------------TCP SYN ----->|
		 |<------TCP SYN+ACK ----------|
		 |---------------TCP ACK ----->|
	.......Connection establishedd...............Assymetric encryption [Public Key/Private Key] 
	     |							   |
		 |--Client hello-------------->|
	     |							   |
		 |<------------Server hello----|
	     |							   |
		 |<----------Certificate-------|
	     |							   |
		 |<---Server hello done--------|
		 
STEP3: Key exchange 

3. Key exchange: 


	i) Client key exchange message: 
-> In this step,client and server  come up with a shared encryption key to encrypt data. 
-> This is where asymmetric encryption comes into the picture.  In asymmetric encryption, piece of data that is encrypted by a public key  in client side can only be decrypted by the private key in server side 
-> This is how client sends a encryption key safely to the server over the internet. 
	-> All these is done In Client key exchange message 
	ii) Exact details varies depends on the cybersuite used. 
	iii) In our example we will use RSA as an example, since it is the easiest to understand.  
	RSA: 
	iv) With RSA, client generates an encryption key also called a session key.  
	v) Then With RSA, session key is encrypted with server public key and we get encrypted session key in Client side 
	vi) The encrypted session key is sent to server side 
	vii) The server receives the encrypted session key and decrypts it with its private key 
	viii) After decryption of encrypted session key , we get the session key which the client was holding earlier 
	-> After this they enter step 4 of the TLS handshake 
	
	Session Key ---------> encrypted session key 

         Client                        Server
	     |---------------TCP SYN ----->|                    
		 |<------TCP SYN+ACK ----------|              TCP handshake 
		 |---------------TCP ACK ----->|
	.......Connection establishedd...............Assymetric encryption [Public Key/Private Key] 
	     |							   |
		 |--Client hello-------------->|
	     |							   |
		 |<------------Server hello----|			Certificate Check 
	     |							   |
		 |<----------Certificate-------|
	     |							   |
		 |<---Server hello done--------|
..........................................................
	     |							   |
		 |--Client key exchange------->|
	     |							   |
		 |--Change cipher spec-------->|			Key exchange  
	     |							   |
		 |---------Finished----------->|
	     |							   |
		 |<--Changed cipher spec-------|
		 |    						   |
	     |							   |
		 |<--Finished------------------|		 



4. STEP4: Data transmission 

   i) In step4 which is data transmission, they use the session key and agreed upon cybersuite to send encrypted data, back and forth in a  secure bidirectional channel 
   Thus we use symmetric encryption here, since we use only session key here 
   ii) The main reason why we use symmetric encryption here in data transmission instead of symmetric encryption is :asymmetric encryption is computationally expensive. Asymmetric encryption is not suitable for bulk data transmission 





         Client                        Server
	     |---------------TCP SYN ----->|                    
		 |<------TCP SYN+ACK ----------|              TCP handshake 
		 |---------------TCP ACK ----->|
	.......Connection establishedd...............Assymetric encryption [Public Key/Private Key] 
	     |							   |
		 |--Client hello-------------->|
	     |							   |
		 |<------------Server hello----|			Certificate Check 
	     |							   |
		 |<----------Certificate-------|
	     |							   |
		 |<---Server hello done--------|
..........................................................
	     |							   |
		 |--Client key exchange------->|
	     |							   |
		 |--Change cipher spec-------->|			Key exchange  
	     |							   |
		 |---------Finished----------->|
	     |							   |
		 |<--Changed cipher spec-------|
		 |    						   |
	     |							   |
		 |<--Finished------------------|		 
         Client                        Server
	     |---------------TCP SYN ----->|                    
		 |<------TCP SYN+ACK ----------|              TCP handshake 
		 |---------------TCP ACK ----->|
	.......Connection establishedd...............Assymetric encryption [Public Key/Private Key] 
	     |							   |
		 |--Client hello-------------->|
	     |							   |
		 |<------------Server hello----|			Certificate Check 
	     |							   |
		 |<----------Certificate-------|
	     |							   |
		 |<---Server hello done--------|
..........................................................
	     |							   |
		 |--Client key exchange------->|
	     |							   |
		 |--Change cipher spec-------->|			Key exchange  
	     |							   |
		 |---------Finished----------->|
	     |							   |
		 |<--Changed cipher spec-------|
		 |    						   |
	     |							   |
		 |<--Finished------------------|		 
....................................................Symmetric Encryption 
	     |							   |
		 |--Encrypted data------------>|
	     |							   |
		 |         Session key         |			Data transmission 
	     |							   |
		 |<--Encrypted data------------|
	     |							   |
		 |							   |
		 |    						   |
	     |							   |
		 |-----------------------------|	


		 
		 


c) Thus these are the four steps in tls handshake: a) TCP handshake b) Certificate check c) Key Exchange d) Data transmission 
d) Done with TLS handshake lets discuss two more points: 
e) First: Handshake we talked above applied to TLS1.2. While the last version is TLS1.3 
-> TLS1.3 being supported on all major browsers 
-> In our above illustration of handshake - TLS 1.2 takes two network round trips to complete
-> TLS 1.3 optimizes the handshake the reduce the number of network round trips to 1.   which is one of the major improvements of TLS1.3
-> In our illustration we talked about TLS1.2 because we reviewed TLS 1.3 in optimization 
-> As with most optimizations , it is a bit harder to explain. Hence we chose TLS1.2 in our illustration  
-> Core concepts of TLS1.2 applies to TLS1.3 also 
f) Second: We use RSA for symmetric encryption to securely exchange the symmetric session key 
-> We chose RSA because it is easy to understand. 
-> However symmetric session key is not the only way to exchange session key during data transmission. 
-> In TLS1.3 , RSA is no longer supported as a method for key exchange 
-> diffie helman is a more common way nowadays for exchanging session keys 
g) DH is complicated, but in a nutshell it uses some advanced math involving large prime numbers to derive a shared session key without ever transmitting a public key over the network. 

###################


93) VLANs 
->  VLANs to Virtualize our infrastructure
-> While Companies such as VmWare helps virtualize servers 
-> Similarly we are going to virtualize our switches , where one physical switch is virtually multiple switches 
-> This is not full virtualization, We are virtualizing only the local area networks on that specific switch. 

-> In this lesson we will study the following:
► VLAN Overview 
► 802.1Q and ISL : They are trunking protocols , ISL - interswitch link 
► VTP : Virtual trunking protocol - Helps to create vlans on a single switch and have that vlan information propagated to other switches in the topology 


94) Problems with incorrectly/poorly designed networkk

NETWORK1: 
a) If we have one switch connecting to multiple endpoints and one hub connecting to that single switch and hub connected to endpoints 
-> Topology: 1 switch, 1 hub, 6 endpoints 
b) IN this case we will have single broadcast domain and multiple collision domains - 4 here 

                                    HOSTC 
                                     |
									 |
                                     |
HOSTA<-----------------------------SWITCH------------------------->HOSTB
                                     |
									 |
                                     |
									 hub---------HOSTD
									 |
									 |
									 |
									 HOSTC 
									 
									 
									 
									 
-> If one host starts broadcast, that broadcast will be received by everyone 
-> If NIC starts jabbering(ie. sending lot of broadcasts), it can flood your entire network and cause t of issues.  
-> This issue increases exponentially, if more and more devices are sending broadcasts . Hence broadcasts should be limited. 


NETWORK2: 



HOSTA     HOSTB     HOSTC  		HOSTD		HOSTE
 |			|		 |				|			|
 |			|		 |				|			|
 |			|		 |				|			|
SWITCHA  SWITCHB  SWITCHC       SWITCHD       SWITCHE
 |			|		|				|			|
 |			|		|				|			|
 |			|		|				|			|
-------------------------------------------------- 
						|
						|
						|
					SWITCHF--------------------------------------ROUTER-----(INTERNET)
					
-> In this network, if switchF fails , it would affect all devices and the topology. No host will be able to communicate with each other, as all communication nees to go via the single device, which is now a single point of failure.
-> Again broadcasts will flood throughout the network . Broadcast is received on all links and will consume bandwidth on every single link in the topology 
-> Thus every single device has to process the broadcast and the CPU process of all the endpoints will be interrupted. 

94) Overview of VLAN:
a) VLAN is esssentially a single broadcast domain or logical network or logical subnet 
-> We can say VLAN as a group of hosts with a common set of requirements attached to the same broadcast domain. 
-> Regardless of where they are physically located, you are able to group multiple devices together logically, rather than physically 

b) Hence it is possible to span a subnet or VLAN across multiple switches, even though that not recommended 
c) Advantages of VLAN:
-> Segmentation : segment or separate users based on function . Eg sales in a VLAN, accountancy in another VLAN 
-> Very Flexible: Without changing physical cabling, we can move a user from one VLAN to another. 
-> Provides Security: becauses users are in separate VLAN and therefore have to traverse a layer 3 device like router to get from one VLAN to another. 
   -> Can implement Access lists in router to control which users have access to various VLANs 
   -> Have advantages while implementing voip also. Where we can put your ip phones into separate VLAN to your workstations, thereby providing better quality of service to the IP phones.  
   
d) Difference between Physical topology and Logical topology 

-> Logical topology looks very different than physical topology, as soon as VLANs are implemented.

e) VLANs are implemented at layer2. ONly way to move from one VLAN to another is to go via  Layer3 devices such as router. 
--> By default all devices in a switch are connected to VLAN1 

-> Thus, VLAN is a separate logical subnet or separate broadcast domain. 

-> If HOSTA, HOSTB are in red vlan and HOSTC, HOSTD are in green vlan. if HOSTA sends a broadcast to B, then it would be received only by B and not by other devices even though the devices are connected to same physical switch 


f) If devices are in different VLAN , but still wants to connect they can connect via a layer3 device or 
--> A special type of link is needed between two switches so that they can communicate VLAN information between them 
-> That link is known as Trunk Port 

-> An interface connecting two switches will be running a trunking protocol, so that VLAN information can be transmitted from one switch to another switch 

g) Trunking protocols: ISL - Interswitch link  or 802.1Q 

ISL is CISCO propreitary protocol and not used today 
802.1Q is industry standard protocol of choice for communicating VLAN information between switches across trunking ports 


h) Trunking
-> Allows multiple VLAN to traverse a single physical link 
-> Two protocols used: ISL and 802.1Q 



f) 802.1Q frame vs Standard Ethernet frame:

Standard Ethernet frame:

| DEST   | SRC   | LEN/Etype    | data   | FCS |


802.1Q:

| DEST   | SRC   |  TAG |   LEN/Etype    | data   | FCS |


TAG:
|TPID       |PRI   |  CFI     | VLAN ID   |
0x8100


1) Q frame is different from standard Ethernet frame. 
-> 802.1Q has 4 byte tag inserted into the header, between the source address and len/ether type 

-> FCS - frame check sequence is recomputed and altered 

2) Tag consists of two main parts, tag protocol identifier , which is set to 0x8100 to identify that this is a 802.1Q tag frame and thus allows switches/devices to distinguish  802.1q from untagged frames. 
TPID is 16 bits in length; 2 bytes 

3) Remaining 2 bytes i.e 16 bits is split as follows 
3.1) PRI : priority or priority code point: 3 bits 
-> It is used to prioritize certain traffic types over others . This is used heavily in Quality of service . Eg decimal value of 5 used to indicate voice. 

3.2) CFI: Canonical format identifier was used in old days for compatibility between Ethernet and Token ring networks 

3.3) VLAN ID 
-> 12 bit field specifying VLAN to which the frame belongs 
-> A value of 0 will indicate that this frame does not belong to any VLAN 
-> It is because of this field, switches are able to communicate the VLAN number  to each other. 
-> Since it is 12 bits in size, It allows 4096 vlans to be created in an 802.1Q environment. 
-> Thus 4096 vlans could be configured in an 802.1q switch. 



95) VLAN part II
a) Once switches identifies the correct host based on vlan id and other details, the tag for 802.1q will be removed and sent as normal ethernet frame. 
PC's are not aware of tag and hence they process frame was normal ethernet frame. 
b) Native VLAN:
-> 802.1Q trunks have a special VLAN known as native VLAN.  
-> Native VLANs are untagged. 
--> When a port on a switch is setup as a trunk
Eg:  f0/24  interface on Switch1 and Switch2 - Then that interface can receive and transmit tagged frames. 
-> Frames belonging to native VLANs DONOT CARRY VLAN TAGS WHEN SENT OVER THIS TRUNK 
-> In the same manner if an untagged frame was received on the trunk port, that frame would automatically be associated with a native VLAN for this port 
c) Specific management traffic will go across the native VLAN 
for eg: STP BPDU : Spanning tree BPDU will use the native VLAN and also dyanamic trunk protocol  



(Switch1)F0/24 ------------------------(Switch2)F0/24


d) DTP is a way that switches negotiate to setup a trunk between themselves automatically 
e) Certain management traffic always uses VLAN1
f) If you have left VLAN1 as native VLAN, traffic like CDP, VTP, PAGP and UDLP will be transmitted across the native VLAN untagged. 
g) If native VLAN is changed something other than VLAN1, these protocols will then be tagged in that specific VLAN. 
-> CDP allows us to view directly connected devices. 
h) VLAN trunking protocol(VTP) is a way to dynamically update other switches with changes made on a single switch in VTP domain 
i) PAgP or Port aggregation protocol is a protocol used for automatic creation of Ether channels 
j) UDLD - Unidirectional link detection is used to monitor the physical configuration of cables between devices and detect unidirectional links. 
-> This helps us to detect incorrectly cabled links 
k) Important thing to note here: on trunk links there is a special VLAN known as the native VLAN where traffic is sent untagged. 
-> If left at the default value of VLAN1, a lot of management traffic will be sent across that native VLAN 
-> Native VLAN on both sides of the trunk should be the same. 
---> If they are not the same, switches will notify you by telling you that there is a native VLAn mismatch. 
l) Issue that will come, when native vlans are not the same is that traffic from one vlan on this switch will automatically be associated and end up in a different vlan on 
another switch 


96) VLAN types: 
-> Our ports are assigned to VLANs 
a) Static VLAN:
-> statically assigned by an administrator  where an administrator will go to an interface  and put that port into a VLAN 
b) Dynamic VLAN:
-> Using VMPS(VLAN membership policy server) dynamic vlan is assigned. 
-> Dynamic VLANs helps ports to be dynamically updated based on the mac address of device attached to that port. 
c) Voice VLAN:
-> Specifically for IP phones. 
-> VTP or VLAN trunking protocol is a CISCO propreitary layer 2 protocol which helps in propagation of VLAN information from one switch to another rather than telnetting to multiple switches 
-> Addition, deletion and renaming of VLANs 
-> Propagated across trunk links 
-> Uses mac addresses: 01-00-0C-CC-CC-CC, which is a well know multicast address for flooding of CDp and VTP protocols 
---> Three types of Messages in VTP: 
● Summary advertisements 
-> Sent every 5 min or when there is a change using well known multicast devices
-> Inform other switches of the current vtp domain and configuration revision number 
● Subset advertisements 
-> contains detailed information of changes made while summary advertisement is precise 
● Advertisement requests 

d) 3 modes in VTP:
Server : Create VLans/Modify Vlans /Delete vlans /sends and forwards advertisements/ saves vlan configuration
Client: cant create change or delete vlans 
		Sends and forwards advertisments 
		
e) VTP issue: 
-> Entire network brought down by introduction of single switch - side effect 

97) Switch Configuration
a) To check to which vlan is the switch associated, use the command: 
S2#show int fastEthernet 0/1 switchport

b) Since there is no port to negotiate with we can see the port is VLAN1: Access Mode VLAN: 1 (default)

#######
S2#show int fastEthernet 0/1 switchport
Name: Fa0/1
Switchport: Enabled
Administrative Mode: dynamic auto
Operational Mode: static access
Administrative Trunking Encapsulation: negotiated
Operational Trunking Encapsulation: native
Negotiation of Trunking: On
Access Mode VLAN: 1 (default)
Trunking Native Mode VLAN: 1 (default)
Voice VLAN: none
Administrative private-vlan host-association: none
Administrative private-vlan mapping: none
Administrative private-vlan trunk native VLAN: none
Administrative private-vlan trunk encapsulation: dot1q
Administrative private-vlan trunk normal VLANs: none
Administrative private-vlan trunk private VLANs: none
Operational private-vlan: none
Trunking VLANs Enabled: All
Pruning VLANs Enabled: 2-1001
Capture Mode Disabled
Capture VLANs Allowed: ALL
Protected: false
Unknown unicast blocked: disabled
Unknown multicast blocked: disabled
Appliance trust: none
######


c) To display vlans configured in switch:

########
S1#sh vlan

VLAN Name                             Status    Ports
---- -------------------------------- --------- -------------------------------
1    default                          active    Fa0/1, Fa0/2, Fa0/3, Fa0/4
                                                Fa0/5, Fa0/6, Fa0/7, Fa0/8
                                                Fa0/9, Fa0/10, Fa0/11, Fa0/12
                                                Fa0/13, Fa0/14, Fa0/15, Fa0/16
                                                Fa0/17, Fa0/18, Fa0/19, Fa0/20
                                                Fa0/21, Fa0/22, Fa0/23, Fa0/24
                                                Gig0/1, Gig0/2
1002 fddi-default                     active    
1003 token-ring-default               active    
1004 fddinet-default                  active    
1005 trnet-default                    active    

VLAN Type  SAID       MTU   Parent RingNo BridgeNo Stp  BrdgMode Trans1 Trans2
---- ----- ---------- ----- ------ ------ -------- ---- -------- ------ ------
1    enet  100001     1500  -      -      -        -    -        0      0
1002 fddi  101002     1500  -      -      -        -    -        0      0   
1003 tr    101003     1500  -      -      -        -    -        0      0   
1004 fdnet 101004     1500  -      -      -        ieee -        0      0   
1005 trnet 101005     1500  -      -      -        ibm  -        0      0   
#######


d) To create vlan: 

S1(config)#vlan 2
S1(config-vlan)#end
S1#

e) check and see newly created vlan:
-> But we can see no ports are configured in newly created vlan 

S1#show vlan brief

VLAN Name                             Status    Ports
---- -------------------------------- --------- -------------------------------
1    default                          active    Fa0/1, Fa0/2, Fa0/3, Fa0/4
                                                Fa0/5, Fa0/6, Fa0/7, Fa0/8
                                                Fa0/9, Fa0/10, Fa0/11, Fa0/12
                                                Fa0/13, Fa0/14, Fa0/15, Fa0/16
                                                Fa0/17, Fa0/18, Fa0/19, Fa0/20
                                                Fa0/21, Fa0/22, Fa0/23, Fa0/24
                                                Gig0/1, Gig0/2
2    VLAN0002                         active    
1002 fddi-default                     active    
1003 token-ring-default               active    
1004 fddinet-default                  active    
1005 trnet-default                    active    
S1#


f) show spanning-tree and spanning-tree summary 


S1#show spanning-tree 
VLAN0001
  Spanning tree enabled protocol ieee
  Root ID    Priority    32769
             Address     00E0.B0D3.D598
             This bridge is the root
             Hello Time  2 sec  Max Age 20 sec  Forward Delay 15 sec

  Bridge ID  Priority    32769  (priority 32768 sys-id-ext 1)
             Address     00E0.B0D3.D598
             Hello Time  2 sec  Max Age 20 sec  Forward Delay 15 sec
             Aging Time  20

Interface        Role Sts Cost      Prio.Nbr Type
---------------- ---- --- --------- -------- --------------------------------
Fa0/3            Desg FWD 19        128.3    P2p

VLAN0002
  Spanning tree enabled protocol ieee
  Root ID    Priority    32770
             Address     00E0.B0D3.D598
             This bridge is the root
             Hello Time  2 sec  Max Age 20 sec  Forward Delay 15 sec

  Bridge ID  Priority    32770  (priority 32768 sys-id-ext 2)
             Address     00E0.B0D3.D598
             Hello Time  2 sec  Max Age 20 sec  Forward Delay 15 sec
             Aging Time  20

Interface        Role Sts Cost      Prio.Nbr Type
---------------- ---- --- --------- -------- --------------------------------
Fa0/4            Desg FWD 19        128.4    P2p

S1#sh
S1#show sp
S1#show spanning-tree sum
S1#show spanning-tree summary 
Switch is in pvst mode
Root bridge for: default VLAN0002
Extended system ID           is enabled
Portfast Default             is disabled
PortFast BPDU Guard Default  is disabled
Portfast BPDU Filter Default is disabled
Loopguard Default            is disabled
EtherChannel misconfig guard is disabled
UplinkFast                   is disabled
BackboneFast                 is disabled
Configured Pathcost method used is short

Name                   Blocking Listening Learning Forwarding STP Active
---------------------- -------- --------- -------- ---------- ----------
VLAN0001                     0         0        0          1          1
VLAN0002                     0         0        0          1          1

---------------------- -------- --------- -------- ---------- ----------
2 vlans                      0         0        0          2          2

S1#


98) Access Port vs Trunk Port:
a) Access Port is a port that is assigned to a single VLAN 
b) whereas Trunk Port is a port in which it is assigned to multiple VLANs.

c) Trunk Port
-> A trunk port is a port, which is used to connect to another switch or router. 
-> It is a link that carries many signals simultaneously. 
-> Basically, it can transmit data from multiple VLANs. 
-> It uses tags in order to allow signals to get to the correct endpoint. 
-> Trunk Port offers higher bandwidth and lower latency. 
-> The Trunking takes place in layer 2 of the OSI model, which is known as the “data link layer”. 
-> The device uses the IEEE 802.1Q encapsulation or tagging method, in order to correctly deliver the traffic on a trunk port with several VLANs.

d) Advantages of trunk port: 
-> It offers higher bandwidth and lower latency.
-> It sends all signals across a single trunk link which is for each switch or router.
-> It can carry traffic for several VLANs simultaneously. 

e) Disadvantage of using trunk port 

It is quite complex to set up when compared with the Access port.

f) Access Port
-> The access port is a type of port that is like a type of connection on a switch that provides the virtual machines with connectivity via a switch or VLAN. 
-> Basically, it transmits data to and from a specific/single VLAN. 
-> This doesn’t cause signal issues because the frames remain within the same VLAN.  
-> For complex networks, it is not that efficient to work with. One can configure the port as a host port, to optimize the performance of the access port.

g) Advantages of using Access Port: 

-> It sends and receives frames that aren’t tagged.
-> There are no signal issues in the access port as the frame remains in a single VLAN.
-> To decrease the time it takes the designated port to begin to forward packets, use the host port.

Disadvantages

It can carry traffic for only one VLAN.
Only an end station can be set as a host port.

h) Difference between Trunk Port and Access Port:
https://www.geeksforgeeks.org/difference-between-trunk-port-and-access-port/


1) VLAN assignment:
Trunk Port:
It supports multiple VLANs.

Access Port:
It supports a single VLAN.

2) Tags
Trunk Port:
Multiple VLANs are allowed to traverse and add tags.


Access Port:
Single VLAN is allowed to traverse and removes tags.

3) Purpose:
Trunk Port:
It connects switches or routers together.


Access Port:
It connects end devices to the network.

4) Protocols:
Trunk Port:
It uses encapsulation protocol which are

ISL 
802.1Q

Access Port:
It uses only one encapsulation protocol-

IEEE 802.1Q.

5) Bandwidth:

Trunk Port:
In Trunk Port, bandwidth is high.


Access Port:
In Access Port, bandwidth is low as compared to Trunk Port.

6) VLAN tagging:

Trunk Port:
It supports VLAN tagging.


Access Port:
It does not support VLAN tagging.



98) DTP: Dynamic Trunking Protocol 
-> Many cisco switches support Dynamic trunking protocol 
a) DTP allows switchs to dynamically negotiate the forming of trunks 
b) DTP is a cisco propreitary protocol and hence other vendors dont support it. 
c) Lot of cisco switches has DTP enabled by default. 
-> i.e they can automatically negotiate trunking with neighbouring switches 
d) HOWEVER IT IS BEST PRACTICE TO DISABLE DTP AND USE MANUAL CONFIGURATION. 
e) Two cisco switches can dynamically negotiate to form a trunk using DTP and permit vlans acorss the trunk automatically 
f) it can also negotiate the protocol used such as ISL or 802.1Q
g) DTP supports two main modes, dynamic auto and dynamic desirable 
-> Dynamic desirable means that the switch initiates trunking with the remote end 
-> Auto means it does not initiate but will use trunking if the other side initiates. 


99) Spanning tree: 
a) Spanning tree was developed to stop layer 2 loops occuring in switched environments 
b) In transparent bridging or transparent switching , which ethernet uses - redundant links introduce loops 
-> Spanning tree is used to stop those loops. 
-> Spanning tree is present for many years and multiple developments and enhancements has been done 
-> Hence we will have a disadvantage: there are different implementations and versions of spanning tree. - Hence we need to know some of those differences 
c) Spanning tree is an important protocol in traditional networks whose primary purpose is to stop loops in a switched environment.  
d) Spanning tree originally developed for bridges rather than switches 
e) Slower convergence is an issue in voice over IP. hence 802.1D is superseded by newer versions such as rapid spanning tree and multiple spanning tree. 
f)  Since spanning tree is important for CCNA and real time deployments we will discuss with initial version of spanning tree and then look at more complex topologies 


100) Different Types of Spanning Tree: 
a) Original version of spanning tree is: IEEE802.1D spanning tree. 
-> This is the legacy standard of spanning tree which was used when bridges were around. 
-> It is basis for other versions of spanning tree. 
b) CST - Common spanning tree. 
-> CST assumes that there is one spanning tree instance for the entire bridged network, regardless of the number of VLANs 
-> Currently we dont use this 
c) We use a version of PER VLAN SPANNING TREE or PVST 
-> Originally PVST only supported ISL. 
d) PVST+ supports ISL and 802.1Q . In today's world we use PVST plus as PVST itself 
e)RSTP: Rapid spanning tree Multiple spanning tree has rapid spanning tree built into it because Rapid spanning tree or 802.1W improves convergence. 



11) Why is Spanning Tree required in a switched network:
a) 
TO explain that, lets consider a topology - where HOSTA is connected to switch1 which in turn is connected to switch2 and switch2 is conected to HOSTB 



HOSTA--------SWITCH1----SWITCH2---------------HOSTB

b) If a link goes down between SWITCH1 and SWITCH2, HOSTA would not be able to communicate with HOSTB and vice versa  
c) Hence we need to implement some redundancy between those two switches by adding an additional link 
-> However that introduces problems in a switched environment 
-> It is generally recommended in networks today to implement some type of redundancy
-> Here we have two links between the switches, but that will introduce additional problems 
d) Problem:
-> MAC address table in switch updated multiple times for the same device in different ports and host receives frames from devices multiple times 



101) BPDU and Bridge IDs: How do switches learn about each other? 

a) Bridge protocol data units or BPDUs are sent out of all ports on switches by default every two seconds when running spanning tree. 
-> Switches will learn about each other when they receive BPDUs from other switches on their ports 
b) As an example in this topology, switch one will know that there is a loop because they will know that it is receiving a BPDU from switch2 on port2 as well as port3 
c) So BPDUs from  a switch with same bridge ID are received on multiple ports and thus switch1 knows that there is  a loop between itself and switch2 
-> In same way, switch2 knows that there is a loop because it receives BPDUs from switch1 on both port1 and port3 

d) BPDU contains the following:
-> Bridge ID  : Bridge ID of the sending switch 
				8 byte value unique to the switch 
					2 byte priority field and 
					6 byte system id based on MAC address of switch 
-> BPDUs contain information about spanning tree.

e) Switches send BPDUs using their unqiue mac address to destination with multicast of MAC(1:80:C2:00:00:00 or 01:00:00:CC:CC:CC:DD  for vlan spanning tree 

f) 3 kinds of BPDUs 
-> Configuration BPDU - used by spanning tree to provide information to switches 
-> Topology change BPDU: To tell switches about a change 
-> Acknowledgement BPDU - Used to confirm the receipt of a topology change by notification 
				
				
102) Root Ports and Designated Ports : 
a) In this lesson, we will see why certian ports are set to forwarding and why certain ports are blocking 
-> As part of this, we will workthrough the spanning tree process 


RootPort----Lowest Path cost
                   |
				   |
			Lowest neighbour Bridge ID -----> If path cost equal 
				   |
				   |
			Lowest Port priority ------------> 128 by default 
				   |
				   |
		      Lowest Port ID
			  
			  
103) Extended Bridge ID and Portfast :
a) WHat is a PVST+ or Rapid PVST+ Extended Bridge ID?
-> Spanning tree requires that every switch have a unique bridge ID 
.....

104) Different versions of spanning tree:
a) STP 
b) PVST 
c) Rapod PVST 
d) MSTP 


105) BPDU guard 
a) One of the multiple security mechanisms available in spanning tree to proteect your spanning tree.
b) BPDU guard does the following : TO PROTECT YOUR SPANNING TREE NETWORK 
i) Disable a port and protect the spanning tree

c) Two ways to configure BPDU guard 
-> Per interface basis or 
-> Configure it globally on a switch on a per-port basis  


106) CDP - Cisco Discovery Protocol  or Industry version: Link Layer Discovery Protocol -LLDP
a) Runs on Layer2 in OSI model and allows you to discover how devices are connected to each other. 
-> This runs independently of protocol such as IPv4 and IPv6 
b) CDP and LLDP are great ways to discover how devices are connected and it allows you to verify documentation 
c) CDP is cisco propreitrary 
d) Can help hackers also to discover devices in network :) 
e) CDP does not rely on IP 