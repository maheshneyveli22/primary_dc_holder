1) Use of Providers. How to have one instance of a service throughout the app, how to have instance of a service in component level i.e override the service instance at component level
2) Hierarchial Injectors
3) use of @Injectable() decorator 
-> it is used at the place where you want to inject another service
-> eg: if accountservice uses logservice and we use @Injectable at accountservice 
-> if you dont expect logservice to inject any other service, we dont need add @Injectable at logservice 
-> nowadays in newer versions, they add injectable in all service classes 

4) how to do cross component communication using Services 

Without services - 
eg: if there are parent component AppAccount and two child components Account and newAccount and two services: accountservice and logservice
-> if you click something in Account component and if you want to output something in newAccount component based on the click in Account component
a) we would have to emit an event in account component that something was clicked or changed 
b) We have to catch the event in AppAccount 
c) Then we have to pass the newdata/event down via property binding to the newAccount component where we want to handle it 

With Services:
Eg: lets assume we have parent component AppAccount and two child components Account and newAccount. Lets assume we have accounts service, 
We want to provide some event, 
which we can trigger in one component and listen to in another component 
a) We can have statusUpdated EventEmitter declaration in accountservice
###
statusUpdated = new EventEmitter<string>(); 
###

b) In account component , through accountservice, i will emit the statusUpdated event 
###
eg: this.accountservice.statusUpdated.emit(status);
###
c) In newAccount i want to listen to that statusUpdated event via subscribe and i receive the new status which was emitted from account component ,then throw an alert :
###
eg: this.accountservice.statusUpdated.subscribe(
(status:string) => alert('New status received '+status)
###
---> Thus without any chain of property and event binding, we achieved cross component communication

5) Another way of injecting services:

-> Instead of adding a service class to the providers[]  array in AppModule , you can set the following config in @Injectable() :
#############
@Injectable({providedIn: 'root'})
export class MyService { ... }
This is exactly the same as:

export class MyService { ... }
and

import { MyService } from './path/to/my.service';
 
@NgModule({
    ...
    providers: [MyService]
})
export class AppModule { ... }
#############

-> Using this syntax is completely optional, the traditional syntax (using providers[] ) will also work.
-> The "new syntax" does offer one advantage though: Services can be loaded lazily by Angular (behind the scenes) and redundant code can be removed automatically. 
-> This can lead to a better performance and loading speed - though this really only kicks in for bigger services and apps in general.


##########ROUTE START###################
6) How will you add Routes?

a) Declare type routes as constant in AppModule of type: Routes[]
with i) Path ii) action/component attached to it 
b) Register the routes by adding Imports in module : RouterModule 

eg: RouterModule.forRoot(appRoutes) 
-> here appRoutes is the constant we declared earlier 
-> by registering, angular knows our routes 
c) Rendering the currently selected component in Route:
-> in html template, We should not render component via selector, instead
use a special directive: 
eg: <router-outlet> </router-outlet> 

<router-outlet> --> Router-outlet in Angular works as a placeholder 
which is used to load the different components dynamically based on the activated component or current route state

-> This place marks where the render the component for the 
currently selcted route

7) How to implement navigation?
-> In html template, use special directive : routerLink
-> routerLink helps go to that component, without reloading the page
-> routerLink path can be given relative("users") or absolute("/users")
eg:
<a [routerLink]="['/users'"> </a>  /users
<a [routerLink]="['/users',10, 'Anna']"> </a> /users/10/Anna

8) How to Style Active Router links?
-> To set the css class active dynamically:
-> we use a special directive in html: routerLinkActive 
eg: routerLinkActive="active" 
-> to avoid empty path segments marked active : we use 
routerLinkActiveOptions
eg: [routerLinkActiveOptions]="{exact: true}"

9) How to navigate programatically? 
-> after finishing some operation in .ts or after click if we want 
to add Routes: 
a) in ts file constructor, have router:Router
b) we can navigate by this :
this.router.navigate(['/servers']);
-> if we use relative path, you wont face error like RouterLink
-> This is because unlike RouterLink, navigate does not know
on which route you currently stay 
c) to tell navigate method where we are currently, we need
to have second parameter with ActivatedRoute
-> ActivatedRoute tells the currently active route 
relativeTo-> tells relative to which path we need to load this route. so that we can avoid giving full paths. 
-> it helps to load this route over the currently activated route 

eg: route:ActivatedRoute
this.router.navigate(['/servers'], 
{relativeTo: this.route});


10) how to pass parameters to Routes:
a) Change the route constant which we mentioned and registered in app.module.ts and specify parameter using: "users/:id/:name"
eg: 
const appRoutes: Routes =[
{path: 'users:/id/:name',component:UserComponent}]

11) How to access Router Parameters in the loaded component: 
a) We acces Router parameter, in the component's ts file 
b) We need to inject ActivatedRoute in the constructor, through which we get access to the currently loaded route 
eg:
constructor(private route: ActivatedRoute) {}
c) access the parameters using: snapshot
eg:
this.user= {
id: this.route.snapshot.params['id'],
name:this.route.snapshot.params['name']
}
d) output the same in html template;
eg:
<p> User with ID {{user.id}} loaded.</p>
<p> User name is {{user.name}} loaded.</p> 


12) How to Fetch Route Parameters Reactively
a) fine to use snapshot for the first initialization, but to react to subsequent changes:
b) in route object, there is params property - params is an observable, and we observe params by subscribing to it 
eg:
this.route.params.subscribe(
(params:Params) => {
this.user.id= params['id'];
this.user.name= params['name']; 


13) How to Pass query parameters and fragments 
a) Assume this is the route defined in html template:
<a [routerLink]="['/servers',5,'edit']"
b) we can bind queryParams, which is a property of routerLink directive 
eg:
<a [routerLink]="['/servers',5,'edit']"
[queryParams]="{allowEdit: '1'}"
c) how to add framgement:
eg:
<a [routerLink]="['/servers',5,'edit']"
[queryParams]="{allowEdit: '1'}"
fragment="loading" 

14) How to Pass query parameters and fragments, programatically 
a) In ts file method, add query params in router.navigate

eg:
onLoadServer(id:number)
{
this.router.navigate(['servers',id,'edit'],{queryParams: {allowEdit: '1'},
fragment:'loading' })
}

15) How to retrieve query parameters and fragments: 
a) inject activated route in ts file where you want to retrieve
TWO WAYS OF RETRIEVING:
b) using snapshot:
this.route.snapshot.queryParams
this.route.snapshot.fragment
-> this approach wont be reactive, ie it wont react to any change after the component has been loaded
c) other way is to use route and have queryParams as observable

this.route.queryParams.subscribe();
this.route.fragment.subscribe();


16) How to setup child Routes using Nested Routing 
a) Change the route constant in app.module.ts with children object specified:

eg:
consta appRoutes:Routes = [
{path: '',component: HomeComponent},
{path: 'users', component:UsersComponent},
{path: 'servers', component: ServersComponent, children:[
  {path: ':id', component: ServerComponent},
  {path: ':id/edit', component: EditServerComponent }
  ] }
  ];

b) <router-outlet> --> Router-outlet in Angular works as a placeholder 
which is used to load the different components dynamically based on the activated component or current route state

-> Router-outlet specified earlier can load routes and components specified at the top level
-> Hence child routes need a separate outlet  . 

c) So we need to go the template of parent route and add <router-outlet> there. 
d) This will help load all child routes of this parent route . in our case: servers is parent, ServerComponent,EditServerComponent are child routes 
e) by this all child routes wont be loaded as new page , and child components will be loaded in the side 


17) How to preserve queryParams upon navigation: 
-> To preserve queryParams we need to add another parameter in navigate method of router 

eg:
this.router.navigate(['edit'],{relativeTo: this.route, queryParamsHandling: 'preserve'}); )

18) How to Redirect for routes not specified, but entered in url?
a) we need to specify in routes constant 

eg:

{path: 'not-found', component: PageNotFoundComponent},
{path: 'something', redirectTo: '/not-found'}

b) but if we cant specify all the paths, which needs to be redirected, we can use wildcards for the same 

{path: 'not-found', component: PageNotFoundComponent},
{path: '**', redirectTo: '/not-found'}

c) Make sure that the generic route with **, is the last in the array of routes 


19) Redirection Path Matching:

....
By default, Angular matches paths by prefix. That means, that the following route will match both /recipes  and just / 

{ path: '', redirectTo: '/somewhere-else' } 

Actually, Angular will give you an error here, because that's a common gotcha: This route will now ALWAYS redirect you! Why?

Since the default matching strategy is "prefix" , Angular checks if the path you entered in the URL does start with the path specified in the route.
 Of course every path starts with ''  (Important: That's no whitespace, it's simply "nothing").

To fix this behavior, you need to change the matching strategy to "full" :

{ path: '', redirectTo: '/somewhere-else', pathMatch: 'full' } 

Now, you only get redirected, if the full path is ''  (so only if you got NO other content in your path in this example).

.....

#########Passing data through the route ###########
Angular allows us to pass data through the route. 
The route data can be either static or dynamic. 
The static data use the Angular route data property, where you can store arbitrary data associated with that specific route. 
To pass dynamic data (or an object), we can use the history state object. 
The Routed Component can then retrieve the dynamic data from the history state object.
#######

20) how will you outsource The route configuration?

-> Because routes declaration takes significant space in app.module.ts 
a) Create a new module  of name: app-routing.module.ts
b) Add all the route declaration from app.module.ts to app-routing.module.ts 
c) Remove the imports declaration : RouterModule.forRoot(appRoutes) in app.module.ts 
d) in app-routing.module.ts, add imports declaration:RouterModule.forRoot(appRoutes) in app.module.ts 
e) in app-routing.module.ts, add exports declaration , which means if i were to add this module to imports of some other module, what should be 
accessible to the module, which imports this module . Here we make RouterModule to be part of exports declaration
f) now in app.module.ts, add the app-routing.module.ts to the imports declaration 

-> thus we make a leaner app.module.ts, by outsourcing routes to app-routing.module.ts 

21) What are route guards: 
-> it is functionality or code that is executed, before a route is loaded or once you want to leave a route  

#########
CanActivate basically answers the question: “Does the user have access to this route?” 
We use this guard to prevent access to users who are not authorized to access a route.
##############

22) How to protect routes with canActivate guards? 
a) Create a new file: auth-guard.service.ts 
b) create class AuthGuard which implements CanActivate interface and override canActivate()
c) 
-> canActivate implementation
-> Angular supplies these arguments and executes canActivate before a route is loaded  
-> canActivate returns an Observable or Promise or only a boolean 
-> canActivate can run synchronously or asynchronously

  canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable<boolean> | Promise<boolean> | boolean
  {}
  
d) Have another service for auth: auth.service.ts (AuthService), which helps to login or out ,
have a promise and have content for canActivate method
c) Now go to routes specified in app.module.ts and specify the guard you want to execute:

eg:
const appRoutes:Routes = [
{path: '',component: HomeComponent},
{path: 'users', component:UsersComponent},
{path: 'servers', canActivate: [AuthGuard], component: ServersComponent, children:[
  {path: ':id', component: ServerComponent},
  {path: ':id/edit', component: EditServerComponent }
  ] }
  ];


23) How to protect child Routes with canActivateChild 
a) Create class which implements CanActivateChild interface 
b) Implement canActivateChild method 
c0 In route comment use canActivateChild 

eg:
const appRoutes:Routes = [
{path: '',component: HomeComponent},
{path: 'users', component:UsersComponent},
{path: 'servers', 
//canActivate: [AuthGuard], 
canActivateChild:[AuthGuard],
component: ServersComponent, children:[
  {path: ':id', component: ServerComponent},
  {path: ':id/edit', component: EditServerComponent }
  ] }
  ];
  
 
24) How to control navigation with canDeactivate 
UseCase: I edit a page and leave a page without editting , we can use canDeactivate guard 

-> This is controlling, whether we can leave a route or not 
a) Create a deactivate guard 
b) create an interface CanComponentDeactivate
c) Create a guard CanDeactivateGuard implementing CanDeactivate<CanComponentDeactivate> 
d) Implement canDeactivate() which will be called, when we try to leave the route 
e) in app routing mode, add canDeactivate guard for EditServerComponent and in app.module, add the CanDeactivateGuard guard in providers section
f) Implement CanComponentDeactivate in EditServerComponent and add canDeactivate() 

25) How to pass static data to a Route

a) while declaring routes using path, use the data property
eg:

const appRoutes: Routes =[
{path:'', not-found,component:ErrorPageComponent, data:{message: 'Page not found!'}},
{path:'**', not-found, redirectTo: '/not-found'}}

];

-> VIA SNAPSHOT 
eg: 
this.errorMessage= this.route.snapshot.data['message']

or 


b) via route, data
this.route.data.subscribe(
(data:Data) =>
{
this.errorMessage=data['message'];
}
);

26) How to resolve dynamic data with resolveGuard 
-> fetching dynamic data before a route can be displayed or rendered 
---> RESOLVER : helps to execute some code before a route is rendered 
-> RESOLVER  does not decide whether a component should be loaded or not , instead: RESOLVER will always render the component in the end 
-> But it does some preloading, ie it will fetch some data, which the component will need later on   
a) Create a resolver, which is a service class 
b) This Resovler class should implement Resolve Interface

eg: export class ServerResolver implements Resolve<id:number, name:string, status: string}>{
}
c) Implement resolve() in the ServerResolver

eg: resolve(route: ActivatedRouteSnapshot, state: RouterStateSnapshot){}
d) Add this resolver in app.module class as providers
e) in route definiition : add resolve: and mention the Resolver 
-> this data will be given by angular when the route is loaded 
-> name given in resolver declaration should match the property returned 


27) What are location strategies: 
-> URLs are always parsed by the server which hosts the application and not by angular  
a) Server hosting our angular single page application has to be configured such that, in case of a  404 error, it returns the index.html file  
-> index.html is the file which is at starting and containing our angular app 
b) so if we have url: localhost:4200/servers, it will look for /service route on the real server which is hosting our web app
c) Chances are we dont have the file in server, since we have only one file there : index.html which contains our entire angular application
d) if for some reason this does not work or if we need to support very old browsers which are not able to parse paths like this in the client, which angular does ,
then an alternative approach needs to be followed.
e) we can use # sign in routes 

HOW TO ENABLE # Sign in routes:
-> in app routing mode, where we register the forRoot, we can pass a second argument at java script object:
usHash:true -> will make hastags in url, by default, useHash value is false 

eg: 

imports:[
RouterModule.forRoot(appRoutes, {useHash:true } ) 
]

-> this is called hashModeRouting
This tells webserver to care only about part before the # and all parts thereafter will be ignored by webserver 
-> thus it runs even on servers, which dont return the index.html file 
-> part after the # tag can be parsed by Angular 



-> but this is not advisable solution , since it is not clean 


28) How to navigate to a new route and have the new route relative to the current route
a) Declare Router and ActivatedRoute in constructor

eg:
constructor(private recipeService: RecipeService, private router:Router, private route:ActivatedRoute) {
  }

b) Use router's navigate(0 and point relativeTo the current route

eg:
      this.router.navigate(['new', {relativeTo:this.route}]);
	  
##########ROUTE END###################

29) What is observable and observer:
-> Observable is rxjs object
---> Observable(Various Datasources : Events, HttpRequests, UserInput) 
-> We have observable and observer
-> Between observable and observer we have a stream or timeline
-> On this timeline, we have multiple events emitted by the observable 
-> Observable could be a button click, or a event that is triggered programatically or in http request when response returns response is emitted 
as data package or observable

OBSERVER: 
-> Observer is the code EG:  we write subscribe

THREE WAYS OF HANDLING DATA PACKAGES:
-> Handle Data
-> Handle Error 
-> Handle Completion of observable 

-> What should happen if a) New Data arrives b) If you receive error c) If observable eventually completes 
-> some observables never completes 
-> It is the place where we write our code. 

--->Observables are  Mostly used to handle aysnchronous tasks


30) How to install RxJs:

npm install --save rxjs@6 --loglevel verbose

and also install rxjs-compat

npm install --save rxjs-compat --loglevel verbose

---> ng serve in verbose

ng serve --verbose


31) How to build a custom observable :
a)In the component's ts file,  Import Observable from rxjs
b) in ngOnInit(), :

const CustomIntervalObservable = Observable.create(
let count=0;
observer => {
setInterval(()=> {
observer.next(count);
count++;
},1000);
});

-> here observer is the part, that is being informed of new data, about errors or about the observable being completed
-> Now in the custom observable, our job is to tell the observer about new data.  About the error or about the observable being completed. 
-> Here we are not the listeners and only the observer is the listener 
-> Custom Observable informs about new data, when observer listens to that data 
 
-> Observer's methods : next, error and complete 

c) subscribe to the custom observable we defined: 

customIntervalObservable.subscribe(
data=> {
console.log(data);
})


d) Then ensure that the subscription is unsubscribed in ngOnDestroy() 

32) What are operators in Observables:
-> If we have an observable and observer
-> Observer gets data from observable by listening to a subscription
-> Sometimes we dont want raw data, we might want to transform/filter data
-> We can do that transformation inside the subscription
or in the function you pass to your subscription
-> But there is more elegant way: 


##########
Observable--->Operators-->Subscription--->Observer

##########

SOLUTION:
-> We can use built in operators between Observable 
and subscription
-> What it means is, data reach the operators: which
do transformation of data
-> Then we can subscribe to the result of these operators


33) Give a practical example for operators: 

Before Operators:

-> Lets observable gives values of counts:1,2,3

this.firstObsSubscription= customIntervalObservable.
subscribe(data=>
{
console.log('Round:' +(data+1));
}, error=>
{
console.log(error);
}

-> returns output of round:1, round:2, round:3

-> here we transform count values of observable into round:1, round2
, round:3 in subscription


With Operators:
a) Operators can be used on any observable through
a pipe method of observable
b) Import map operator from rxjs/operators
c) using pipe method of observable, we can the map method 
-> map() takes the function as argument, here
data is the data which we got earlier in subscribe function
-> Or it is the current data emitted by observable
-> and there we can do transformation of data
-> now after transformation if we subscribe, we will get the changed data


eg:
customIntervalObservable.pipe(
map(data=>{
return 'Round:'+ (data+1);
})).subscribe(
data=> {
console.log(data);
})

-> Thus console.log -> returns output of round:1, round:2, round:3
-> pipe method handles any number of arguments and we 
can add any number of operators needed. 

complete list of operators: https://www.learnrxjs.io/learn-rxjs/operators


34) What is a subject:

Scenario:
If you click activate button in users component,
you want to print Activated in app component

Steps Using EventEmitter:
a) In UsersService, we will add property and declare that property
using EventEmitter
b) In user component, we will use that EventEmitter
by injecting UsersService in constructor
c) Add a method called onActivate(), where i will
call that service and emit the event:
eg: this.userService.activatedEmitter.emit(true);
d) Then wire users.component.html (click)="onActivate"
e) Then listen to that event in app component .
-> Inject UsersService in constructor of app component.

eg:

ngOnInit()
{
this.userService.activatedEmitter.subscribe(
didActivate=>
{
this.userActivated=didActivate}
)
}
f) Then in app component html, we can add if condition :

<p *ngIf="userActivated">Activated!</p> 


$$$$$$$$$$$$$$$$$

Observable<----Subscription---Observer
i) Observerables we can subscribe and are passive
ii) In observable, we always wrap a callback
or an event 

(next)---> Subject<----Subscription---Observer

SUBJECT:
iii) Subject is also an object, that we can 
subscribe
iv) But its more active, because you can actively
call next on it from outside. 
-> in observable also we called next,
but we called it from inside the observable during 
creation
v) Hence we can subject as Active, since it canActivate
be triggered from code. 

###
->We use subject which is active observable - 
when we want to use it as event Emitter
or when we actively looke for some clicks 
-> Passive event source like: HTTP Request or
DOM events -> We use normal observables
#####

$$$$$$$$$$$$


BETTER APPROACH USING subject: 
a) Subject is imported from rxjs
eg: import {Subject} from 'rsjs';
b) In UsersService, instead of EventEmitter declare a subject

eg: activatedEmitter= new Subject<boolean>();

c) In UserComponent, in onActivate(), instead of
calling emit, we can call next
-> This is because subject is a special kind of
observable

eg:

onActivate()
{
this.userService.activatedEmitter.next(true);
}

d) In App component we still call subscribe, because
subject is still an observable

ngOnInit()
{
this.userService.activatedEmitter.
subscribe(didActivate=> {
this.userActivated= didActivate;
}
}

e) Using subject is efficient behind the scenes
f) like own observables, we should unsubscribe subject subscription
g) Use subject only for cross component event emitters
h) Dont use Subjects instead of event emitter when using @Output
i) When using @Output, we can use EventEmitter



35) What is Template Driven approach and Reactive:

Template:
-> Angular infers the form object from DOM

Reactive:
-> Form is created programatically and syncrhonized with the DOM 

36) Template Driven approach:
-> In this approach, Angular creates the javascript object representing our form 


i) HOW WILL YOU REGISTER CONTROLS IN HTML IN TEMPLATE DRIVEN APPROACH: 
a) Ensure FormsModule is imported in app.module.ts 
b) Upon doing Import, angular will create a javascript representation of form, when it detects a html form. 
-> Thus form html element acts as selector for  creating form
-> Initial form will be empty, angular does not automatically detect inputs 
c) Hence we need to register controls manually for angular to detect and input in form
-> it can be done by specifying ngModel for that input:
-> Also we need to specify the name of that control 

eg:
<input type="text" id="username" class="form-control" ngModel name="username"> 

ii) HOW TO MAKE THE FORM SUBMITTABLE IN TEMPLATE DRIVEN APPROACH and send the form reference: 
a) Lets have a method onSubmit() which needs to be called when submit button is clicked 
b) Add ngSubmit in form element:

eg:
<form (ngSubmit)="onSubmit(formReference)" #formReference>

c) We can access the formReference through local reference in ts code using: HtmlFormElement 

eg: onSubmit(form:HtmlFormElement) 
{
}
d) To get access to the Form Element created by angular, we can use ngform

eg:
<form (ngSubmit)="onSubmit(formReference)" #formReference="ngForm">

In ts file: 
onSubmit(form:NgForm) 
{
}

###General @ViewChild######
-> @ViewChild can be used to get element or local reference directly from Typescript code.
-> We can pass local reference to method in ts and access the local reference in the ts
-> But if we want to access localReferece before we call method, @ViewChild decorator can be used to access it in ts file :

eg:
@ViewChild('serverContentInput',{static:true}) serverContentInput;

in method we can access like this:

serverContent: this.serverContentInput.nativeElement.value

---> THus we can access direct access to dom elements via @ViewChild
 


iii) HOW TO ACCESS angular FORM USING @ViewChild  in TEMPLATE DRIVEN APPROACH 
-> Declare @ViewChild of type NgForm and access it in the method 
eg:
@ViewChild('formReference',{static:true}) signUpForm: NgForm;

In ts file: 
onSubmit(form:NgForm) 
{
console.log(this.signUpForm);
}

iv) Validate Forms in TEMPLATE DRIVEN APPROACH:
-> Through valid in form level and form-control level 

v) How to USE FORM STATE IN TEMPLATE DRIVEN APPROACH:

-> Here we make use of the form control state(eg: f.valid) and disable the button
-> Thus we disable the button, if the form is not valid 
EG:
<button class="btn btn-primary" type="submit"
[disabled]="!f.valid">Submit</button> 


vi) HOW TO SET DEFAULT VALUES IN TEMPLATE DRIVEN APPROACH;
a) Use property binding using ngModel

<select id="secret" class="form-control"
[ngModel]="defaultQuestion" name="secret">
<option value"pet'> You first pet?</option>
<option value"teacher'> You first teacher?</option>

b) In ts file, set default value for the property:

eg:

defaultQuestion='pet';


vii) How to use ngModel with Two way binding in TEMPLATE-DRIVEN-APPROACH

a) Define two binding in html
eg:
<div class="form-group">
<textarea name ="questionAnswer" rows="3" [(ngModel)]="answer"> </textarea> </div>
<p> Your Reply: {{answer}}</p>


b) introduce the property in ts file:

eg:
answer='';

viii) How to GROUP FORM CONTROLS IN TEMPLATE-DRIVEN-APPROACH:
-> We can use ngModelGroup
-> we can also get access to javascript object: by using local reference and assigning it to ngModelGroup

eg:
<div id="user-data" ngModelGroup="userData" #userData="ngModelGroup">

<p *ngIf="!userData.valid && userData.touched"> User Data is invalid!</p>


36) How to set and patch values in TEMPLATE-DRIVEN-APPROACH:

a) If you can get the form data using @ViewChild, 

eg:
@ViewChild('formReference') signUpForm: NgForm;

b) using signUpForm reference, we can set the value:

eg:
this.signUpForm.setValue(
{
userData: {
username: suggestedName,
email: ''
},
secret: 'pet',
questionAnswer: '';
gener:'male'
})
c) The problem with this setting, is that it overrides the already
entered value in ui 

d) To overcome this problem of overriding, we can
use patchValue(), where we can override only specific values

eg:

this.signUpForm.form.patchValue(
{
userData: 
{
username: suggestedName; 
}
}
)

37) How to Reset forms in TEMPLATE-DRIVEN-APPROACH?
a) use reset() on form 
b) This method resets both form values and its
state

eg:
this.signUpForm.reset();


38) Creating form in REACTIVE-APPROACH programatically:
a) In ts file, define a FormGroup  element:

signUpForm:FormGroup

b) In app.module.ts import ReactiveFormsModule 
c) in ts file, ngOnit() initialize the form:

ngOnInit()
{
this.signUpForm= new FormGroup(
{
'username'= new FormControl(null),
'email': new FormControl(null),
'gender': new FormControl('male')
});
}


39) How to Sync HTML and Form:
-> We need to syncrhonize html inputs in template
with the form we created in ts programatically
a) in html file, use the formGroup directive
 in form element 
 -> this tells angular to use my form and not create
 form for me from the page 
 -> via property binding we will be passing our 
 form, to the directive 
-> Thus form in html is syncrhonized with form in ts file


eg:

<form [formGroup]="signUpForm">
<div class="form-group">
<label for="username">Username<label>

b) But still we need to tell which control in ts, connects to which
input in ts file 
-> For this we use the formControlName directive 
-> Here in: formControlName="username", 
username corresponds to control we defined in ts
file 

eg:
<input type="text" id="username" 
formControlName="username" class="form-control">

-> To use the same via property binding:
eg:
<input type="text" id="username" 
[formControlName]="'username'" 
class="form-control">

40) How to submit forms in REACTIVE-APPROACH?

In TD approach:
<form (ngSubmit)="onSubmit(formReference)" 
#formReference="ngForm">

In Reactive approach:
a) Have signUpForm assigned to [formGroup]
-> Have ngSubmit called to any method you 
like to be called 
<form [formGroup]="signUpForm"
(ngSubmit)="onSubmit()" 
>
b) The difference from TD approach is 
that we dont need to get the form via Local Reference
-> Because we already have the formReference, since
we have crated the form programatically
c) We can get access to the form like this:

eg:
onSubmit()
{
console.log(this.signUpForm);
}

-> The form has Value: Object, which represents
the key value pair javascript object
 which we defined in the ts file 

41) How to add validation in REACTIVE-APPROACH?
a) We can specify validators while defining FormGroup with FormControl
---->Single Validator 'username'= new FormControl(null, Validators.required)
----> Multiple Validators: 'email': new FormControl(null, [Validators.required, Validators.email]),

eg:
ngOnInit()
{
this.signUpForm= new FormGroup(
{
'username'= new FormControl(null, Validators.required),
'email': new FormControl(null, [Validators.required, Validators.email]),
'gender': new FormControl('male')
});
}

42) How to get access to controls in REACTIVE-APPROACH

a) Access the overall form and use the get() method

eg:

<input type="text" id="username"
formControlName="username" class="form-control">
<span 
*ngIf="signUpForm.get('username').valid" 
class= "help-block"> Please enter a valid 
username!</span> 

43) What is difference between [formGroup],
formControlName and forGroupName
a) [formGrup] -> To synchronize
form defined in ts to form in html
b) formControlName to match property in
form defined in ts to an input in html
c) formGroupName to match formGroup defined
in ts file to a formGroup in html 

44) What is FormArray and how to create it
-> To make user to dynamically add 
formcontrols :
a) Here let me want user to add hobbies
eg:
<div> 
<h4> Your hobbies <h4> 
<button class="btn btn-default" 
type="button">Add Hobby</button>
<div> 

-> When user clicks the button, i want to
dynamically add a control to my form 
-> Specifically i want to add this control
to an array of controls because i may have
multiple hobbies 
 so adding click listener
 
 eg:
<div> 
<h4> Your hobbies <h4> 
<button class="btn btn-default" 
type="button"
(click)="onAddHobby()">Add Hobby</button>
<div> 
 
b) in my ts file , signUpForm 
declaration, add a new FormArray variable


eg:
'hobbies': new FormArray(
[]
)

c) When we click on new hobby, i want to 
add new hobby to that FormArray and 
type cast the same 

onAddHobby()
{
const control= new FormControl(null,
Validators.required);
(<FormArray>this.signUpForm.get('hobbies'))
.push(control)
}

d) Now we created new FormControl to FormArray,
but we wont be seeing it.
-> We need to syncrhonize it will the html
-> It can be done by defining formArrayName in outer div

eg:
<div formArrayName="hobbies"> 
<h4> Your hobbies <h4> 
<button class="btn btn-default" 
type="button"
(click)="onAddHobby()">Add Hobby</button>
<div> 

<div class="form-group"
*ngFor="let hobbyControl of
signUpForm.get('hobbies').controls; 
let i=index">
<input type="text" class="form-control"
[formControlName]="i">

</div>

45) How to create your own Validators :
a) A validator in the end is just a 
function which gets executed by angular automatically
when it checks the validity of formControl 
and it also checks the validtity when you
change the control 
b) lets define a function:

forbiddenNames(control: FormControl):
{[s:string]:boolean} 
{
if(this.forbiddenUserNames.indexOf(control.value)
{
return {'nameIsForForbidden':true};
}
return null;
}
}

c) In above method we should not pass(return {'nameIsForForbidden':false};) : return
object with false, we can omit return statement or 
return null 
d) Add it to validators array in FormControl
eg:
'username': new FormControl(
null, [Validators.required, this.forbiddenNames.bind(this)]),
)

e) Here this.forbiddenNames, declared in validator array
 of form control is the method we declared earlier 
 
 46) How to user Error codes in REACTIVE-APPROACH
 
 a) To get error codes in html:
 
 <span *ngIf="!signUpForm.get('userData.username').
 errors['nameIsForForbidden']">This name
is invalid  </span> 


47) How to create custom Async validator
-> A Validator that waits to see if the 
reponse is coming and then checks if 
it is valid or not 
a) To create asysnchronous validators, create
a method in ts file like synchronous validators
b) The difference here is while return we dont return
Error code or boolean, instead we return a Promise or Observable 

eg:
forbiddenEmails(control:FormControl):
Promise<any> | Observable<any>
{
const promise= new Promise<ay>(
(resolve,reject)=> {
setTimeout(()=> {
if(control.value === 'test@test.com')
{
resolve({'emailIsForbidden':true})
}
else{
resolve(null) 
}
},1500);
}
});
return promise; 
}

c) in FormControl, we separately add async validators
eg:

'username': new FormControl(
null, [Validators.required, this.forbiddenNames.bind(this)], 
this.forbiddenEmails),
)


48) How does validators change state:

Normal Validators:
ng-valid to ng-invalid

Async Validators:
ng-valid to ng-pending to ng-invalid 


49) How to react to status or value changes in
REACTIVE-APPROACH?

a) In signUpForm we defined in ts, where we defined all FormControl,
there are two observables which we can listen to
i) statusChanges
ii) valueChanges 

b) valueChanges gets triggered for every change in
formcontrol value 
eg:
this.signUpForm.valueChanges.subscribe
(
(value) => console.log(value) ;
)

c) statusChanges: status changes gets triggered
for every change instatus in form: eg: ng-valid, ng-pending,ng-invalid  

eg:
this.signUpForm.statusChanges.subscribe
(
(status) => console.log(status) ;
)

50) How to Set and Patch values in REACTIVE-APPROACH

a) Using setValue to set entire object
eg:
this.signUpForm.setValue(
{
'userData': {
'username': 'Max',
'email': 'max@test.com'
}
'gender': 'male',
'hobbies': []

});
}
)

b) Using Patch Value to update only certain
values in object:

 this.signUpForm.patchValue(
 {
 'userData': {
'username': 'Mahesh',
'email': 'Mahesh@test.com'
}
 }
 
 )
 
51) How to resetForm in reactive approach:

eg:

this.signUpForm.reset();

52) How to clear all items in FormArray in reactive approach?
-> As of Angular 8+, there's a new way of clearing all items in a FormArray.

->(<FormArray>this.recipeForm.get('ingredients')).clear();
The clear() method automatically loops through all registered FormControls (or FormGroups) in the FormArray and removes them.




53) What are pipes in Angular?
-> Pipes are used to transform output in html template file without changing the actual value of the property

54) How to use pipes in Angular?
-> in html template file we should use pipes:

eg: {{server.instanceType | upperCase}}

55) How to parameterize pipes 
a) Here date is the pipe and 'fullDate' is the parameter for the pipe
b) We pass parameter by having a colon: 

eg:
{{server.started | datae:'fullDate'}}


56) Where can we find piples documentation:

https://angular.io/api/common#pipes

57) How to chain multiple pipes?
a) We can chain multiple pipes by having | symbol
b) Eg:

{{server.started | date:'fullDate' | uppercase }}
c) Order of pipes is important. sometimes it maynot work if the order is wrong


58) How to create a customized pipe?

a) Create a file: shorten.pipe.ts
b) Implement interface: PipeTransform and override transform(Value: any) 

eg:
transform(value: any)
{
return value.substr(0,10);
}

c) To use this pipe, add the piple to declrations in app.module.ts

eg: 
declarations:
[AppComponent,
ShortenPiple]

d) Add @Pipe decorator in shorten.pipe.ts file

eg:
@Pipe({
name: 'shorten'
})

e) Use the same in html file:

eg:
{{server.name | shorten }}

59) How to Parameterize a custom pipe:
a) In transform() method, add second argument

eg:
transform(value: any, limit:number)
{
return value.substr(0, limit);
}

b) use with additional param in html file 
eg:
{{server.name | shorten:5 }}

59) Change of data and Change of parameter
a) Change of parameter will re-run the pipe
b) But change of data does not re-run the pipe 

-> Hence no built in filter pipe exist in angular 

-> We can pipe to re-run or recalculate data, whenever there is data change - but that will cause performance issues 

60) What is the use of pure in pipes
-> To make pipe recalculated whenever data changes, mark pure to be false , by default this is true 
-> this pipe is also called impure pipe 

eg:
@Pipe(
{
name: 'filter',
pure: false
}
)


61) What is 'async' pipe?
a) async pipe is used to handle asysnchronous data
b) async pipe recognises, that it has a promise or observable to which it subscribes automatically
c) After some time, if it recognises something has changed or if the promise has resolved or in case of observable, data was sent through the subscription,  
then it will print the data to the screen. 


62) How to send HTTP POST request in angular?

a) In app.module.ts add new module in imports: HttpClientModule
-> Using HttpClientModule, we can send HttpRequests 

eg:
  imports: [BrowserModule, FormsModule, HttpClientModule],
  
b) Inject the HttpClient in the component's ts file where you want to send the Http request:

eg: constructor(private http:HttpClient) {}

c) Now using the HttpClient object we send http requests
-> HttpClient's post method is used to send http requests
-> post() method takes couple of arguments 

Ist argument: url to which we want to send this request : ttps://reqres.in/api/users
IInd argument: data for the post request 

eg:
    this.http
      .post(
    'https://reqres.in/api/users',
     {
      "name": "morpheus",
      "job": "leader"
  } 
  
d) Using the above code we dont see any request being sent 
-> The reason behind is : HttpRequests are managed via observables 
-> Angular does not send the HTTP request, if you are not subscribed to the  http request
-> thus post returns an observable, which wraps our request 
-> We can get the responseData in the subscribe method. responseData contains the responsebody 
-> Here we need not unsubscribe the subscription, since it is done by Angular

eg:
 this.http
      .post(
    'https://reqres.in/api/users',
     {
      "name": "morpheus",
      "job": "leader"
  } 


      )
      .subscribe(responseData => {
        console.log("Mahesh is printing response")
        console.log(responseData);
      });


###########
->Request as seen from inspection tools:
{
  "name": "morpheus",
  "job": "leader"
}
-> Response as seen from inspection tools:
{
    "name": "morpheus",
    "job": "leader",
    "id": "766",
    "createdAt": "2023-11-28T06:46:38.209Z"
}
###########

63) How to send HTTP get request in angular 
a) get requests needs only argument. i.e the url 

eg:
 fetchPosts()
  {
    // Send Http request
    this.http.get('https://reqres.in/api/users')
    .subscribe(posts=> {
      console.log(posts);
    });
  }
  
 
64) How will you use RxJs operators to transform http response data: 
-> use pipe and map operator

65) How to use types with HttpClient
-> by specifying types in http get:

eg:
this.http.get<{[key:string]:Post}>('https://reqres.in/api/users')
.pipe(map(responseData => {
const postsArray: Post[]=[];
for(const key in responseData)
{
if(responseData.hasOwnProperty(key))
{
postsArray.push({...responseData[key], id:key});
}
}
return postsArray;
})
}
}

eg2:
this.http.post<name:String}>
{
'url',postData
}

66) How to output the fetched data from Http request? 
a) whatever data we go in subscribe, we can set it to a property 
b) Then use that property in html file to output the fetched data 

67) How to show a loading indicator 
a) define isLoading boolean property in component's ts file 
b) While starting to fetchPosts, make isLoading to true where it is starting
c) In subscribe method , once the data has arrived, we can mark isLoading back to false 
d) In html, We can use the same variable: isLoading to wait if isLoading is true 
e) We can use the same variable to load css spinner  for loading 

68) How to use Service while sending Http Requests? 
a) While sending http request, we use pipe and map to transform data
b) It is always good to have code for transforming data, into services file 
c) Create PostsService using @Injectable , also have HttpClient injected through constructor
d) Add new method createAndStorePost(title:String, content:string)  and within that method we can send httprequest for post


eg: 
createAndStorePost(title:string, content:string)
{
this.http.post<{name:string}>
{
'https://ng-complete-guide/posts.json',postData).subscribe(responseData => {
console.log(responseData);
}
);
}
}


e) -> Also have fetchPosts(), to send get request 
f) In appComponent, inject PostService through constructor and in onCreatePost,

eg:
onCreatePost(postData:Post)
{
this.postService.createAndStorePost(); 
}
---> While following these steps, connection will be lost between data fetched in service and data fetched in template 

69) what to do when connection is lost between data fetched in service and in Template###
Two ways to fix:
WAY 1:
-> Use a subject in post service, where we next our posts whe we got them and 
-> we subscribe to that subject in the app component 
---> we can use this approach if there are multiple components interested in the posts 
WAY 2: Suited
a)  Simply return the results of our get() method , which is an observable 
b) Hence we should not subscribe in the place where return the get 
c) Instead we return only the prepared observable in fetch posts
d) Hence while returning no http request gets sent 
---> THUS BELOW CODE FOR GET IS DONE IN SERVICE AND subscribe WILL BE DONE IN COMPONENT 
eg:

fetchPosts()
{
return this.http.get<{key:string):Post}>('https://ng-complete-guide/posts.json')
.pipe(map(responseData => {
const postsArray: Post[]=[];
for(const key in responseData)
{
if (responseData.hasOwnProperty(key)) {
postsArray.push({...responseData[key], id:key});
}
{
return postsArray;
}));
}

e) Requests are sent only when someone is interested, i.e only when it is subscribed 
-> SO we subscribe in the COMPONENT 
-> We do the subscribe in app component ;
-> We add this code in ngOnit and also in OnFetchPosts() of the component

eg:

ngOnInit()
{
this.isFetching=true; 
this.postsService.fetchPosts().subscribe(
posts=> {
this.isFetching=false;
this.loadedPosts=posts; 
});
}
}

f) Thus we moved RESULT HANDLING(i.e setting of data from subscription, so that template could use) into the component, 
but sending of the request and transformation of the data LIVES IN SERVICE 

70) When can we put subscribe code in service itself? 
If Component does not care about response, and whether the request is done or not, then we can do subscribe in the service itself 
-> But if component wants response or the response status, then we need to have service component split 

71) How to send a delete request? 

-> in service:PostService

eg:
deletePosts()
{
return this.http.delete('https://ng-complete-guide/posts');
}

-> in app component to be informed about the deletion, we will subscribe

eg: 
onClearPosts()
{
this.postsService.deletePosts().subscribe(
()=> 
{
this.loadedPosts=[];
}
);
}
 
 
72) How to Handle errors in angular while sending HTTP requests? METHOD 1: Using subscribe's second argument 
 
A) So far we passed only one argument to subscribe() : The first argument is a function which fires when new data is emitted 
B) Second argument is also a function, that triggers whenever an error is thrown. 
-> Here we can do something to handle that error 


c) Introduce new property error=null in the component.ts file  
d) in template file displayed based on error property, we show error message

eg:
<p ngIf="isFetching">Loading...</p>
,div class="alert alert-danger">
<h1> An Error *ngIf="error" </h1> 
<p> {{Error}</p>

e) Set the error mange to error ;

 eg: 
onFetchPosts(){

this.isFetching=true;
this.postsService.fetchPosts().subscribe(
posts => {
this.isFetching=false;
this.loadedPosts=posts;
}, error => {
this.error=error.message[

});

}

72) How to Handle errors in angular while sending HTTP requests? METHOD 2: Using Subjects for Error Handling 

-> Method 2: Could be useful when we send a request and dont subscribe it in your component 
 

----> We can use subject, if there are multiple places in application that are interested in our error 
a) have a new property error in PostsService which is of type Subject

eg:
error= new Subject<string>();

b) In service where we subscribe, we can call next and pass the error message 

eg:

subscribe(responseData => 
{
console.log(responseData);
}, error => 
{
this.error.next(error.message});
}
}

c) Next step is to subscribe that subject in all the places where we are interested in that error message

eg) in app.component.ts, we can subscribe to that error message 

-> this.postsService.error.subscribe(errorMessage =>
{
this.error = errorMessage;
}

73) How to use catchError operator to handle errors? 
-> In PostService,for post where we do a get and then piple/map data , we can add catchError operator 
and get the error message and do some generic error handling task like, sending to analytics 
-> We need to use another observable, throwError along with catchError
-> catchError is used, when we have some generic error handling task, that needs to be executed 

eg:
catchError(errorRes =>
{
//send to analytics server 
return throwError(errorRes);
}


73) Until now we saw how to handle http requests, handle errors and how we work with data we get back if no errors etc. 

74) How to set headers while sending HTTP requests? 
-> Headers like : Authorization header, content type, custom header 

a) Set HttpHeaders variable, using HttpHeaders
-> Multiple Headers can be defined in headers property 

eg:
fetchPosts()
{
return this.http.get<{key:string):Post}>('https://ng-complete-guide/posts.json',
..................
{
headers: new HttpHeaders({'Custom-Header': 'Hello'})
}
................
)
.pipe(map(responseData => {
const postsArray: Post[]=[];
for(const key in responseData)
{
if (responseData.hasOwnProperty(key)) {
postsArray.push({...responseData[key], id:key});
}
{
return postsArray;
}));
}

75) How to add queryparams in http request? 

-> we can params in same config object where we added headers
-> We can set params using: HttpParams
a)  we could have set params at the end of url too  for get 

{
headers: new HttpHeaders({'Custom-Header': 'Hello'}),
params: new HttpParams().set('print','pretty')

}


b) We can set multiple params by defining a constant and appending:
-> Since searchParams which is instance of HttpParams is immutable object , we need to reassign searchParams after appending 


eg:

let searchParams= new HttpParams();
searchParams=searchParams.append('print','pretty'); 
searchParams=searchParams.append('custom','key'); 

{
headers: new HttpHeaders({'Custom-Header': 'Hello'}),
params: searchParams
}

76) Observing different types of responses 
->So far we are interested only in responseData
---> for eg: In pipe/map we get the responseData ,then we return the data in subscription,  map it to component property and display it in template 
---> SOmetimes we need access to entire responseObject and not just to the extracted body data. 
--> Eg we want status code, response headers etc 


a) To get entire responseObject

a) 
-> body means only the responseData
eg:
observe:'body' 
-> to get full responseObject, use response
eg:
observe:'response' 
-> to get responseData from  responseObject,  we can access like this: responseData.body 



createAndStorePost(title:string, content:string)
{
this.http.post<{name:string}>
{
'https://ng-complete-guide/posts.json',postData).subscribe(responseData => {
console.log(responseData),postData, 
{
observe:'response'
}
}
.subscribe(
reponseData => 
{
console.log(responseData);
}
);
}
}

b) We can also observe events and we can use 'tap' operator.

-> tap operator helps to execute some code without altering the response 

eg: Observe:'events' 
-> Event type can be Sent, Response etc 

eg:
deletePosts()
{
return this.http.delete('https://ng-complete/posts.json', {
observe:'events'
})
.pipe(
tap(event => {
console.log(event);
})
);

}

77) How to change ResponseBodyType in http response 
-> By default response type of body is json

eg: responseType: 'json' 

eg:
eg:
deletePosts()
{
return this.http.delete('https://ng-complete/posts.json', {
observe:'events'
responseType: 'text'
})
.pipe(
tap(event => {
console.log(event);
})
);

}

78) What are Interceptors?

-> Suppose if we want to attach the custom header to all outgoing HttpRequests 

eg:usecase
I want to authenticate the user and you need a certain param 

STEPS:
a) Create a new interceptor : AuthInterceptorService  which implements HttpInterceptor

eg:
export class AuthInterceptorService implements HttpInterceptor

b) In this class, we need to implement intercept method which gets two arguments of types:HttpRequest<any>
-> intercept() forwards the request . 
-> Interceptor runs the code before the request is sent
 and right before the response is forwarded to subscribe
-> Here next of type: HttpHandler is the function which we needed to call, to le the request continue its journey 
-> we should return  handle() of next to let the request continue its journey

eg:
intercept(req: HttpRequest<any>, next: HttpHandler)
{
console.log('request is on its way');
return next.handle(req);
}

c) in app.module-> providers array , we should give three keys:
i) provide:HTTP_INTERCEPTORS 

HTTP_INTERCEPTORS -> is the token by which angular identifies that all classes given with the token are identified as HTTP Interceptors 

ii) useClass: AuthInterceptorService
-> we can specify the class that is specified as AuthInterceptorService

iii) multi:true
-> we can ensure multiple interceptors are called 

eg:

providers:
[
{
provide: HTTP_INTERCEPTORS,
useClass: AuthInterceptorService,
multi: true
} 
]

d) if you want to restrict this interceptor for a particular url, you can do this by having a check in intercept() using the req:HttpRequst<any> object

eg: if(req.url) 

79) How to modify request in Interceptors 
-> We can modify request in Interceptors. 
-> Since request object is immutable, we need to create a new object and assign to it

eg: 
 const modifiedRequest = req.clone({url:'newUrl'});
 
 -> in intercept(), we dont return the original request, instead we return the modifiedRequest:
 
 eg: return next.handle(modifiedRequest);
 
80) How to use Response Interceptors?
-> To use Response interceptors while returning in next.handle , in pipe->tap we can do something with the response 
-> in below code we can see request is being intercepted, request is modified and then response is intercepted 


eg:
intercept(req: HttpRequest<any>, next: HttpHandler)
{
console.log('request is on its way');
console.log(req.url);
const modifiedRequest = req.clone(
{
headers: req.headers.append('auth','xyz')
}
);
return next.handle(modifiedRequest).pipe(
tap(event => {
console.log(event);
if(event.type == HttpEventType.Response)
{
console.log('Response arrived, body data:");
console.log(event.body);
}
}
}




81) What is the difference between map and tap:

The purpose of tap is to execute an action keeping the same value of the observable

The purpose of map is to transform the emitted values of the observable


82) How to handle multiple interceptors in HTTP Request/Response 

a) In addition AuthInterceptorService, add another interceptor class: LoggingInterceptorService which impements HttpInterceptor

b) Next in app.module.ts , the order in which we specify them in provider, is the order in which the interceptors get executed.

-> Here AuthInterceptorService will run first and then the LoggingInterceptorService 


eg:


providers:
[
{
provide: HTTP_INTERCEPTORS,
useClass: AuthInterceptorService,
multi: true
} ,

{
provide: HTTP_INTERCEPTORS,
useClass: LoggingInterceptorService,
multi: true
}
]


83) How to add authentication to your angular app

a) Create Auth page, where user will be able to signup and sign in 
b) Add support to switch between Auth modes 
c) Handling form input 
-> for username and password 

84) Authentication - Preparing the sign up request 


->  from ui html, we call onSignUp in component-> signUp of Service  which inturn makes a post call for sign up with url 

a) Create a new service file: auth.service.ts
-> this service will be responsible for signup, sign in and managing token of user 
-> mark with with @Injectable and providedIn as root

eg:
@Injectable({providedIn:'root'})
export class AuthService{

b) Create constructor with HttpClient injected 
c) In service class create signUP which sends a http post request 
-> list of firebase rest api: https://firebase.google.com/docs/reference/rest/auth
-> get the url for sign up with email/password: https://identitytoolkit.googleapis.com/v1/accounts:signUp?key=[API_KEY]
-> since this is post request, send post with url and firebase web key and with data options as javascript object 

-> In service, we will be returning this prepared Observable and subscribing the data in the component 

eg:
signup(email:string, password: string )
{
  return  this.http.
    post('https://identitytoolkit.googleapis.com/v1/accounts:signUp?key=AIzaSyAETvw1FH6Vc5aR8gRIAwIA7iofso0xkmY',
    {
       email:email,
       password: password,
       returnSecureToken:true
    } );

}

d) In order to hold the object to be returned from the request, we need to define a model interface in the service 

eg:
interface AuthResponseData{
kind:string;
idToken:string;
email: string;
refreshToken: string;
expiresIn:string; 
localId: string; 
}

e) We can put the same in return response through generics

eg: 

return  this.http.
    post<AuthResponseData>('https://identitytoolkit.googleapis.com/v1/accounts:signUp?key=AIzaSyAETvw1FH6Vc5aR8gRIAwIA7iofso0xkmY',
    {
	..
	}
	

85) Authentication - Sending request from Auth Component: 
-> as part of this section, we will fire request from auth component and handle potential errors and handle loading state

a) In auth.component.ts,onSubmit() extract values from ui and call the signUp of authService:

eg:
   const email = form.value.email;
    const password = form.value.password; 
b) We should subscribe to return value of the signup request which we made in authService   

eg:
  onSubmit(form: NgForm) {
   if(!form.valid)
   {
    return ; 
   }
   const email = form.value.email;
   const password = form.value.password;

   if(this.isLoginMode)
   {

   }
   else{
    this.authService.signup(email,password)
    .subscribe(resData => {
      console.log(resData);
    },error => {
      console.log(error);
    }); 
   }

    form.reset();
  }
  
c) Now if we go to ui and give values for email and pwd, we can do sign up and we can see the following in console output as response: 

eg:
{
    "kind": "identitytoolkit#SignupNewUserResponse",
    "idToken": "eyJhbGciOiJSUzI1NiIsImtpZCI6IjBiYmQyOTllODU2MmU3MmYyZThkN2YwMTliYTdiZjAxMWFlZjU1Y2EiLCJ0eXAiOiJKV1QifQ.eyJpc3MiOiJodHRwczovL3NlY3VyZXRva2VuLmdvb2dsZS5jb20vdGVzdG1haGVwcm9qZWN0MiIsImF1ZCI6InRlc3RtYWhlcHJvamVjdDIiLCJhdXRoX3RpbWUiOjE3MDE0MTM0MjQsInVzZXJfaWQiOiJpb2lPZjdGRXppWEtEbDlralpubk5BWEJLSkQyIiwic3ViIjoiaW9pT2Y3RkV6aVhLRGw5a2pabm5OQVhCS0pEMiIsImlhdCI6MTcwMTQxMzQyNCwiZXhwIjoxNzAxNDE3MDI0LCJlbWFpbCI6Im1haGVzd2FyYW4uZWx1bWFsYWlAZXhwZWRpdG9ycy5jb20iLCJlbWFpbF92ZXJpZmllZCI6ZmFsc2UsImZpcmViYXNlIjp7ImlkZW50aXRpZXMiOnsiZW1haWwiOlsibWFoZXN3YXJhbi5lbHVtYWxhaUBleHBlZGl0b3JzLmNvbSJdfSwic2lnbl9pbl9wcm92aWRlciI6InBhc3N3b3JkIn19.YbV9Hm0PAdG2fXQXXkBJBZntFQtuKvZflo9VGz78eooVb_vhmxh2P5SgabKtOvaX8WN3nwws4GzrDnS57V18zXECLKHEtNRKeo5QbE7e-qpOoXRaW6IlCVai1e76D_B9_wwOWJNxR_dLB-TbsyTkyXuk67zHH5cjgIC2Wa2Ot64Mbbtlfmo5hHKvdwVbWbO7pr5dxSCVffuSMCI3opCxDhrEMzTOOWlL-apTZZEHo3pRgPs5bZ371ShLVgmW4_Olb_5iy7TwqrKIy7aks8jJgnDXXnfB4DJ6kadul07DjCWxH1nsvShTytGG55GFglMirfReI1mBC5-gAaO2tKRI0A",
    "email": "maheswaran.elumalai@expeditors.com",
    "refreshToken": "AMf-vByftnkW9MqcInjARBk_uaJvpaKjQN-jvOd-RuBUt4XZ8zLnzkgTkQOYFl74romYHQ7N1yuqIy9Xo-qZB_G5JKPJdOzIE0tIpGmuX7pyZHGLeZ7VBDMN6hZmdHk4g8F7s5-ms7H8dGM5kinxcwNi3qlJkbZ3uX6l6Zw_Hd5AqIHiNoYhgoKImbv9uxx3QyuSumm6mStnDOYTY50IydXf2ZoxAuZuBCjFYV4J_6oHtcAxmaeZ7RA",
    "expiresIn": "3600",
    "localId": "ioiOf7FEziXKDl9kjZnnNAXBKJD2"
}

d) Also if we go to firebase Authentication screen, we can see the new user mail id, getting added with user uid


86) How to add a Loading spinner while doing sign up http request

a) 
-> To get css for loading spinner,search for 'css loading spinner' in google search and load the below url: 
https://loading.io/css/
-> Copy code of one of the spinner 
-> Create two files: loading-spinner.component.ts and loading-spinner.component.css
-> In the css file, paste the spinner code which was copied earlier:

b) In loading-spinner.component.ts , create Component , declare selector and for template  , paste the html code from css which was copied earlier 
-> Also specify the css 

@Component({
    selector: 'app-loading-spinner=', 
    template: '<div class="lds-ring"><div></div><div></div><div></div><div></div></div>',
    styleUrls:['./loading-spinner.component.css']
})


c) In the app module, add the LoadingSpinnerComponent under declarations array 
d) Now we can use the LoadingSpinnerComponent in the auth component 
-> We need to hide the entire form, if we are currently loading 
-> To find if we are currently loading in AuthComponent ts, we can add a new property isLoading , change the isLoading property dynamically and update the 
UI based on it 

----> We can make isLoading to true when onSubmit method is executing  and we will make isLoading to false, once we get the data for subscription and also in error case

eg: 
onSubmit(form: NgForm) {
   if(!form.valid)
   {
    return ; 
   }
   const email = form.value.email;
   const password = form.value.password;
   this.isLoading=true ;

   if(this.isLoginMode)
   {

   }
   else{
    this.authService.signup(email,password)
    .subscribe(resData => {
      console.log(resData);
      this.isLoading=false;
    },error => {
      console.log(error);
      this.isLoading=false; 
    }); 
   }
   
   
 e) Now we can make isLoading property in the template to hide the form, using *ngIf 
 
 eg:
      <div *ngIf="isLoading" style="text-align: center">
      <app-loading-spinner ></app-loading-spinner>
    </div>
    <form #authForm="ngForm" (ngSubmit)="onSubmit(authForm)" *ngIf="!isLoading">
		...
 

87) How to handle Error while doing sign up http request
a) Declare new property : error of type string

eg:
error:string =null;

b) In authcomponent ts file, error section for authservice sign up, update the error message

eg:
 this.authService.signup(email,password)
    .subscribe(resData => {
      console.log(resData);
      this.isLoading=false;
    },error => {
      console.log(error);
      this.error="An error occurred and Mahesh handled it "
      this.isLoading=false; 
	  
c) in auth component, html file create another div using bootstrap: alert and alert-danger classes 
-> show error message only if "error" is populated 

eg:
    <div class="alert alert-danger" *ngIf="error">
      <p>{{error}}</p>
    </div>
	

88) How to tell what error occurred while doing sign up http request ?
-> To be specific on what error occurred with specific error message: 
-> In errorresponse we get as part of subscription, access error message like below and populate the error property

eg: 
 this.authService.signup(email,password)
    .subscribe(resData => {
      console.log(resData);
      this.isLoading=false;
    },errorRes => {
      console.log(errorRes);
      switch(errorRes.error.error.message)
      {
        case 'EMAIL_EXISTS':
          this.error='This email id exists already';
      }
      this.isLoading=false; 
    }); 


89) How to tell what error occurred while doing sign up http request: using RxJs Operator:catchError/throwError ?
a) In previous handling, we populated error message in component.  Now we will do error message setting in service area 
b) Using catchError rxjs operator , we can handle error in service while calling the post by using pipe/catchError 
-> catchError catches the error but it returns new observable and that observable should still wrap the error , so that the error ends in error case of subscribe(subscription) ie in the component code 
-> All error messages that are formulated in service code's pipe should be thrown back using throwError observable, so that the component subscription's error part could receive it 

eg: In AuthService : 

return  this.http.
    post('https://identitytoolkit.googleapis.com/v1/accounts:signUp?key=AIzaSyAETvw1FH6Vc5aR8gRIAwIA7iofso0xkmY',
    {
       email:email,
       password: password,
       returnSecureToken:true
    } ).pipe(catchError(
        errorRes => {
            let errorMessage= 'An unknown error occurred';
            if(!errorRes.error || !errorRes.error.error)
            {
                return throwError(errorMessage)
            }
            switch(errorRes.error.error.message)
            {
              case 'EMAIL_EXISTS':
                errorMessage='This email id exists already';
            }
            return throwError(errorMessage);
        }
    ));


c) Now in auth.component's error case , we can get the errorMessage and set it to error property directly 

d) Thus the error handling is done in service, thus making component leaner 

90) How to send login http requests? 
a) in AuthService, create new login method which accepts email and password 
b) In firebase page get the url to sign in with email/password: https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=[API_KEY],
we pass same request which we passed for sign up and almost same response which we got for signup, but one extra property : registered
-> So i will use the same interface: AuthResponseData and add additional property registered and declare it as optional 

eg:
  
  interface AuthResponseData{
kind:string;
idToken:string;
email: string;
refreshToken: string;
expiresIn:string; 
localId: string; 
registered?:boolean
}

c) Hence in request i will specify the response object : 

eg: 
this.http.post<AuthResponseData>

d) Like signup, in AuthService we will return this observable which get from http.post and then later subscribe for the result in the app.component 

eg:
return this.http.post<AuthResponseData>(
'https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=AIzaSyAETvw1FH6Vc5aR8gRIAwIA7iofso0xkmY',
{
    email:email,
    password: password,
    returnSecureToken:true 
});

e) in authcomponent, in login mode, we will subscribe to login observable  and handle both success response and error 

eg: 
 if(this.isLoginMode)
   {
  this.authService.login(email,password).subscribe
  (resData=> {
    console.log(resData);
    this.isLoading=false;
  }, errorMessage => {
    console.log(errorMessage);
   this.error=errorMessage; 
    this.isLoading=false; 
  });
  
f) In order to avoid repeating of code in signup and in login , create a new variable of type Observable of type AuthResponseData
-> since AuthResponseData is in AuthService, we need to export that interface in service and import the sam ein component class

NEED FOR CREATING authObs observable:
a) Earlier when we have check for isLoginMode , we subscribed in if block and in the else block separately.
b) Now using this approach, we can hold the observable in the new variable authObs, and then later have a single subscribe and handle successful 
response and error scenario. thus eliminating redundant code 

eg:
let authObs: Observable<AuthResponseData>;
  this.isLoading=true ;
  if(this.isLoginMode)
  {
    authObs= this.authService.login(email,password);
  }
  else {
    authObs= this.authService.signup(email,password);
  }
  
  authObs.subscribe
  (resData=> {
    console.log(resData);
    this.isLoading=false;
  }, errorMessage => {
    console.log(errorMessage);
   this.error=errorMessage; 
    this.isLoading=false; 
  });


91) How to do Login Error handling for http request: 

a) In authService we have error handling for signup , but for sign in we dont have error handling
b) We can share the error handling logic between two observables 
c) To do that in service class, create a new private method 

eg:
private handleError(errorRes:HttpErrorResponse)
{
let errorMessage= 'An unknown error occurred!';
if(!errorRes.error || !errorRes.error.error)
{
return throwError(errorMessage);
}
switch(errorRes.error.error.message)
{
    case 'EMAIL_EXISTS':
     errorMessage= 'This email exists already';
}
return throwError(errorMessage);

}

d) in signup-> pipe-> catchError-> call the handleError:

eg:
signup(email:string, password: string )
{
  return  this.http.
    post<AuthResponseData>('https://identitytoolkit.googleapis.com/v1/accounts:signUp?key=AIzaSyAETvw1FH6Vc5aR8gRIAwIA7iofso0xkmY',
    {
       email:email,
       password: password,
       returnSecureToken:true
    } ).pipe(catchError(this.handleError));

}
e) we can add the same pipe -> catchError in login method also
f) Thus handleError is running for both obervables that is doing signin and signup

92) How to store user data for logging in?
a) Start by creating user model 
b) Create user.model.ts file in auth folder 
-> this model helps in storing the user data and also helps in validating the token 
-> if we have accessor in front of property like public in constructor, then it will also be used as property name and it will 
automatically store arguments of constructor, in properties of the class. 

eg:
export class User{
constructor(
    public email:string,
    public id:string,
    private _token:string,
    private _tokenExpirationDate:Date 
){}

}

c) 
-> private properties can be accessed via getter
-> getter will look like function , but we access it like a  property 
-> get also means that user cant override this , meaning if you are trying to set that property will throw an error 
eg;
get token()
{
    if(new Date()> this._tokenExpirationDate)
    { 
        return null; 
    }
    return this._token;
}

d) Now we will  store the authenticated user as a subject 

eg:
 user = new Subject<User>();
 
-> We will emit user, a) whenever there is new user who logs in or b) when a user logs out or c) user becomes invalid or
d) token gets expired. 

e) To the signup method we will add a new tap operator, which helps to work on response data without transforming it
-> tap just runs some code with the data we get from observable. 
-> here in tap , i will create new user with the user model we created
-> Here we get the current date which is in mill seconds, then get expires in which in seconds and change it to
 milliseconds. Also we add  double + to typecast and convert expiresIn from string to number before multiplying it with 1000
 -> Then we wrap the whole time in Date object 

   const expirationDate = new Date(new Date().getTime()+ +resData.expiresIn*1000)
 
f) Then we next the newly created user, to set this or emit this as the current logged in user of the application . 

eg:
signup(email:string, password: string )
{
  return  this.http.
    post<AuthResponseData>('https://identitytoolkit.googleapis.com/v1/accounts:signUp?key=AIzaSyAETvw1FH6Vc5aR8gRIAwIA7iofso0xkmY',
    {
       email:email,
       password: password,
       returnSecureToken:true
    } ).pipe(catchError(this.handleError),tap(resData=>
        {
            const expirationDate = new Date(new Date().getTime()+ +resData.expiresIn*1000)
const user = new User(resData.email,resData.localId,resData.idToken,expirationDate);
this.userSubj.next(user);
        }));

}

g) Then for error handling also we need to follow exact same approach
-> Add a new private method handleAuthentication 
-> have all the logic we had in signUp-> tap in this new method

eg:
private handleAuthentication(email:string, localId:string, idToken:string, expiresIn:number)
{

    
    const expirationDate = new Date(new Date().getTime()+ +expiresIn*1000)
    const user = new User(email,localId,idToken,expirationDate);
    this.userSubj.next(user);
       
}

-> Now in signup's tap method we remove existing content and just call handleAuthentication

eg:
.pipe(catchError(this.handleError),tap(resData=>
        {
            this.handleAuthentication(resData.email,
                resData.localId,resData.idToken,+resData.expiresIn)
        }));
		
h) Now we will copy tap of signup and use the same in login's pipe
-> we do this to use the response data to create user objecct and store it  

eg:
 login(email:string, password: string)
{

return this.http.post<AuthResponseData>(
'https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=AIzaSyAETvw1FH6Vc5aR8gRIAwIA7iofso0xkmY',
{
    email:email,
    password: password,
    returnSecureToken:true 
}).pipe(catchError(this.handleError),tap(resData=>
    {
        this.handleAuthentication(resData.email,
            resData.localId,resData.idToken,+resData.expiresIn)
    }));
}


93) How will you reflect authStatus in the UI? 

-> So far we created the user object, that is logged in. 
-> Next step is to redirect the user in UI, navigate us away and then update UI 
i.e show only logout button and manage buttons after we logged in 
-> Thus update the entire header based on the authStatus 

a) Lets start by forwarding the user to a different route once logged in 
-> since we always want to redirect user once authenticated, it can be done in two different places 
---> It can be done in handleAuthentication or in the component authcomponent in subscribe's success case 
-> In our example lets do it in the router 

b) In authcomponent, constructor inject the router and in subscribe success case, navigate to recipes route

eg:
 authObs.subscribe
  (resData=> {
    console.log(resData);
    this.isLoading=false;
    this.router.navigate(['/recipes']);
  }, errorMessage => {
  

c) Now if we try to login, it goes to recipes section 

d) Next step: 
-> disable authenticate link, if you are  logged in
-> disable recipes link, if you are not logged in 
-> to always show shopping list,
-> to disable drop down for save/fetch if you are not logged in 
-> to show logout button, which helps us to logout 

e) Adding logout button in header component ui:

eg: 
        <li>
          <a style="cursor: pointer;">Logout</a>
        </li>

f) Now we need to get the currentauthenticationstatus into the header component 
-> i.e we need to find if user has valid token or not and then update html correctly
-> for that  in authservice, right now we manage 
our user through a subject, which will inform 
all places in application whenever user object 
changes 
-> Hence user subject is going to be source
of truth for us 
--> Hence we can make the header component subscribe to 
the user subject to update header correctly 
based on user status 

g) Hence in header component, lets inject auth service 

eg: 
  constructor(private dataStorageService: DataStorageService, private authService: AuthService) {}
  
h) in ngOnInit of header component, lets 
set a subscription to the subject: AuthService user 

-> our assumption is, when we logged in userSubj will always
 have data, hence we make isAuthenticated to 
 true or false based on whether user is there or not 
 
 eg:
   ngOnInit(): void {
    this.authServiceUserSub=    this.authService.userSubj.subscribe(
      userObj=> {
        this.isAuthenticated= !userObj?false:true; 
      }
    );
	
-> above ternary expreession can also be written
like there:
this.isAuthenticated=!!userObj

---> it means it will be true when we have a user and false when if there is no user 


i) Now based on userObj and isAuthenticated, we can update header component ui to reflect accordingly 

 -> disable recipes link, if you are not logged in(not authenticated) 
eg:
        <li routerLinkActive="active" *ngIf="isAuthenticated">
          <a routerLink="/recipes" >Recipes</a>
        </li>
		
-> Enable authenticate link, if you are not authenticated 

eg: 
       <li routerLinkActive="active" *ngIf="!isAuthenticated">
          <a routerLink="/auth">Authenticate</a>
        </li>
		
		
-> logout,dropdown should be visible only if you are authenticated 

eg:
     <ul class="nav navbar-nav navbar-right">
        <li *ngIf="isAuthenticated">
          <a style="cursor: pointer;">Logout</a>
        </li>

        <li class="dropdown" appDropdown *ngIf="isAuthenticated">
		
	
Next steps:
-> Storing the token and protecting certain routes so that we cant visit them if we
directly enter the url 	

94) How to use our token to fetch data  or How to add token to Outgoing requests? 
-> Why is authentication status ignored while we fetch data? 

-> its because we dont attach token to outgoing request to firebase 
-> Hence we need to manipulate fetch and store Recipes in dataStorageService

a) Inject authService into dataStorageService

eg:
  constructor(private http: HttpClient, private recipeService: RecipeService, 
    private dataStorageService: DataStorageService) {}
	
b) Get access to user in both store recipes and fetch recipes, inorder to get the token
-> we already have subject in AuthService for getting user object, what that will update us for every change in the user object 
-> In our case, we dont want user object for event update, but we need user object whene we need it. ie on demand way of
fetching data

ON DEMAND FETCHING DATA:
WAY1: use Normal SUbject 
i) Since we are interested in token alone, we can declare a string variable 
-> we will set the token whenever we also emit a new subject 

WAY2: Use BEHAVIORSUBJECT
ii) We can also use a different type of subject : BehaviorSubject
-> We can subscribe to this subject and get information whenever new data is emitted 

DIFFERENCE BETWEEN BEHAVIORSUBJECT AND SUBJECT: 
BehaviorSubject: also gives subscribers with immediate access to previously emitted value,even if they have not subscribed at the 
point that value was emitted. 
-> i.e we can get access to currently active user even if we only subscribe after that user has been emitted
-> It mean that when we fetch data and we need that token at this point of time , even if the user logged in before this point 
of time we get access to that latest user 


c)  Hence behavior subject also needs to be initialized with a starting value  and we declare it as null here 
-> Here we initialize with null, since we dont start off with a value 
eg:

    userSubj = new BehaviorSubject<User>(null);

d) No change needed in AuthService, but in dataStorageService , we can reachout to AuthService, get the currently active user 
and be done with that 
-> in fetchRecipes i dont want to have ongoing subscription, but i want to get user only once and thereafter i am done
----> we can do unsubscribe to achieve that 
------> or we can use the pipe with the take operator 
-> take is also an rxjs operator and we can pass a number to it 
-> if we pass 1, it means i want to take only one value from that observable and thereafter it should automatically 
unsubscribe
-> So this declaration, matches the subscription, gives latest data and then unsubscribes 
-> Thus take helps us to take data on demand 

eg:

    this.authService.userSubj.pipe(take(1)).subscribe(
      user=>{}
    );
    return this.http.get<Recipe[]>(
        'https://testmaheproject2-default-rtdb.firebaseio.com/recipes.json'
      )
	  
e) Now the problem is , we need to have the http.get within subscribe and return the observable, but the problem is  we cannot return within subscribe
-> Now the solution is : 
Pipe the two observables : a) userSubj and the b) out of http.get TOGETHER INTO ONE BIG OBSERVABLE 
-> We can simply add another observable to pipe for the user observable

f) exhaustMap is the new rxjs operator 
exhaustMap -> waits for the first observable to complete, in out case it happens after we get the latest user 
-> Thereafter it gives us the user - now we return a new observable in there which will return the previous 
observable in the entire observable chain 
---> in our case first we start off with user obervable and once we are done with that, it will be replaced 
in the observable chain with the inner observable, we return inside of that function we passed to exhaustMap 
-> Hence inside we will return the httprequest, where is get my recipes 
---> since return of http.get is done within exhaust map, the entire observable chain switches to http observable

 
eg:
    this.authService.userSubj.pipe(take(1)),exhaustMap(
      user=>{
        return this.http.get<Recipe[]>(
          'https://testmaheproject2-default-rtdb.firebaseio.com/recipes.json'
        )
      }
    );
	
g) Now with regards to map and tap which we used earlier, we can cut them and add them as next steps after the exhaustMap and then we 
can return the overall observable 
-> This means that we can still subscribe to that observable returned by fetchRecipes and in the end it will be 
http observable , because we switch it in the exhaustMap 

eg:
 fetchRecipes() {

    this.authService.userSubj.pipe(take(1),exhaustMap(
      user=>{
        return this.http.get<Recipe[]>(
          'https://testmaheproject2-default-rtdb.firebaseio.com/recipes.json'
        )
      }
    ),  map(recipes => {
      return recipes.map(recipe => {
        return {
          ...recipe,
          ingredients: recipe.ingredients ? recipe.ingredients : []
        };
      });
    }),
    tap(recipes => {
      this.recipeService.setRecipes(recipes);
    }));   
      
  }

h) Thus Overall: 
##) WE UTILIZED THE user observable, got the user out of it one time , UNSUBSCRIBED  to that observable
##) Then AUTOMATICALLY replaced it with new observable  

i) Now we got the user, we need to extract the token and then add the token to this http request which we do via exhaustMap

-> for firebase, we add token as query parameter in url
-> for other apis, normally we add it as header in the request 

eg:
  this.authService.userSubj.pipe(take(1),exhaustMap(
      user=>{
        return this.http.get<Recipe[]>(
          'https://testmaheproject2-default-rtdb.firebaseio.com/recipes.json',
          {
            params: new HttpParams().set('auth',user.token)
          }
        )
      }
	  
--> thus now when we fire the request, we can see token is sent as part of header 



95) How to attach token to HTTP request, using an interceptor? 
-> So far we have added token to fetch recipes, similarly we need to add token to store recipes
-> we can copy same code from fetchRecipes to storeRecipes, but there is more elegant approach
-> We can use interceptors to achieve the same 

a) Create AuthInterceptorService class which implements HttpInterceptor and override intercept()

eg:
@Injectable()
export class AuthInterceptorService implements HttpInterceptor{
    
    intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
   return next.handle(req);
    }
}

b) We should be modifying the request to attach token before returning through next 
c) Inject AuthService in the constructor

eg:
 constructor(private authService:AuthService)
    {
        
    }

d) Now in intercept(), use the authservice and do the subscribe
-> in FetchRecipes, we would have used pipe,exhaustMap and so on. Same approach needs to be followed here :

-> We can copy the below chunk of code from fetchRecipes and use the same in interceptor 

eg:
 return this.authService.user.pipe(
      take(1),
      exhaustMap(user => {
	  
e) Then move the return statement of interceptor into the exhauseMap

eg;
    intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
        return this.authService.user.pipe(
            take(1),
            exhaustMap(user => {
                return next.handle(req);
            }));

    }
	
f) We will clone our request and update it , so the modified request is created
by calling request.clone and to the clone we can pass an object, where we can update the 
params 
-> we set the user.token in the 'auth' params 
-> Then we pass the modified request in the next.handle  and return the same 

eg:
intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
        return this.authService.user.pipe(
            take(1),
            exhaustMap(user => {
const modifiedRequest = req.clone({
    params: new HttpParams().set('auth',user.token)
            });

                return next.handle(modifiedRequest);
            }));
    }

-> with this change, this interceptor should be able to add token to all the outgoing 
requests 

g) Next we should make sure that we provide the token in the app module, under 
providers .ie we add the interceptor on the providers 

-> also set multi: true , in order to allow multiple interceptors

eg:
  providers: [
    ShoppingListService,
    RecipeService,
    {
      provide: HTTP_INTERCEPTORS,
      useClass: AuthInterceptorService,
      multi: true,
    },
  ],
  
  
h) Now we have added interceptor and specified the same in provider of app.module.ts
i) Now we have to fix the datastorage service, as we dont need to use the logic to 
set the token through HttpParams in our request 

-> We need to remove this in fetchRecipes code: 
eg:
 return this.http.get<Recipe[]>(
          'https://testmaheproject2-default-rtdb.firebaseio.com/recipes.json',
          {
            params: new HttpParams().set('auth', user.token)
          }
        );
      }),
	  
	  
j) Now still if we try to login we will face issue, because intercptor will work 
even for login and in that case user object to fetch token will be null, 
-> we can bypass this issue, by adding a check for user  in the intercept() 

eg: 
if(!user)
{
return next.handle(request) 
}

  'https://www.googleapis.com/identitytoolkit/v3/relyingparty/signupNewUser?key=AIzaSyAETvw1FH6Vc5aR8gRIAwIA7iofso0xkmY',
  
  k) Thus we used interceptor to intercept all requests and append it with auth token 
  
  
96) How to add logout functionality
a) go to auth.service.ts and add logout() function 
b) in logout function, we use our user subject and in next we call null 
-> by this we set the user subject to be null, which is our initial state before logging in 

eg:
  logout() {
    this.user.next(null);
  }
  
c) Link the click to onLogOut to the header.component.html 
eg:
        <li *ngIf="isAuthenticated">
          <a style="cursor: pointer;" (click)="onLogout()">Logout</a>
        </li>

d) then header.component.ts , in onLogOut call the auth.service.ts's logout() function 

eg:
  onLogout() {
    this.authService.logout();
  }
  
e) after logout we also should redirect in auth service
-> first inject router in auth.service.ts 

eg:
  constructor(private http: HttpClient, private router: Router)

-> in logout() function, do the redirection to /auth 

eg:
  logout() {
    this.user.next(null);
    this.router.navigate(['/auth']);
  }


99) How will you do autologin : i.e Persist the token , so that token is still there when we do reload 


-> Right now, when we reload the page , we lose all the status in the app
-> This is because when we reload the page, angular application restarts, hence the old application
data is dumped 
-> Since we store user object in memory in javascript, whenever application restarts , we lose
all the state i.e the memory gets cleared automatically 
-> There wont be any connection between last time we ran this page and this time after we reloaded the 
page 

-> Hence if we want to store the auth token, we have to store it somewhere else and not in 
javascript variable  or class property 

HOW TO STORE USER DATA IN LOCAL STORAGE:
a) We have to store the auth token in a persistent storage, that survives page reloads and
browser restarts - which we can write to and fetch data from 
b) What would be such a storage ? 
-> In Browser we have got different storages
-> We cant access the normal file system of your device, but we can work with cookies
or with local storage 
-> Local stoage is the api exposed by browser to store simple key value 
pairs on the file system, but it is controlled by the browser 
---> We will use local stoage here, to store the token 
c) To store the token in the local storage, go to auth.service.ts -> handleAuthentication function  
-> in this method we create user object and emit it to our application 
-> Here besides emitting it to the application, we also want to store the token 
in our local storage
--> this can be done by calling setItem of localStorage by using key value pair
-> we can give any name as key  which will be later used for retrieval.
-> then we should write some value i.e data 
---> In our case, we will store the user object to the local storage 
--> Here the problem is we cant store the user object directly, we can only store it as string
-> to convert it into string, we need to use JSON object's stringify method 
-> JSON.stringify -> serializes or converts a javascript object to string version of it 
-> thus the string version of the user object gets stored in the local storage 

eg:  
    localStorage.setItem("userData", JSON.stringify(user));
	
d) Now if we go to inspect-> application -> storage -> local storage 
-> we will be able to see the useData stored as string  

HOW TO RETRIEVE USER DATA FROM LOCAL STORAGE: 
a) for that add a new method autoLogin() in auth.service.ts 

->The goal of autologin method is to retrieve the user data from the local storage
b) use the localStorage's getItem function 
-> when there is no userData, we do a return so that the user has signin on his own 
 const userData = localStorage.getItem("userData");
 
c) here the userData which we get is string, we need to convert it 
back to normal javascript object, by calling JSON.parse

eg:
    const userData = JSON.parse(localStorage.getItem("userData"));
	
d) Note that the userData which we obtained is not of type User model
e) Hence we need to create new User model  from the userData object

eg:
  const loadedUser = new User(
      userData.email,
      userData.id,
      userData._token,
      new Date(userData._tokenExpirationDate)
    );
	
f) Then we need to check if this user has valid token or not and then forward the loadedUser as our new
authenticated user 

eg:
  if (loadedUser.token) {
      this.user.next(loadedUser);
    }
	
g) thus the auto login function .. 
h) To see how it works, lets go to a place which runs early in our application lifecycle  
-> app.component.ts 
-> implement OnInit interface and impement ngOnInit function
-> also inject the auth service and call autologin method 

eg:
  constructor(private authService: AuthService) {}
  ngOnInit(): void {
    this.authService.autoLogin();
  }
  

100) How to do Auto logout functionality?
=> if token expires, auto logout should happen 
a) In auth.service.ts -> logout() -> ensure that we clear the local storage 

eg:    localStorage.clear(); 

-> clear clears all the data in local storage

But if we want to remove certain item in the local storage, we can use removeItem() 

eg:
    localStorage.removeItem("userData");


b) create method autoLogout which sets a timer and manages a timer for automatically
logging the user out 

-> Here after the timeout of expirationDuration, this.logout() method will be called 

eg: 
  autoLogout(expirationDuration: number) {
    setTimeout(() => {
      this.logout();
    }, expirationDuration);
  }

c) When user logs out manually, we should clear the expiration timer  
-> for that create a variable: tokenExpirationTimer

eg:
export class AuthService {
  user = new BehaviorSubject<User>(null);
  private tokenExpirationTimer: any;
  
d) setTimeout returns reference of the timer, so we can store it in tokenExpirationTimer

eg:
  autoLogout(expirationDuration: number) {
    this.tokenExpirationTimer = setTimeout(() => {
      this.logout();
    }, expirationDuration);
  }
  
e) In the logout function, we need to clear that timer 

eg:
  logout() {
    this.user.next(null);
    this.router.navigate(["/auth"]);
    localStorage.removeItem("userData");
    if (this.tokenExpirationTimer) {
      clearTimeout(this.tokenExpirationTimer);
    }
    this.tokenExpirationTimer = null;
  }
  
  
f) Thus far, we cleared the tokenExpirationTimer, when we logout and we 
also set the tokenExpirationTimer in the autoLogout method 
g) Now we need to make sure that we call autoLogout , to make sure that the timer actually starts
h) We need to call autoLogout  whenever we emit a new user to our application 
i.e in handleAuthentication and also in autologin methods 

i) In handleAuthentication , we emit a user - there we should call autoLogout and pass the current
expiration time into that 

eg:
private handleAuthentication(
    email: string,
    userId: string,
    token: string,
    expiresIn: number
  ) {
    const expirationDate = new Date(new Date().getTime() + expiresIn * 1000);
    const user = new User(email, userId, token, expirationDate);
    this.user.next(user);
    this.autoLogout(expiresIn * 1000);
    localStorage.setItem("userData", JSON.stringify(user));
  }
  
j) Now we need to do the same in autoLogin, but with some tweaks to calculate expirationDuration :

    if (loadedUser.token) {
      this.user.next(loadedUser);
      const expirationDuration =
        new Date(userData._tokenExpirationDate).getTime() -
        new Date().getTime();
      this.autoLogout(expirationDuration);
    }
	
	
101) We can still recipes route, even though we are not logged in : 
How to prevent users visiting /recipes if they are not authenticated  using Auth Guard? 

-> A ROUTE GUARD - allows us to run logic right before the route is loaded 
-> we can deny access to a route if certain condition is not met 

a) Create a new file : auth.guard.ts 
b) Export class AuthGuard and override canActivate

eg:
export class AuthGuard implements CanActivate {
  canActivate(
  
c) Since AuthGuard is going to be service, we will be using @Injectable 
d) Inject AuthService in the constructor 

eg:
  constructor(private authService: AuthService) {}
  
e) impement canActivate

eg:
 canActivate(
    route: ActivatedRouteSnapshot,
    state: RouterStateSnapshot
  ):
    | boolean
    | UrlTree
    | Observable<boolean | UrlTree>
    | Promise<boolean | UrlTree> {
    return this.authService.user.pipe(
      map((user) => {
        return !!user;
      })
    );
  }
  
f) now go to app-routing.module.ts and we want to protect recipes with AuthGuard, using 
canActivate: 

eg: 
    path: "recipes",
    component: RecipesComponent,
    canActivate: [AuthGuard],
    children: [
	
g) to redirect to url in case of unauthenticated user: 

-> here we return true in case of authenticated and return urltree if not authenticated 

eg: 
canActivate(
    route: ActivatedRouteSnapshot,
    state: RouterStateSnapshot
  ):
    | boolean
    | UrlTree
    | Observable<boolean | UrlTree>
    | Promise<boolean | UrlTree> {
    return this.authService.user.pipe(
	 take(1),
      map((user) => {
        const isAuth = !!user;
        if (isAuth) {
          return true;
        }
        return this.router.createUrlTree(["/auth"]);
      })
    );
  }
  
102) what are Dynamic Components?
-> Components that we create during run time 

eg; showing an alert or modal only upon a particular action 

-> In this module, we will learn:
a) How to create dynamic component
b) How to load it on demand 
c) how to communicate with it 
d) how to get rid of it 



103) Understanding different approaches:
a) Dynamic components - means displaying some components dynamically
-> Those components are not always present but its present once something specific happens in your 
code 
b) Hence we want to control programatically when that component should be loaded and displayed 
c) DIFFERENT WAYS OF LOADING DYNAMIC COMPONENTS PROGRAMATICALLY: 
i) using *ngIf 
-> component embedded via selector declaratively
-> *ngIf controls whether component is added to DOM 
ii) Using Dynamic Component Loader 
-> creating component in code and manually attaching it to DOM 
-> component is managed and added/removed by developer 
---> this approach involves controlling everything from code and not touching the template 

104) How to add an alert modal component: Using *ngIf approach 
-> Let display simple alert modal overlay in case of an incorrect login 
a) Create AlertComponent and specify selector and html

eg:
@Component({
  selector: "app-alert",
  templateUrl: "./alert.component.html",
  styleUrls: ["./alert.component.css"],
})
export class AlertComponent {
  @Input() message: string;
}

b) in html, create div with class backdrop and add another div of class alert-box 

eg:
<div class="backdrop"></div>
<div class="alert-box">
<p>{{message}}</p>
<div class="alert-box-actions">
    <button
    class="btn btn-primary">Close</button>
</div>

</div>


c) in auth.component.html, comment the alert which we show in case of error:

eg:
    <div class="alert alert-danger" *ngIf="error">
      <p>{{ error }}</p>
    </div>
	

d) and we are showing our app-alert component in case of error

eg:
    <app-alert [message]="error" *ngIf="error"></app-alert> 
	

e) Until now , our alert component is included through a selector in html and 
controlled with *ngIf 
-> advantage of this is, we dont have to manually create it and we can pass data with
property binding 

f) To get rid of the alert, we need to emit an event and make that event listenable from outside
with the help of @Output 

eg:
  @Output() close = new EventEmitter<void>();
  
  
g) To emit the event, we  will create a method: onClose, which will be triggerred whenever user clicks
the close button or the backdrdop 

eg:
<div class="backdrop" (click)="onClose()"></div>
<div class="alert-box">
<p>{{message}}</p>
<div class="alert-box-actions">
    <button
    class="btn btn-primary" (click)="onClose()">Close</button>
</div>

h) in alert.component.ts, on call of onClose(), lets emit event for close

eg:
  onClose() {
    this.close.emit();
  }
  
i) Now in auth component, lets listen to the close event and trigger a method:onHandleErrorClose

eg:
   <app-alert [message]="error" *ngIf="error" (close)="onHandleErrorClose"></app-alert>
   
j) Now add this method to the auth-component and make error=null, so that app-alert wont displaythe modal
since it :

eg:
  onHandleErrorClose() {
    this.error = null;
  }
  
j) Thus using this approach to display dynamic components like alert modal is going to be simpler
for the use case: Where we need to show some component dynamically based on a condition 


105) How to create dynamic component using programmatic approach: 
a) First lets comment the <app-alert> component which is shown based on *ngIf 

eg:
    <!-- <app-alert [message]="error" *ngIf="error" (close)="onHandleErrorClose()"></app-alert> -->
	
b) Now the goal is to create the alert component programatically and show it programatically
c) For that we need a new method in auth.component.ts , to show the error alert 

eg:
  private showErrorAlert() {}
  
d) showErrorAlert() has to be called, whenever there is an error and we set the error 

eg:
   (errorMessage) => {
        console.log(errorMessage);
        this.error = errorMessage;
        this.showErrorAlert(errorMessage);
        this.isLoading = false;
      }
	  
	  
e) now in showErrorAlert method, we need to dynamically create Alert component 
-> To do that, we can manually initiate the component and following are the steps
i) Import the AlertComponent in auth.component.ts 

eg:
import { AlertComponent } from "../shared/alert/alert.component";

ii) create instance for AlertComponent in showErrorAlert() method:

eg:
    const alertComponentObj = new AlertComponent();

-> This may be valid typescript code to create instance, but this alone is not sufficient
 to create a component from angular perspective.
-> Because angular does far more things while creating component 
---> angular needs to wire it up to change detection into the dom 
---> Hence we cannot create Angular component like this 

f) Instead we need to tell Angular to create the component using: ComponentFactory 
-> inject ComponentFactoryResolver in the constructor of auth-component.ts 

eg:
  constructor(
    private authService: AuthService,
    private router: Router,
    private componentFactoryResolver: ComponentFactoryResolver
  ) {}
  
  
g) In showErrorAlert() method, use the componentFactoryResolver to get access to resolveComponentFactory
-> To resolveComponentFactory, we need to pass the type of the Component


eg:
    this.componentFactoryResolver.resolveComponentFactory(AlertComponent);

-> The resolveComponentFactory,returns a component factory and not the alert component 

h) Now we need to use the component factory and create a concrete component 
-> But we also need to specify the place where we need to attach the component in the dom. 
-> i.e we want to tell angular where we want to attach that component in the html 

Angular needs a ViewContainerRef. ViewContainerRef is essentially an object managed internally by angular, which gives angular the reference ,
pointer to a place in dom with which it can interact 
-> This object has more than the co-ordinates where it sits .
---> it has methods like creating component 

h) to get access to ViewContainerRef, we can create a helper directive which could be named placeholder :placeholder.directive.ts
i) In that file,we create PlaceholderDirective 

eg:

@Directive({
  selector: '[appPlaceholder]',
})
export class PlaceholderDirective {}

j) this directive needs to inject ViewContainerRef 
-> This directive automatically gives access to the reference, ie. to the pointer of the place where 
this directive is used 
-> Thus this will help to get the information about the place where we use that directive  

eg:
export class PlaceholderDirective {

    constructor(viewContainerRef:ViewContainerRef)
    {}
	
k) We need to store in to a public property: viewContainerRef - where this argument is 
automatically stored in a property of the same name and this property is publicly accessible ,
so that we can access ViewContainerRef from outside 

->now we will add this directive in html and get access to it through @ViewChild 

eg:
    constructor(public viewContainerRef:ViewContainerRef)
    {}
	
l) Also declare that directive in the app.module.ts in declarations section
eg:
    AlertComponent,
    PlaceholderDirective
  ],
  imports: [
  
m) Now the PlaceholderDirective is added. Lets go to auth-component html file and add 
a new element there 
-> we can use <ng-template> for the same in auth.component.html 
-> <ng-template> of angular, will not render anything to dom , but still accessible in the 
angular templating language. 
-> This is good, since we dont add extra dom element like dom, and instead we can get
access to a place in the dom 
-> to <ng-template> we can add appPlaceholder directive 

eg:
<ng-template appPlaceholder></ng-template>
<div class="row">

n) next in the auth.component.ts, we can access to that directive with help of @ViewChild 

eg:
export class AuthComponent {
  isLoginMode = true;
  isLoading = false;
  error: string = null;
  @ViewChild(PlaceholderDirective,{static:false}) alertHost: PlaceholderDirective;
  
  
o) Now this alertHost can be used in show error alert 


eg:
  private showErrorAlert(message: string) {
    //const alertComponentObj = new AlertComponent();
    const alertComponentFactory =
      this.componentFactoryResolver.resolveComponentFactory(AlertComponent);
      const hostViewContainerRef = this.alertHost.viewContainerRef;
	  
p) Now clear anything, that was rendered before by calling clear on the viewContainerRef

eg:
  private showErrorAlert(message: string) {
    //const alertComponentObj = new AlertComponent();
    const alertComponentFactory =
      this.componentFactoryResolver.resolveComponentFactory(AlertComponent);
      const hostViewContainerRef = this.alertHost.viewContainerRef;
      hostViewContainerRef.clear(); 
  }
  
q)  Now we can use the componentFactory to create a new AlertComponent in hostViewContainerRef 
by calling createComponent(), and createComponent needs to be passed with the factory we created earlier: alertComponentFactory 

eg:
hostViewContainerRef.createComponent(alertComponentFactory);

-> this will create a new Component in that place 

r) Now we will get 'did you add entry components' error in the application 


106) What are EntryComponents : 
-> Until now we tried to render dynamic component programatically, but we ended up with a strange error  while 
testing : 
-> but we wont get that error if we use angular 9 or later 


REASON FOR ERROR:
a) It did not find component factory for alert compoent 

HOW ANGULAR WORKS BEHIND SCENES WHILE CREATING COMPONENTS:
a) Any components or directives or pipes - needed to be added as part of declarations of app.module 
b) This is important for angular to understand what is a component or which components and directives 
you have in your app. 
-> This is because angular does not automatically scan all your files 
-> Hence declarations makes angular aware of the component ,so that angular 
creates those components when it finds in one of two places
c) The first place would be in your templates 
-> if it finds the selector in templates , angular looks into declarations array ,
finds it there and then it is able to create component 
d) The other place where angular will look for the component, is in your routes
-> in route config, if we point at a component , angular will also check that in the declarations 
array , and if it is able to find it in declarations array, then angular will creat the component
and load it 
e) One place that does not work by default is - when you want to create a component manually 
f) For example, we create our own componentFactory with alert component
-> here angular does not automatically reach out to declarations array 
-> instead we need to deliberately inform angular that in this case, alertcomponent will be 
created at some place and angular should be prepared for it 
g) To tell angular that it needs to be prepared, we need to add a special property to the
object you pass to the ngModule 
h) Besides declarations, imports , there is another property what we need to specify.
-> it is ENTRYCOMPONENTS 
-> entryComponents is an array of component types 
-> But only of components that will eventually be need to be created without a selector 
or the route config being used. 
i) THUS WHENEVER A COMPONENT IS CREATED THROUGH SELECTOR IN HTML OR ROUTE CONFIG , we need to specify
in declarations and when manually created programatically, we need to add the component in
entryComponents

eg:  in app.module.ts 
 bootstrap: [AppComponent],
  entryComponents:[AlertComponent]
  
j) if you are using angular 9+, you need not specify entryComponents

107) How to do Data binding and Event binding in Component that is created programatically? 
-> Until now because of our changes we dont see the error message or we are not able to close the 
alert modal
-> This is because In AlertComponent, we have @Input() and @Output() , but 
we are not using property or event binding on our component at the moment , because we 
created the component in code 

so HOW TO PASS DATA INTO THE COMPONENT or LISTEN TO AN EVENT or REMOVE IT 
a) Store the component created in a constant variabe 

eg:      
	  const componentRef= hostViewContainerRef.createComponent(alertComponentFactory);

b) Now we can interact with that component : 
-> we can use the instance which has the properties of alertcomponent

eg:
   componentRef.instance.message=message;
   
c) Now on saving we will be able to see the error message in the screen for AlertModal 
d) Now for closing, we need to manually listen to the closing event and subscribe it 
-> clear it using hostViewContainerRef

eg: 
     this.closeSub= componentRef.instance.close.subscribe(
        ()=> {
          this.closeSub.unsubscribe();
          hostViewContainerRef.clear();
        }
	  
e) After this change, close of the alert modal should be working fine 

f) Thus ends the section of dynamically creating components programatically 


108) What are Modules in Angular ?
-> NgModule is the angular module 

a)  Module is way of bundling Angular building blocks together 
b) Building blocks include Components, Directives, Services, Pipes
c) You have to group that all together into angular modules, so that angular is 
aware of these features  
d) This is because angular does not automatically scan all the files in your 
project 
e) Instead we need to tell Angular, 
1) Which components do you have?
2) Directives
3) Services 
4) Pipes etc 
and then bundle them together into modules 
f) Every angular app needs to have atleast one module  - app module 
g) We cant have an angular app without app module 
h) Sample App Module
App Module
|----AppComponent
|----ProductsComponent
|----HighlightDirective
|----ProductsService


109) What does Angular do with Modules
a) Angular analyzes NgModules to Understand your application and its features 
b) Angular modules define all building blocks your app uses: 
Components, Directives, services 
c) An Application requires atleast one module(AppModule), but may be split into multiple 
modules 
d) We have Core Angular features that are wrapped into modules 
(eg; FormsModule ) to load them only when needed. 
e) You cant use a feature/building block without including it in a module 
f) We can include it by adding in declarations or providers, depending on the 
feature/building block 


110) What does the AppModule in the course project contain? 
a) In our project we have two modules: a) AppModule and b)AppRoutingModule
-> Both are decorated with @NgModule decorator
b) In AppModule, we have  declarations [] array
Declarations - It is the end array of all the  components,directives and custom pipes 
-> If not provided in the declarations, that component or building block could not be used in 
the template or in routes

eg:
@NgModule({
  declarations: [
    AppComponent,
    HeaderComponent,
    RecipesComponent,
    RecipeListComponent,
    RecipeDetailComponent,
    RecipeItemComponent,
    ShoppingListComponent,
	
	
c) In AppModule, we have imports[] array
Imports - Imports array helps to import other modules into this module 
-> Hence imports array is important here to split your application into multiple modules 
-> So far in our project, we created only extra module - AppRoutingModule 
-> But we were using couple of modules shipped with Angular like FormsModule,ReactiveFormsModule etc 

eg: 
imports: [
    BrowserModule,
    FormsModule,
    ReactiveFormsModule,
    HttpClientModule,
    AppRoutingModule,
	
	
d) In AppModule, we have providers[] array
providers - Any service that we plan on injecting should be provided in providers array or

eg:
  providers: [
    ShoppingListService,
    RecipeService,
    {
      provide: HTTP_INTERCEPTORS,
      useClass: AuthInterceptorService,
      multi: true,
    },
  ],
  
  


-> Alternatively we can add services  like this using providedIn 

eg:
@Injectable({providedIn: 'root'}) 

e) In AppModule, we have bootstrap[] array

eg: app.module.ts 
  bootstrap: [AppComponent],
  
bootstrap - Important for starting our app 
-> it tells which component is available in index.html file 
-> Typically we have only one component here  in index.html 

eg: index.html

<body>
  <app-root></app-root>
</body>

-> We can define multiple components in bootstrap array , then each component will be detached from other components.
-> IT will create different root component trees in application and it is not used much
since it makes working between components harder 
-> So in most of the cases, we have only one root component in index.html and add that in bootstrap array 


f) In AppModule,we have entryComponents[] array 

-> this is for components that we created programatically 


111) What does the AppRoutingModule contain: 
a) In our imports of AppModule, we have AppRoutingModule mentioned
-> We use AppRoutingModule to hold the route configuration 

b) AppRoutingModule imports the RouterModule of anuglar and use the special method 
offered by that module, which then takes our route configuration  to configure the Angular
Router with our route config 

eg:app-routing.module.ts

@NgModule({
  imports: [RouterModule.forRoot(appRoutes)],
  exports: [RouterModule],
})


c) We export the RouterModule from the AppRoutingModule
-> We need to do that because every module works on its own in angular 
-> They dont communicate with each other 
-> If you declare a component in a certain module like AppModule, we can only use it in AppModule 
and nowhere else 
-> Thus we cannot use selectors of other modules into our current module 
-> Hence to use them, we need to export the RouterModule with our route configuration
-> SO that it is not just available  in this module ie AppRoutingModule, but then it is available in 
AppModule as well. since we have declared AppRoutingModule in the imports array of AppModule 
-> When we import another module in our module, we import everything that module exports

in our case, it is configured RouterModule 

eg:
 @NgModule({
  imports: [RouterModule.forRoot(appRoutes)],
  exports: [RouterModule],
})

d) Thus the configured RouterModule of AppRoutingModule is available in the AppModule 



112) When to go and split our application into smaller modules? 
-> For smaller applications, we need not split modules
-> But if your application grows bigger,we need to split our code into leaner modules 

113) How to split a sample project into multiple modules :

a) One big AppModule without being split
AppModule                                        
|                                                
|--AppComponent                                  
|                                                               
|--ProductListComponent                                         
|                                                               
|--ProductComponent                                             
|                                                                
|--OrdersComponent                                               
|                                                                
|-- Highligh Directive                                            


b) Split into three modules: AppModule, ProductsModule and OrdersModule 



AppModule       
|               
|--AppComponent 

 ProductsModule 
 |
 |--ProductListComponent
 |
 |--ProductComponent 
 
  OrdersModule 
  |
  |--OrdersComponent
  |
  |--Highligh Directive 
  
  
c) Here AppModule defines AppComponent 
d) We have two feature modules: ProductsModule and OrdersModule
-> Feature module also has NgModule defined in it and it is called Feature module since we 
use it for a particular feature or functionality
  
  
114) What are the advantages of grouping into modules:
a) Improves performance
b) Makes code refactoring easy   
  
114) How to split our Course project into Feature Modules 

a) In our course project, we have the following features:
i) Recipes feature
ii) Shopping list feature
iii) Auth feature 

HEADER AND SHARED COMPONENTS 
-> Header and shared components are not really features of the app 
---> Header is part of App component
-> Shared Component is used in certain parts of the app 
like Alert/Auth and it is shared across different
features of our application 
-> Because we could be showing an alert in recipes area as well 

115) How to Create Module for Recipes feature

a) In recipes folder, create new file:recipes.module.ts
b) In the file, create a class and add @NgModule decorator

eg: 
@NgModule()
export class RecipesModule {}

c) To the @NgModule decorator, we can add all things, what we added earlier 
app.module.ts 

-> Remove all recipes related components from app.module and add it to 
declarations of recipes.module.ts 

eg:
   declarations:[
            RecipesComponent,
            RecipeListComponent,
            RecipeDetailComponent,
            RecipeItemComponent,
            RecipeStartComponent,
            RecipeEditComponent,
        ]
		
d) To use Recipes module in app module , as first step, copy all components in declarations array and put it in exports array of
recipes module :

eg:
   exports:
        [
            RecipesComponent,
            RecipeListComponent,
            RecipeDetailComponent,
            RecipeItemComponent,
            RecipeStartComponent,
            RecipeEditComponent
        ]
		
-> By doing exports of all components, all the modules that imports the recipes module will be able to use these components

e) Lets import recipes module in app.module 

eg:
  imports: [
    BrowserModule,
    FormsModule,
    ReactiveFormsModule,
    HttpClientModule,
    AppRoutingModule,
    RecipesModule
  ],
  
-> the imports array, will help to import all the features of the module declared in imports into the parent module: i.e the app.module here 

f) Now if we save the application, we get the below error:
which is thrown from recipes.module-> recipes.component 
-> The problem here is, in recipes component we are using
router-outlet 


eg:
Error: src/app/recipes/recipes.component.html:6:5 - error NG8001: 'router-outlet' is not a known element:
1. If 'router-outlet' is an Angular component, then verify that it is part of this module.
2. If 'router-outlet' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the '@NgModule.schemas' of this component to suppress this message.

6     <router-outlet></router-outlet>
      ~~~~~~~~~~~~~~~
	  
	  
g) 
-> router-outlet is a directive provided by angular and
its not magically available for the entire application 
-> <router-outlet> is made available by the router module 
by the imports and exports

eg: in app-routing.module.ts 

eg: 
@NgModule({
  imports: [RouterModule.forRoot(appRoutes)],
  exports: [RouterModule],
})


-> The above declaration of imports and exports is not 
there only to configure our routes, but it also adds 
routing features like router link directive which we 
used to add a link or the router outlet directive 
-> Since RouterModule is exported in app-routing module
and in appModule we have AppRoutingModule in the imports 
array -> Router module and its features are available

h) But this router module will not be available in recipes
module 
-> This is because everything in a module works standalone 
---> Hence though we imported AppRoutingModule in app module, 
RouterModule will not be available in recipes module
---> Thus recipes module does not have access to all 
the modules that we specified as imports in AppModule 

i) How to fix this issue:
TWO WAYS:
1) Simply import RouterModule in recipes module 
--> but still everything does not get imported and we may
face issues  for *ngFOr, hence we need to import BrowserModule 
also here

eg: 
        imports:[RouterModule,BrowserModule],
		
		or
		
We can import CommonModule, to get access to *ngIf and
*ngFor 

j) Now the *ngIf and *ngFor issues go after saving and
we get new error:

eg:
Error: src/app/recipes/recipe-edit/recipe-edit.component.html:3:11 - error NG8002: Can't bind to 'formGroup' since it isn't a known property of 'form'.

3     <form [formGroup]="recipeForm" (ngSubmit)="onSubmit()">
            ~~~~~~~~~~~~~~~~~~~~~~~~

  src/app/recipes/recipe-edit/recipe-edit.component.ts:9:16
  
  
-> TO solve this issue, we need to impor the FormsModule

eg:
        imports:[RouterModule,CommonModule,FormsModule],
		

-> thus all the compilation issues gets solved 

j) Thus the core takeaway is:

-> Whatever Component declared in declaration of Recipes Module,
and whatever used in the template of these components ,
has to be imported in that module 
-> Its not enough if you import that in the appModule

k) The only exception to this rule is SERVICES 

-> Services if setup or specified in appModule , we can 
access them in the whole application and even in components which 
are added to Feature Modules 

l) But anything that is used in templates like: Components, Directive and pipels
needs to be declared or imported in the module where we use them 
 
 
 115) How to add Routes to Feature Modules :
 -> Thus far we outsourced recipes component declaration 
 from appModule to RecipesModule so that app module becomes 
 leaner 
 
 -> We can do more. We can also move recipes related 
 route configuration away from the app routing module and
 move the below route configuration into recipes module 
 
 
 eg:
   {
    path: "recipes",
    component: RecipesComponent,
    canActivate: [AuthGuard],
    children: [
      { path: "", component: RecipeStartComponent },
      { path: "new", component: RecipeEditComponent },
      {
        path: ":id",
        component: RecipeDetailComponent,
        resolve: [RecipesResolverService],
      },
      {
        path: ":id/edit",
        component: RecipeEditComponent,
        resolve: [RecipesResolverService],
      },
    ],
  },
  
  
 a) To do that  in RouterModule specified in imports of
 recipes.module we need to specify forChild 
 
-> RouterModule.forRoot is used only once i.e in appRoutingModule 
and in FeatureModules we will be using RouterModule.forChild ,
which automatically merges child routing configuration with the
root routes 

b) To keep recipes module leaner, we can create 
recipes.route.module to focus on the routing related
configuration for Recipes module  and copy recipes specific
routes into appRoutes array 

eg:
import { NgModule } from "@angular/core";
import { Route, RouterModule } from "@angular/router";
import { AuthGuard } from "../auth/auth.guard";
import { RecipesComponent } from "./recipes.component";
import { RecipeEditComponent } from "./recipe-edit/recipe-edit.component";
import { RecipeStartComponent } from "./recipe-start/recipe-start.component";
import { RecipeDetailComponent } from "./recipe-detail/recipe-detail.component";
import { RecipesResolverService } from "./recipes-resolver.service";

const routes:Route=[
    {
        path: "recipes",
        component: RecipesComponent,
        canActivate: [AuthGuard],
        children: [
          { path: "", component: RecipeStartComponent },
          { path: "new", component: RecipeEditComponent },
          {
            path: ":id",
            component: RecipeDetailComponent,
            resolve: [RecipesResolverService],
          },
          {
            path: ":id/edit",
            component: RecipeEditComponent,
            resolve: [RecipesResolverService],
          },
        ],
      }
];


@NgModule({
e
})
export class RecipesRoutingModule{}



c) In recipes.routing.module, add the RouterModule in imports 
and call forChild 

eg:
@NgModule({
    imports:[RouterModule.forChild(routes)],
    exports:[RouterModule]
})
export class RecipesRoutingModule{}


d) Now in the RecipesModule, we can import the RecipesRoutingModule

eg:
        imports:[RouterModule,CommonModule,ReactiveFormsModule,RecipesRoutingModule],
		
e) Now after saving we can see the routes are fine in the application



116) So far we have split our application into 4 modules:
1) AppModule 2)AppRoutingModule 3) RecipesModule 4)RecipesRoutingModule

a) Components we load via Routing 
-> Like we specify in the Routes, and the components
were loaded 

eg: recipes-routing.module.ts 
const routes:Routes=[
    {
        path: "recipes",
        component: RecipesComponent,
        canActivate: [AuthGuard],
        children: [
          { path: "", component: RecipeStartComponent },
          { path: "new", component: RecipeEditComponent },
	
b) Recipes component is also declared in RecipesModule

-> Lets remove that declaration in the exports and see if
the app works fine

eg:recipes.module.ts

        declarations:[
//            RecipesComponent,

        exports:
        [
//            RecipesComponent,


-> It does not and Angular throws the Error 
"RecipesComponent is not part of any NgModule or the module 
has not been imported into your module. 


c) Thus its not enough to specify the component in routing
alone, it needs to be spcified in declaration  of the module to load the component 
-> But there is no reason to export the components any more



117) How to create ShoppingList feature module 
a) Create a file shopping-list.module.ts file 
b) Like before, export the class with @NgModule decorator 


eg:
@NgModule({})
export class ShoppingListModule{}

c) Add the ShoppingList related components to declarations
array 

eg:
@NgModule({
    declarations:[    
        ShoppingListComponent,
        ShoppingEditComponent]
}) 

d) Since routing is small for ShoppingList module, lets
have routing part in ShoppingListModule itself
instead of having it in separate shopping list routing module


eg:
shopping-list.module.ts 

e) Here in shopping-list.module, in imports,
Pass Route configs to RouterModule.forChild 

eg:
@NgModule({
    declarations:[    
        ShoppingListComponent,
        ShoppingEditComponent],
    imports:[
        RouterModule.forChild(
            [
                { path: "shopping-list", component: ShoppingListComponent }
            ]
        )
    ]
	
	
f) Here we dont need to export RouterModule,
since we dont have separate Routing module for shopping-list 
module 

g) We also should import the common and Forms module in ShoppingListModule

eg:
   imports:[
        RouterModule.forChild(
            [
                { path: "shopping-list", component: ShoppingListComponent }
            ]
        ),
        CommonModule,
        FormsModule
    ]
 

h) Now go to app module and add the ShoppingListModule
to the imports array 

eg: app.module.ts

  imports: [
    BrowserModule,
    FormsModule,
    ReactiveFormsModule,
    HttpClientModule,
    AppRoutingModule,
    RecipesModule,
    ShoppingListModule
  ],
  
i) THus the feature Modules comes to an end

118) What are Shared Modules?

a) In this sample application, we have two feature Modules 
and an app.module 

ProductsModule:
ModalComponent
DropdownDirective
FormsModule
ProductsComponent

SalesModule:
ModalComponent
DropdownDirective
FormsModule
SalesComponent

b) These two modules differ only in one component :

-> ProductsModule has the ProductComponent and the 
SalesModule has the SalesComponent


c) We can put shared features, directives and even other
modules into a shared Module, which we later import into 
other Feature Module 

-> This avoids code duplication to a larger extent. 



119) How to implement Shared Modules: 
-> In our project -RecipesModule/ShoppingListModule have only
one thing in common i.e. the CommonModule
-> But in application we have more shared contents like
alert, loading-spinner, placeholder and the dropdown directive

-> Therefore in shared folder, we will create: shared.module.ts file 

a) Anything that we declare and import in this 
module is going to be used by other modules
-> But since every module works standalone,  to make these
things available in other modules - we will also export
all these things which we are importing  

b) In shared.module.ts, we add declarations to all
the components that needs to be included in this module;

eg:
    declarations:[
        AlertComponent,
        LoadingSpinnerComponent,
        PlaceholderDirective,
        DropdownDirective
    ]
	
c) Lets assume we also want to share some modules as 
part of shared.module.ts, we can add that as part of 
imports array:

eg:
 imports:[
        CommonModule
    ]
	
d) Since we dont want to use the above declared declarations's components
and imports array modules to be used in shared.module.ts,
but we want to be used or imported in other feature modules,
,
We can add those components/directives in the exports[] array. 

eg:
 exports:
    [
        AlertComponent,
        LoadingSpinnerComponent,
        PlaceholderDirective,
        DropdownDirective,
        CommonModule  
    ]
	
e) So the idea is whenever we import the shared.module.ts 
in other feature modules, we have access to all the features
that were specified in the exports[] array. 
-> if we are not exporting, we would not have access. 


-> THUS FAR WE HAVE CREATED SHARED MODULE. 

120) How to use the newly created Shared Module? 
a) Go to ShoppingListModule and there in imports[] array,
we can replace the CommonModule with SharedModule :

eg:shopping-list.module.ts

  imports: [
    FormsModule,
    RouterModule.forChild([
      { path: 'shopping-list', component: ShoppingListComponent },
    ]),
    SharedModule
  ]
  
-> Thus by adding the SharedModule in the imports,
we will get all the features of SharedModule into ShoppingListModule



121) In the Sameway, in RecipesModule we can do the same
-> Replace CommonModule with SharedModule 

eg:
 imports:[RouterModule,ReactiveFormsModule,RecipesRoutingModule,
        SharedModule],
		
-> Now if we save, we will get error message;

DropdownDirective is part of declaration of two modules
Please consider moving DropdownDirective to a higher module, that imports
SharedModule and AppModule 

LESSON:
You can only define or declare Components, directives and pipes
once 
-> You cant do that multiple times 
-> You can import a module into multiple imports 
i.e you can add in imports array the same Module  to 
RecipesModule and also in ShoppingListModule

---> But this is not ok with Declarations
*****
---> If you declare ShoppingListComponent in ShoppingListModule,
you must not declare it anywhere else, even if it is needed
in another module 
----> The solution is to export the component in the Module where you have declared
and import that module in the another module where you need
that component 

****

-> Hence to over come the error , we need to remove All the
components and directives in the AppModule 



-> SharedModule should be in imports array of AppModule 

122) What are the CoreModules?
-> FeatureModule,SharedModules,CoreModules are all created in same way using @NgModule
--> just what we put in there and how we use them differs with 
different types of these modules 

a) CoreModule:
-> It is there make app module a bit leaner
-> Lets assume we have AppModule which has AppComponent
and it is providing two services: ProductsService and 
AnalyticsService 

-> In that case we can have coremodule to move the services out of the AppModule and move it into the 
CoreModule
-> Then we can add CoreModule as part of AppModule

-> Alternative to this approach is to use providedIn in the services and use them
---> But if we have to add the services to providers in 
AppModule then using CoreModule is  a good idea to keep AppModule leaner 


123) How to implement CoreModule?
CoreModule Idea:
-> We provide all these application wide services in a
separate module 
-> And then import this CoreModule into the AppModule 

a) Create a file: core.module.ts , in providers array, add the services declared in AppModule

eg; 
    providers:[
        ShoppingListService,
        RecipeService,
        {
          provide: HTTP_INTERCEPTORS,
          useClass: AuthInterceptorService,
          multi: true
        }
      

    ]

KEY TAKEWAY ON SERVICES: 	
b) In CoreModule, we need not export our Services
-> This is because Services work differently than declarations 
-> Only declarations and other modules needs to be exported 
-> Services are automatically injected on a root level 

c) Now in the AppModule, to use the CoreModule - we have to import 
the CoreModule 

eg:
  imports: [
    BrowserModule,
    FormsModule,
    ReactiveFormsModule,
    HttpClientModule,
    AppRoutingModule,
    RecipesModule,
    ShoppingListModule,
    SharedModule,
    CoreModule
  ],
  
-> Even though CoreModule does not export anything, but to still 
include it in our build process, we need to import CoreModule into AppModule file 
  
d) Two points to note;
1) This approach is optional
2) Required only if you provide a service in providers 
array of AppModule instead of providing via @Injectable(providedIn:root) - which is the
recommended way for services 


124) How to add an AuthFeatureModule? 
-> We are going to create a new FeatureModule for Auth

a) Create a file:auth.module.ts 

eg:
@NgModule({
    declarations:[AuthComponent],
})
export class AuthModule{}



b) Add imports:

eg:
@NgModule({
    declarations:[AuthComponent],
imports:[CommonModule,FormsModule]
})

c) in AppModule, add the AuthModule 


eg:
  imports: [
    BrowserModule,
    RecipesModule,
    ShoppingListModule,
    SharedModule,
    CoreModule,
    AuthModule
	

d) Also outsource the app.routing.module 

eg:
@NgModule({
    declarations:[AuthComponent],
imports:[CommonModule,FormsModule,RouterModule.forChild(  [{ path: 'auth', component: AuthComponent }])]
})

-> Thus we implemented AuthModule as a separate Feature Module 

125) Advantages of Modules ? 
-> Thus far, we did splitting of app into modules.
-> Modules only makes code leaner and improves maintainability
-> But it does not improve the performance of the application


126) What is Lazy Loading?
-> Using Multiple Feature modules is pre-requisite for lazy loading


a) Consider an application with following 3 routes:

/
/products
/admin 

-> We have a user visiting this page
-> Every route is associated with a module 
/          ---> AppModule/CoreModule
/products  ---> ProductsModule
/admin     ---> AdminModule 


b) Whenever user visits root Route, first module gets loaded 
and we do the same when different routes are visited 
c) At this moment in our project, we dont do lazy loading 
and whenever we visit any page, we load everything 
d) But it will make more sense to load only Products and Admin when we 
visit those pages respectively 
e) Thus lazy loading is loading the code areas, only when we 
need it 

-> In the above example - We will Initially load only the 
root route content - so only the app module code and the code of all the 
components that are registered in app module 
-> We dont load the other modules and only when we visit 
another module like Admin module or Admin route, we load the admin module code and 
the code of all the components of Admin module 


f) Advantage:
-> Initially we download a smaller code bundle and we download more code 
when we need it 
-> But initially our app is able to start faster because it 
downloads and parses less code on the first visit of a certain route 


127) What are the 4 important files in Angular application while loading? 

Upon inspect -> Sources, we will see bunch of files 
a) Of that there are 4 js files:
1) polyfills.js 
-> Polyfills play a vital role in ensuring that your 
Angular application runs smoothly across different 
browsers and versions. They provide modern JavaScript 
features to older browsers that do not natively support
 them
2) styles.js 
3) vendor.js 
-> The vendor. js file is generated during the build process of an Angular application.
-> It contains all the external libraries and dependencies that your application relies on. These can include frameworks like Angular itself, as well as third-party libraries like RxJS, 
Angular Material, or Bootstrap.
4) main.js 
-> The main. js file is the entry point of your Angular application. It contains the 
bootstrap logic that initializes and launches your Angular application.

-> We are in development mode, hence these files are big
-> if we build the same app for production, it will be of smaller size, since it will be optimized 
-> if the code is not optimized, it will contain debug features  


128) How to implement Lazy loading in our project in angular ?
a) Lets start with recipes module 
-> This is because when we are not authenticated, we dont need 
to load the recipes module code 
b) For lazy loading to work, your feature module needs to 
have its own routes 
-> in recipes case, we have route config defined in recipes-routing.module.ts 

c) in routes, we need to change path from 'recipes' to empty ''

eg:
const routes: Routes = [
  {
    path: '',
	
-> We change it to empty path , because we need to add something to AppRoutingModule 
to make lazy loading to work 

d) In AppRoutingModule, we need to add 'recipes' to the path :
-> We add the path here, but we dont add the component here
-> Instead we add a specify property in route config: loadChildren 
-> With this special property: loadChildren, angular understands : Please 
load the code content or the module, only when the user visits 
the path here. 
-> Angular goes to that path and loads the specified object
in the path 

eg:
{
path:'recipes', loadChildren:'./recipes/recipes.module.ts#RecipesModule'
}

e) The effect of the above declaration is that , 
-> Everything that the module uses, will be put into a separate
code bundle - which is then downloaded and parsed on demand as soon as the 
user visits that page 

-> This is achieved by angular CLI, while analyzing the routes with loadChildren while  
building our application and then it analyzes the recipes module 
at which we point in loadChildren 
-> Then it goes to the module and put all the code what we mentioned in declarations and put it in
 separate bundle, which is now built separately detached from our main bundle 
 with which the app starts 

f) For this to work effectively, we need to have all Component Imports only in the specific module:

eg: All Recipes module releated imports should be present only in RecipesModule 
-> This is because for build process considers only what you import at the top of the module 


g) In RecipesRoutingModule it is important to have empty path '', because 
we changed the routeconfig in AppRoutingModule to include the 
path 'recipes" with loadChildren - due to which it will 
load the RecipesModule only when we visit /recipes 

h) Now after saving, we need to restart build process by using: ng serve 

i) The code we used earlier for loadChildren is old

old:
path:'recipes', loadChildren:'./recipes/recipes.module.ts#RecipesModule'

Alternate syntax:
{
    path: "recipes",
    loadChildren: () =>
      import("./recipes/recipes.module").then(m => m.RecipesModule)
  },
  
-> Here in loadChildren we will have anonymous function which
calls import function where module path is passed as 
argument and on successful completion of promise 
-> module is received and using the module object, RecipesModule is 
extracted 

j) now on saving, we will get this error: 
ERROR Error: Uncaught (in promise):
TypeError: undefined is not a function
TypeError: undefined is not a function
at Array.map(<anonymous>)
at WebpackAsyncContext( $_lazy_route_resource_namespace_object:15)
at
SystemJsNgModuleLoader.push./node_modules 


RCA:
In AppModule , we will still import the RecipesModule(
module loaded via loadChildren)
---> by having RecipesModule in import of module,  we loaded 
RecipesModule eagerly and lazily at the same time 

Solution:
Remove the RecipesModule from the imports array 

eg:
  imports: [
    BrowserModule,
    HttpClientModule,
    AppRoutingModule,
    SharedModule,
    CoreModule
  ],

k) Now if we see in network, bundles will get loaded
based on route 


129) How to preload a Lazy-Loaded code ? i.e Optimizing a lazy-loaded code 
-> Right now, we load a code whenever we need it 
Disadvantage of this approach: We may have delay when we try to load the code when we need it 
--> When module is big and when the internet connection is slow, delay will be higher 

SOLUTION:
-> Hence we can tell Angular to Preload lazy loaded modules in order to avoid this delay 

a) Go to Root Router Module(AppRoutingModule), where we configure our root routes and pass a second argument to that
and mark as: {preloadingStrategy:PreloadAllModules} 

eg:
@NgModule({
  imports: [RouterModule.forRoot(appRoutes,{preloadingStrategy:PreloadAllModules})],
  exports: [RouterModule]
})


-> By specifying preloadingStrategy, when we are in different page, it will preload other modules so that we could use it when needed 

Advantage:
1) Initial bundle will still be small , but then when user is browsing the pages, during idle time, we preload additional code bundles 
-> so that additional navigation requests are faster 


130) What is special about  Services and Modules ?
a) Where you can provide services and how it affects the instances of the services 

1) We can provide services in the AppModule OR 
-> Service available Application wide 
2) we can provide services in the AppComponent or other components OR
--> Service available in Component-tree
3) Add services to providers of any Eagerloaded Module OR
-> -> any services you add to providers in Eager loaded module 
will be available application wide 
4) Add services to providers of lazy-loaded modules OR 
-> Service will be available only in loaded Module
 


a) When you provide a service in the AppModule or with
providedIn root @atInjectable 
-> The service is available Application wide 
-> Service's same instance i.e Singleton instance of the Service 


b) If you provide Service in the component, whether AppComponent or any 
other Component,  
--> Service available in Component-tree and
-> Service's same instance i.e Singleton instance of the Service 


c) if you Add services to providers of any Eagerloaded Module
-> any services you add to providers in Eager loaded module 
will be available application wide 
-> Service's same instance i.e Singleton instance of the Service 

 
d) If you Add services to providers of lazy-loaded modules 
*********
-> Service will be available only in loaded Module and it
gets its own instance 
-> if you provide a Service both in AppModule and Lazy loaded module 
then service will be available application wide 
----> But the lazy loaded module will get a separate 
instance 

REASON
1) The Reason for this is: When you do service in Provider array  in 
AppModule or @Injectable -> We use Root Injector i.e Root Dependancy Mechanism of angular 

2) WHen you provide it in a component - we use Component specific injector 
3) When you provide service  to providers of eager loaded Module
-> We use root injector 
4) When we add services to providers of lazy loaded module 
-> we use a separate child Injector which is provided by Angular for that Module 
-> Therefore that module will have its own instance of that service 


USAGE:
1) Default should be to use the AppModule or providedIn root @Injectable case a)
2) Use b) Only if service is relevant for a component tree
3) Avoid case c) 
4) Use d) only if you deliberately want to have separate 
instance of that service there. 
-> use if service should be scoped to loaded module 

GENERAL RULE ON SERVICES:
a) Ensure services are available application wide using Provider or @injectable root 
b) Only if you have strong reason use b)  or d) and never use c)


131) What are the steps for Deployment of Angular Application :


a) Use and Check environment variables :
b) Polish and test code 
c) Build your application for production using: ng build --prod 

-> Uses Ahead of time compilation 

>>>>>
1) Run a command that takes all your typescript code, 
2) compiles it to Javascript, 
3) then bundles all your code together
4) translates it into angular language - so that angular renderer can work with it in 
the browser and 
5) optimize it to be as small as possible 
-> Because the application has to be downloaded by 
every user using your website 
-> Hence it should be as small as possible 
>>>>>


d) Deploy the build artifacts(generated files) to a 
static host 

Static Host - Web server capable of serving html, Javascript 
and CSS 

-> But static host is not capable of running any server side language 
like php or node js because you only need html,js and css


132) How to Use Environment Variables?
->Assume our code is already optimized and tested properly 
-> Now lets deploy the application 

a) In source->environments 
-> we will have two files : environment.ts and environment.prod.ts 
b) In environment.ts, we will have constant defined:

eg:

export const environment = {
  production: false
};

c) We can add key value pairs . since we are using api key,
we can store that api key in environment.ts,
import that environment constant into your files to use 
that API key 

d) Angular CLI automatically swaps these two files, when you are building for 
production 
e) So for development, environment.ts will be used for 
production, environment.prod.ts will be used 

132) How to use API key through Environment Variables?

a) Add the key value pair in environment.ts  for firebaseAPIKey

eg:
export const environment = {
  production: false,
  firebaseAPIKey: 'AIzaSyAETvw1FH6Vc5aR8gRIAwIA7iofso0xkmY'
};

b) Copy the same to environment.prod.ts file 

eg:
export const environment = {
  production: true,
  firebaseAPIKey: 'AIzaSyAETvw1FH6Vc5aR8gRIAwIA7iofso0xkmY'
};

c) Now with the keys added, we can go to AuthService and import these 
environment values 

d) in auth.service.ts, import environment constant 

eg:
import { environment } from 'src/environments/environment';

-> this will automatically fetch the right value from the right file, based on the
environment during build 


e) Use the constant in the function we needed: auth.service.ts 
by using: environment.firebaseAPIKey,

eg:
 signup(email: string, password: string) {
    return this.http
      .post<AuthResponseData>(
        'https://www.googleapis.com/identitytoolkit/v3/relyingparty/signupNewUser?key='+environment.firebaseAPIKey,
        {
          email: email,
		  
f) Now will be able to signup and signin using the firebaseAPIKey 
provided in environment.ts file 


133) What are the commands for building Angular applications
-> Angular apps can be built for deployment by running ng build. 
-> In older versions, you had to run ng build --prod - this is now longer required though.

134) What does ng build do?
a) It compiles Typescript code in code base to Javascript
b) Compiles all the html files to Javascript instructions , so at the end only javascript code is generated 
c) JavaScript code that runs in browser, contains all the logic for updating the DOM in the way you defined multiple components 
d) This is all done by the bundled up application , which takes advantage of the angular framework 
e) after running ng build, we get the dist folder  and inside you have a folder of your project name:ng-complete-guide-update

-> Here ng-complete-guide-update is the project name 

C:\ExpoNow\maheangularprojects\Dec3_auth-05-added-token-to-requests\dist\ng-complete-guide-update


f) Inside the project name folder, 
a) you have bunch of assets you have included in your project
b) main.js
c) polyfills.js
d) runtime.js 
 
 and a couple of other js files which contains your javascript code which is your angular app code in optimized form 
 
 
In the index.html in dist\ng-complete-guide-update\index.html
-> we can find runtime.js, polyfills.js , main.js being included 
-> All these script imports make the application that started 

eg:
  <meta charset="utf-8">
  <title>Angular - The Complete Guide</title>
  <base href="/">

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" type="image/x-icon" href="favicon.ico">
<style>html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}@media print{*,:after,:before{color:#000!important;text-shadow:none!important;background:0 0!important;box-shadow:none!important}}*{box-sizing:border-box}:after,:before{box-sizing:border-box}html{font-size:10px;-webkit-tap-highlight-color:rgba(0,0,0,0)}body{font-family:Helvetica Neue,Helvetica,Arial,sans-serif;font-size:14px;line-height:1.42857143;color:#333;background-color:#fff}</style><link rel="stylesheet" href="styles.css" media="print" onload="this.media='all'"><noscript><link rel="stylesheet" href="styles.css"></noscript></head>
<body>
  <app-root></app-root>
<script src="runtime.js" type="module"></script><script src="polyfills.js" type="module"></script><script src="main.js" type="module"></script>

</body></html>

-> Now we need to deploy: ng-complete-guide-update and its contents 


134) How to build and  Deploy Angular application using Firebase hosting?

a) Now with our Deployable ready, we need a 'static website host' to deploy our application 
-> we are going to use firebase as statis website host to deploy the application 
b) first install firebase-tools in your local :
npm install -g firebase-tools               

if linux: npm install -g firebase-tools               


eg:
PS C:\ExpoNow\maheangularprojects\Dec3_auth-05-added-token-to-requests> npm install -g firebase-tools

c) login to firebase using command : firebase login
d) run cmd: firebase init 
-> to connect this project here in local to one of your firebase projects 
-> for that you should be in your angular project:
in our case we should be in : C:\ExpoNow\maheangularprojects\Dec3_auth-05-added-token-to-requests>
e) firebase asks which firebase feature you want to use: 
select: Hosting: Configure and Deploy firebase hosting sites 


f) select your project 
g) It will ask : what do you want to use as your public 
directory: 
-> Public directory is the directory that contains all your files that you 
want to deploy 

so in our case we should give: dist\ng-complete-guide-update\

h) Then it will ask if you should create this as a single page app and you 
should choose Y 
-> this ensures that all requests that are sent to backend are redirected to 
index.html 
-> We need to have a server configured, that always serves index. html no matter which url you entered into the 
browser 


i) Any request will reach the server first. 
-> So any request should reach the server first 
-> There they are redirected to index.html which is the 
starting point of our single page application 
-> since any rquest reaches that page, now the angular application 
can take over for any incoming request with any url on your server 
-> And then case use the angular router to load the correct 
content in your angular app 
-> Hence this redirection is important 

j) will ask for overriding. Existing html should not be
overwritten , hence we should choose no 

k) Last step is to run the command: firebase deploy 
-> this will now deploy the content of this folder into firebase 

l) Once it is done, it will give you an url, where you can 
find your application 

m) if we use that url and hit it, we will be into our application now 

n) it will work the same way it worked locally, but now it will run on 
the firebase server 


135) 
Server Routing vs Browser Routing
When deploying your Angular app, it's really important to make sure that your server (like S3) is configured to always serve the index.html file.

Here's why: https://academind.com/tutorials/angular-q-a#how-to-fix-broken-routes-after-deployment

136) What are standalone components:
---> Standalone components are components that work without modules 

a) Feature introduced in Angular 14 in preview mode 
b) Standalone components to get rid of ngModule 

-> Standalone components are regular Angular components with one important twist:
they dont require a @NgModule as a wrapper 
-> Standalone components define their own dependencies and can be imported 
and used anywhere. 

Problem with Standard Angular Apps:
-> Lot of boiler plate code 
-> you specifically have to add all these modules like AppModule or SharedModule to 
organize and declare your directives 
-> Angular needs to know the modules internally. It needs 
to know which components are available in which other component 
and so on 


137) How to build a standalone component? 
a) Build a regular component
b) Add a special property flag to the @Component decorator
-> standalone: false is the default value and need to be added.
-> if standalone:true, then this property sets this component
 to be standalone component 

@Component(
{
standalone:true
selector: 'app-details',
templateUrl: './details.component.html',
...
})
})

c) Marking standlone:true, internally changes many things 
-> Because this component can be used in other components, without declaring it ,
but still we need to make angular aware of it. 

d) If standalone is set to be true, it should not longer be part declared in 
declarations array of any ngModule 

e) To make angular aware of the standalone component you created,
go to the component that uses this component and add
imports: property 
-> In imports we need to point to standalone component 

eg:
@Component(
{
imports:[DetailsComponent]
selector: 'app-welcome',
templateUrl: './welcome.component.html',
...
})
})

-> One standalone component can be used in multiple components 


e) Also a standalone component can be used in another standalone component only 

f) Standalone components can be combined with @NgModules, so that we can migrate to 
standalone components in a smooth way 
g) To use a standalone component in various components that 
make up a module - all you have to do is , go to that module 
and instead of add the standalone component to the declarations array ,
we need to add it to imports array 
-> Imports in the past is used to add only other modules 
-> But now even standalone components can be added to imports array 

eg:

@NgModule({
@declarations: [AppComponent, WelcomeComponent],
imports: [BrowserModule,SharedModule,DetailsComponent],
providers: []
bootstrap: [AppComponent],

})


g) In standalone components, we not only can import standalone components,
but we can import other modules as well.

eg:
Component({
standalone: true,
imports:[SharedModule],
selector: 'app-details',
templateUrl: './details.component.html',
...
})
})

-> This helps in smooth migration process. 


138) Just like Components, directives and pipes also can be made 
standalone.

eg:
@Directive(
{
standalone:true,
selector: '[appHighlight]',
})

a) When directive is converted to be standalone, it should be 
part of  declarations[] array  of any module 
b) In another standalone component, where this standalone directive is used, we should add as part of imports [] array.

eg:
@Component({
standalone:true,
imports: [HighlightDirective],
selector: 'app-details',
templateUrl: './details.component.html',
....
})

})

c) THUS IF WANT TO USE STANDALONE COMPONENTS/DIRECTIVES, We
SHOULD EITHER IMPORT THEM INTO ANOTHER MODULES OR SPECIFY AS IMPORTS IN ANY OTHER STANDALONE 
COMPONENT 

139) How will you migrate RootComponent(AppComponent) into a 
standalone component ?

a) We also have to change our bootstrapping code in main.ts
b) Since we dont bootstrap module, we need to bootstrap component 

COde earlier:which is removed in main.ts
platformBrowserDynamic.bootstrapModule(AppModule).
catch(err=> console.error(err));

b) Now in main.ts we need to call bootstrapApplication() method and pass pointer 
for our root component 

eg:
bootstrapApplication(AppComponent); 
c) Now the application on save, works without any error 

d) Thus by this approach we can get rid of the app.module now 


140) Services and Standalone Components: 

-> In standalone component, we can add the provider's property 

to the component's decorated object 
-> In providers's array we can specify the service

eg:
Component({
standalone: true,
imports:[SharedModule],
selector: 'app-details',
templateUrl: './details.component.html',
...
providers:[AnalyticsService]
})
})

-> so this another way of providing services 

DIFFERENCE:
-> Now if you add a service to component like this, every 
component gets its own object 
-> So if you use the same service for multiple instances of a component, 
you get multiple instances of that service as well and there is 
no shared state 


a) if your application does not contain modules and if you dont want to 
declare service via @Injectable provided in:root, you can 
do in main.ts via bootstrapApplication
b) by this you can add a globally provided service 

eg:
boostrapApplication(AppComponent, {
providers:[AnalyticsService]
}) 



141) How to do Routing with Standalone Components ? 
a) if AppComponent is standalone component, we need to make 
AppComponent aware of Router 
b)  RouterLink and RouterOutlet in template is not known to angular 
if RouterModule is not there 
c) Just like CustomComponent, we need to impor tthe RouterModule in the imports array 
of standalone component 

eg;
@Component(
{
standalone: true,
imports: [WelcomeComponent, RouterModule ],
selector: 'app-root',
templateUrl: './app.component.html',
styleUrls: ['/app.component.css']
})


d) Still to make angular aware of the Routes, we need to go to 
main.ts and in bootstrapApplication, we need to use 
special providers function: importProvidersFrom 
-> this change makes our standalone root component aware of the 
routes and thus making overall angular application aware of the routes 

eg:
boostrapApplication(AppComponent, {
providers:[
//AnalyticsService
importProvidersFrom(AppRoutingModule)
]
}); 


142) LazyLoading in Standalone components
-> use loadComponent: 

eg:
path: 'aout',
loadComponent:()=> 
import('./dashboard/dashboard-routing.module').then((mod)=>
mod.DashboardRoutingModule),

143) What are Signals in Angular?
-> Developer Preview feature in angular16
-> Will be added in Angular 17 

a) Signals are new way of handling data changes 
and updating the UI 

b)  Without signals, angular relies on classic change detection for checking 
whether data changed and UI should be updated 
-> That classic change detection is also called Zone based change detection 
-> This is because classic change detection algorithm uses Zone.js 

c) Advantage of classic change detection:
1) Changes detected automatically
2) UI updated automatically 

d) Disadvantages of classic change detection:
1) Performance could be beter
2) Bundle size is increased because of zone.js library 


e) SIGNALS:
1) Alternative way of managing and detecing those changes 
2) Allows angular to get rid of extra library : zone.js 
3) Allows angular to stop watching entire application and 
therefore can lead to better performance and a smaller bundle 
4) With signals - No automatic change detection and only
developer tells angular when data changes
5) Angular updates only parts of the UI when the data('signal') is changed 

6) Developer has slightly more work, but full control, better 
performance and smaller bundle 

144) How to Create a new signal? 

a) Current state of the component is:

eg:
import { NgFor } from '@angular/common';
import { Component } from '@angular/core';

@Component({
  selector: 'app-default',
  templateUrl: './default.component.html',
  standalone: true,
  imports: [NgFor],
})
export class DefaultComponent {
  actions: string[] = [];
  counter = 0;

  increment() {
    this.counter++;
    this.actions.push('INCREMENT');
  }

  decrement() {
    this.counter--;
    this.actions.push('DECREMENT');
  }
}

b) Now to turn the counter into a signal, import signal  

eg:
import { Component,signal } from '@angular/core';

c) Create signal Object
-> Signal objects are wrappers around data, that 
can tell angular once you changed the data 
-> It can be used by angular, to find out 
where in your application and in your UI  
you will be using those values, so that angular can know which 
part needs to be updated 
--> to pass initial value to counter,we pass initial 
value to signal object 


eg:
  counter = signal(0);
 
 
145) How to update a signal value? 
-> Angular provides three methods to update signal 
values:
A) set() B) update() C) mutate() 

a) update()
-> here update will receive old value in function and 
in the function, you should return the new signal value 

eg:
this.counter.update((oldCounter)=> oldCounter+1);

this.counter.update((oldCounter)=> oldCounter-1);

146) How to Read and Output a signal value in html?
-> When using signals, we need to execute signal based values as a 
function, hence counter has to be executed as a function
-> A function that can be executed in the places, where 
you need that signal value 

From:
  <p id="counter-output">Counter: {{ counter }}</p>
  
To:
  <p id="counter-output">Counter: {{ counter() }}</p>
  
  

147) Signal updating: set(), update() and mutate()

a) set()
-> set unlike update does not take a function, set simply 
takes the new value 

eg:
this.counter.set(5);

-> if the new value has to be based on the old value,
then we have use update or when using set, you should get access to 
the old value first 

-> mutate is removed from angular17 
-> mutate to help update mutatable data structures like 
arrays, objects etc 


148) What are computed() function in signals? 

a) computed() function: 
-> computed() takes a function as a value , function here 
does not take any input, but it returns a value 
-> its typically a value based on other signals 
-> eg we read a counter signal and multiply it with 2
-> computed exists to create an easy way of creating well computed values 
i.e values that depend on other signal values 
-> In our case, doubleCounter will be updated by 
angular, whenver this counter signal changes 

eg:
doubleCounter= computed(()=> this.counter()*2);

b) later doublCounter should be used in html like signal

eg: 
  <p id="counter-output">Counter: {{ doubleCounter() }}</p>


149) What is effect() function in signals?

-> effect is function that could be executed in the 
constructor, though we are not limited to the constructor 
-> it could also be used in other places like ngOnInit() 
-> Just like computed takes a function as a value , effect also 
takes a function as value 
-> in this function we can also use signals, but the idea
behind effect is not to produce a value , but instead  TO RUN A 
CODE WHENEVER THE SIGNAL CHANGES 
-> for eg: here we console log the the current counter 
value 

eg:
constructor()
{
effect(()=> console.log(this.counter()));
}

-> Angular will execute this effect(), whenever the value of counter signal 
changes 


149) What is NgRX: 
-> Complex state management library
-> 3rd party package you can add to your angular projects 

-> We can install this package in our application to get some 
help on manage your application wide state 
-> Aims to help with the management of more complex, 
(app-wide) state 

a) what is state:
-> State is the data that's used in one or more
components in your application, that typically changes over time( eg: because of 
button being clicked) 
-> And the data changes should be reflected in UI 
b) so far, we have managed a lot of state by:
1) directly in a component by storing some data in 
a property , which when got changed by clicking a button for eg:
2) Or if data is needed in multiple components, we stored 
some data with the help of a service, changed 
it from component A and then may be used it in component B using behaviour subject 


150) Understanding NgRx and its building blocks
-> NgRx is state management solution, a library that 
helps with managing state data in your application 
-> Library that gives you a clearly defined way of managing application state
--> APPROACH:
a) STORE:
Starts with creating a data store or state store 
-> This is where your data is stored and managed 
-> Place where components will reach out to read the data
and listen to data changes and update UI 

b) SELECTORS(optional):
-> For reading and extracting data from the store - selector is 
used. 
-> Using selector components can get the globally managed state data 
->NgRx is the central store that manages all the data 
used in your entire application 
-> Components can change data, when button was clicked or 
a form is submitted 
-> NgRx gives a clearly defined standardized way of performing data changes 

c) ACTIONS:
-> To change data, Components must dispatch ACTIONS
-> Actions are standardized messages(Events) to which 
reducers can listen 

d) REDUCERS:
-> Actions are picked up by REDUCERS
-> Reducers contains state changing logic(eg: Increment counter by 1) that gets triggerred
based on those actions to change the data in the 
store 

e) EFFECTS:
-> Side effects that should be triggered for certain 
actions( eg: send HTTP request) 


151) How to Install NgRx and do Project setup: 

a) In terminal install NgRX using the command: 
 ng add @ngrx/store 
 
 eg:
PS C:\ExpoNow\maheangularprojects\dec16-01-starting-setup> ng add @ngrx/store  
ℹ Using package manager: npm
✔ Found compatible package version: @ngrx/store@16.3.0.
✔ Package information loaded.

The package @ngrx/store@16.3.0 will be installed and executed.
Would you like to proceed? Yes
✔ Packages successfully installed.
UPDATE src/app/app.module.ts (611 bytes)
UPDATE package.json (1070 bytes)
✔ Packages installed successfully.
PS C:\ExpoNow\maheangularprojects\dec16-01-starting-setup> 


b) As part of the installation, AppModule will be modified, where imports 
array will StoreModule.forRoot({}


eg:

import { StoreModule } from '@ngrx/store';

  imports: [BrowserModule, StoreModule.forRoot({}, {})],


c) This line of code is responsible for setting up a 
store in the application 

  imports: [BrowserModule, StoreModule.forRoot({}, {})],
  
  
152) How to add Reducer and register reducer in NgRx
-> Time to add data to NgRx store
-> Where the data can be used in components 
eg: in counter-output.component -> we will read data from 
that store 
-> To get data in the store, we need a reducer 
i.e reducers change the data in store and also 
sets the initial value in store 
-> Thus Reducers helps to get some data from 
store or change the data in the store 

a) Create a new folder store and create a file 
counter.reducer.ts file 
-> This reducer manages data that belongs to counter part of the 
app here 
-> reducer is nothing but a function, that 
takes some data as input and spits out the updated 
counter state 


eg:
import { createReducer } from "@ngrx/store";

const counterReducer = createReducer()

b)createReducer() function needs the initial state of 
of that piece of global store 
-> When using NgRx anything can be your state
-> It an be a number, text(string), boolean, array 
 or an object  
-> This function will be executed whenever an action occur 
or when it initially sets up the store 
-> i.e -> This function counterReducer will be executed 
by NgRx when it first creates the store 

eg:
const initialState=0;

export const counterReducer = createReducer(initialState);

--> Thus we created a Reducer with an initial state 


c) Add the counterReducer to the imports[] array of 
app.module

eg:
  imports: [BrowserModule, StoreModule.forRoot({counter:counterReducer}, {})],
  
  
153) Alternate way of creating reducers; 
-> this is for older versions of NgRx 

a) Create reducer function which has the 
current state as argument 
-> this function will be later be executed 
by NgRx 
-> It will be executed whenever an action occur 
or when it initially sets up the store 

eg:
export function counterReducer(state=initialState)
{
    return state;
}
  
-> This function counterReducer will be executed 
by NgRx when it first creates the store 

154) How to read Data from the store in NgRx? 
-> In CounterOutputComponent, we need to output 
the currently stored counter in the template 
of this component 

a) To do that, in the CounterOutputComponent,
inject the Store in the constructor 

eg:
  constructor(private store:Store) {}
  
-> The store injected here is the globally managed 
store
-> We are able to use the store, because we have 
mentioned in the imports array as StoreModule

eg:
imports: [BrowserModule, StoreModule.forRoot({counter:counterReducer}, {})],


b) We declare a property which stores an observable 


eg:
count$: Observable<number>;

if we declare a property name with $ sign, it means 
we store an observable, and this is only by convention 

c) We can set this observable in the 
constructor 
-> Here the select() method, allows to select 
data from the store 
-> in the select we will pass the key, that identifies 
the data you want to select 
-> The key will be key which we used to store the reducer in 
app.module.ts 
eg:app.module.ts 
imports: [BrowserModule, StoreModule.forRoot({counter:counterReducer}, {})],


eg: CounterOutputComponent
  constructor(private store:Store<{counter:number}>) {
this.count$= store.select('counter');
  }


d) When selecting values using store.select, we 
are not getting the values themselves, instead 
we are getting an observable 
-> Advantage of having the count$ as observable is that it automatically 
updates, whenever the data in the store changes 

-> to do that, we can use a special pipe provided 
by Angular : async pipe
-> async pipe: sets an automatic listener to this observable, which
 updates this part of the UI 
 
eg: counter-output.component.html
<p class="counter">{{ count$ | async }}</p>

e) Thus by using async pipe we can listen to 
an observable in the tempate and get the latest value
and update the value in UI whenever the value changes 
 
f) Thus until now: we are able to read data from the store , add some initial data to the 
store and output the data to the screen 

155) Introducing Actions and state changing 
reducers :  

Actions: Standardized messages(events) to which reducers 
can listen 

a) Add a new file counter.actions.ts
-> actions file defines that actions that can 
be dispatched in this application 
-> in this application, we need an incrementing action for increasing the counter by 
1 

b)Here '[Counter] Increment' is the action identifier 

eg:
export const increment=createAction(
'[Counter] Increment'
);

Thus the action is created

c) Now the action created will be used in 
the Reducer function 
-> in the reducer function we will be listening to that action 
-> in createReducer we will add the second 
argument to createReducer after the initial state 
-> The second argument will be a value that is 
created with the help of another function provided by 
NgRx store : on() function 
-> on() needs two arguments, action: increment action 
in our case and second value will be a function  which will 
be executed whenever the action occurs and this 
function receives the current state of reducer 
and updates the state 
-> you should not directly change the existing state, but should produce 
a new state 
-> this will be used by NgRx as the new state for the 
data that is managed by the reducer 

eg:
export const counterReducer = createReducer(
    initialState,
    on(increment,(state)=> state+1));
	
	
-> Thus so far we listened to the action and 
defined what needs to be executed when the action 
occurs 


156) Despatching actions 
-> One missing piece needs to be done for action to occur 
-> That happens in counter-controls component 

a) Inject the NgRx store in counter-controls component 
  constructor(store:Store)
  {}
  
b) In increment() use the injected store object to 
call built-in dispatch method 
-> Earlier we used select for selecting data and now
we use dispatch  to dispatch an action 
-> We need to pass an identifier of action to dispatch method 
and we need to execute increment() like a function 

eg:
import {increment} from  '../store/counter.actions'

  increment() {
    this.store.dispatch(increment());
  }
  
-> increment is not executed when we use createReducer, where we only
pass the reference, but here we execute it 
-> But increment is executed when we dispatch 

---> Thus we defined an action in counter.actions.ts -> increment-> createAction 
listen to it in  reducer createReducer and execute the function 
 and execute/dispatch it in  CounterControlsComponent

-> Now if we do ng serve, we can see increment operation is done
successfully 

157) How to add data to actions 
a) createAction() in counter.actions.ts will be 
able to take second argument which describes the kind of data
which we want to add to actions 
-> it is done with the help of props function 

eg:
import { createAction, props } from "@ngrx/store";

export const increment=createAction(
'[Counter] Increment',
props<{value:number}>()
);


b) To extract this action, you go to reducer and add the action as 
extra agrument and use the action's value

eg:
export const counterReducer = createReducer(
    initialState,
    on(increment,(state,action)=> state+action.value));

c) Now in the CounterControlsComponent, we should pass the data 
 that should be attached to the action, when calling the 
action as a function inside of dispatch  
-> and we pass value as 2 to increment

eg:
  increment() {
    this.store.dispatch(increment({value:2}));
  }
  
d) Now if we run the applicaiton using ng serve, we can see values 
incremented by 2  
  
  
158) How to Handle actons without createReducer 
-> Until now we learnt about how to 
define reducer and its alernative way of defining 
reducer 

eg: 
export const counterReducer = createReducer(
    initialState,
    on(increment,(state,action)=> state+action.value));

// export function counterReducer(state=initialState)
// {
//     return state;
// }


-> commented counterReducer is the alternative approach 


a) Lets redefine the counterReducer, using the syntax  defined in 
alternative approach i.e without using createReducer 
-> We will do the same for action and build action  without 
createAction 

/* export const counterReducer = createReducer(
    initialState,
    on(increment,(state,action)=> state+action.value)); */

export function counterReducer(state=initialState, 
    action:any)
{
    if(action.type ==='[Counter] Increment')
    {
        return state + action.value;
    }
    return state;
}

-> on saving it works again in UI
-> Thus we are using counterReducer without using 
createReducer 

159) Alternate way of defining actions: 
-> Instead of defining actions using createAction:

/* export const increment=createAction(
'[Counter] Increment',
props<{value:number}>()
); */


-> We can create our own function which when called generates 
an action object
-> This is because createAction  which is stored in increment is just a function which 
returns an object with a type and value property 
-> We will rebuild it without using createAction here 


a) A common way of rebuilding a function that generates objects in javascript is,
to use a class 

eg:

export class IncrementAction implements Action{
     readonly type:string = '[Counter] Increment'; 
     
     constructor(public value:number) {
        
     }
}

b) Now in CounterControlsComponent, instantiate the class and 
pass the value to it like this 


eg:
from:
  increment() {
    this.store.dispatch(increment({value:2}));
  }
  
  
to:
  increment() {
    this.store.dispatch(new IncrementAction(2));
  }


c) defining action as a type: counter.actions.ts 

export type CounterActions =IncrementAction;

-> now we can use type CounterActions, which is group 
of all actions related to counter a type instead of any in counter.reducer.ts 

eg:

from:
export function counterReducer(state=initialState, 
    action:any)
{
    if(action.type ==='[Counter] Increment')
    {
        return state + action.value;
    }
    return state;
}

to:
export function counterReducer(state=initialState, 
    action:CounterActions | Action)
{
    if(action.type ==='[Counter] Increment')
    {
        return state + (action as IncrementAction).value;
    }
    return state;
}

160) How to define multiple reducers 

eg:

export const counterReducer = createReducer(
    initialState,
    on(increment,(state,action)=> state+action.value),
    on(decrement,(state,action)=> state-action.value)
    );
	
	
	
161) What are selectors?

a) How we selected values earlier 

we can select data from the store like this: CounterOutputComponent, using the select method 

count$: Observable<number>;
this.count$= store.select('counter');

-> we use the select method and we select the entire state 
slice and here in our case it is only the counter number 
-> in this.count$,we get an observable and we listen 
to that observable in template via aysnc pipe 

eg:
<p class="counter">{{ count$ | async }}</p>

b) Now we have alternative or additional way of selecting 
values: 
c) Add a new file counters.selectors.ts 
-> A selector in its simplest form is a function 
that could be stored in a constant,selectCount here for example 
-> This select function gets the state value, which is the
overall NgRx store state
-> Hence the shape of the state is the shape of the overall store 
-> Here in our demo application, that would be an object that 
has all the keys you defined, when you register the 
store undert imports array of app.module.ts 

eg:
  imports: [BrowserModule, StoreModule.forRoot({counter:counterReducer}, {})],
  

-> Under those keys, we can find different values stored 
for the different state slices 
-> Here counter is the value which is a number


const selectCount=(state:{counter:number})=>

-> if you have more keys we can addi it to the type,  as java script 
object 
-> In the arrow function, we just return the value you 
want to select 

eg:
export const selectCount=(state:{counter:number})=>state.counter;
 
 
-> This is the definition of a selector 

c) The selector thus defined can be used in other parts of the app like 
inside of other services or components where you need 
data from the store 

-> eg, here in CounterOutputComponent we can use the selector 
selectCount function which we defined earlier 

eg: CounterOutputComponent 
this.count$= store.select(selectCount);


162) What are effects in NgRx? 
Effects: 
Side effects that are triggered for certain actions
eg: Http Requests 

SIDE EFFECT or Effects:
-> Anything thats not related to an immediate UI 
update 

eg: if you change a value at one end and then UI gets updated right away
then there is no side effect 

-> But if you send HttpRequest, or store in localStorage or 
log to the console - these things will be considered as 
side effects 


a) Why should you be aware of side effects in NgRx
-> To avoid them in reducers, because Reducer state 
changing functions should be synchronous 
-> hence sending HttpRequest in reducer should not be 
done 
-> promises or async await should not be used 
in reducers 
-> instead whatever we define in reducer should be 
pure synchronous functions 

eg: 
export const counterReducer = createReducer(
    initialState,
    on(increment,(state,action)=> state+action.value),
    on(decrement,(state,action)=> state-action.value)
    );
	
b) Hence we handle httprequests, console logging etc in Effects 


163) How to insall NgRx effects package? 
a) Install the command to install NgRx effects:
eg: 
PS C:\ExpoNow\maheangularprojects\dec16-01-starting-setup> ng add @ngrx/effects

b) This installation adds EffectsModule in AppModule

eg:
imports: [BrowserModule, StoreModule.forRoot({counter:counterReducer}, {}), EffectsModule.forRoot([])],

c) In our application, whenever counter gets changed
we shall save the updated counter in local storage 


164) How to define a effect
-> We are going to store the counter value in local storage whenever 
it gets changed 

a) Add a new file in store folder: counter.effects.ts
b) Create a class Counter Effects and define property 
which in the end defines one pipeline.
-> Pipeline should be executed for certain functions 
-> Define a constructor to inject something into 
CounterEffects class
eg: 
 constructor(private actions:Actions)
 {}

-->  We use createEffect() function 

eg:
export class CounterEffects{

 saveCount= createEffect(
    ()=>this.actions$.pipe()
 ) ;

 constructor(private actions$:Actions)
 {}
}

c) pipe the first action :ofType 
-> ofType defines for which actions we want to 
execute some code 
-> this is because here this.actions$ yields a new 
value, which we can handle whenever anywhere in our 
application an NgRx action is dispatched  
-> this.actions$ emits a new value, whenever anywhere in the 
app, an action is dispatched  
-> Using the ofType() operator we can filter those 
dispatched actions and decide for which actions, we wanted to 
continue in this pipeline 
-> ofType takes the action identifiers as inputs 
Here we use increment action 

eg:
export class CounterEffects{

 saveCount= createEffect(
    ()=>this.actions$.pipe(
        ofType(increment),
    )
 ) ;
 
-> if dispatched action is increment, we can also pass more than one value 
to ofType to listen to multiple actions. Eg decrement 
action here 

eg:  saveCount= createEffect(
    ()=>this.actions$.pipe(
        ofType(increment,decrement),
    )
	
 
d) We use tap operator of RxJs to console log and store count to 
local storage:

eg:
 saveCount= createEffect(
    ()=>this.actions$.pipe(
        ofType(increment,decrement),
        tap((action)=>{
            console.log(action);
            localStorage.setItem('count',action.value.toString())
        })
    )
 ) ;
 
 
e) So far the action pipeline defined like this does not 
dispatch a new action, we need to create second argument to 
create effect 
-> we need configure dispatch property to false , makes sure 
that the effect we defined does not dispatch a new 
action when it is done 

eg:
 saveCount= createEffect(
    ()=>this.actions$.pipe(
        ofType(increment,decrement),
        tap((action)=>{
            console.log(action);
            localStorage.setItem('count',action.value.toString())
        })
    ),
    {dispatch:false}
 ) ; 
 
f) Thus our first side effect is defined 

165) how to Register a effect?

a) In AppModule, add the CounterEffects in 
imports array :

eg:
  imports: [BrowserModule, StoreModule.forRoot({counter:counterReducer}, {}), 
    EffectsModule.forRoot([CounterEffects])],
	
c) CounterEffects class should be decorated with 
@Injectable decorator 

eg:
@Injectable()
export class CounterEffects{


d) Now if we save and do ng serve, we can see the console lo getting printed na dthe localstorage  gets 
populated , based on the effects we defined earlier 

166) How to use storeData in effects 
a) We got our first effect.
b) Lets improve it by making sure we dont store the value, 
by which the counter changed in localStorage, but instead 
the latest counter value thats stored in our NgRx store 
c) Latest value in store could be obtained by using 
special operator: withLatestFrom 

eg:
-> constructor 
 constructor(private actions$:Actions, private store: Store<{counter: number}>)
 {}

-> we select values from selectCount selector 

eg:
   import { selectCount } from "./counters.selectors";
   
   withLatestFrom(this.store.select(selectCount)),
   
   
c) Now after addin withLatestFrom, we get different data 
i.e an array with two elements  for tap operator 
-> Hence we need to use array destructuring here, 
to pull those two elements out of the array 
-> The first element will be an action  and the second 
element will be the data, which we merged into this 
array 


eg:
 saveCount= createEffect(
    ()=>this.actions$.pipe(
        ofType(increment,decrement),
        withLatestFrom(this.store.select(selectCount)),
        tap(([action,counter])=>{
            console.log(action);
            localStorage.setItem('count',counter.toString())
        })
    ),
    {dispatch:false}
 ) ;

-> thus we get the value stored in our NgRx store  and use 
this value in our effect pipeline 

-> Thus on saving and ng serve we get the updated value in local storage 


167) How to add a second effect in NgRx which loads the 
data from local storage? 
a) This is an effect should dispatch a new action once its done 
-> A new action that will take that counter that was 
extracted from local storage and store it in our NgRx store 
-> Hence when we reload the app , we continue with the 
counter we stored before 
b) To make this work, we need to add two new 
actions 
i) init - to trigger the side effect pipeline and loads data 
from it 
ii) set - to be dispatched once the side effect is done 
 

eg:
export const init = createAction(
     '[Counter] Init'
);

export const set = createAction(
     '[Counter] Set',
     props<{value:number}>()
);

c) In reducer, add another on branch to it 

eg:
    on(set, (state,action)=>action.value),
	
	
c) To add the logic for this, in CounterEffects - add a new 
property loadCount 

   loadCount = createEffect(()=>
    this.actions$.pipe(
        ofType(init)
    ))

-> in loadCount, we want to load counter from local storage,for which we will use switchMap operator 
of RxJs
- switchMap operator allows us to switch to a new observable 
chain where we start by getting some value from localStorage 
-> the new value that we should return in switchMap should be the new 
observable which in the end is wrapped around an action which we want to 
dispatch 

-> of() is an RxJs operator, which is simply a function which we can execute 
to wrap it around a value , which will then be wrapped into an 
observable 

eg:
export class CounterEffects{

    loadCount = createEffect(()=>
    this.actions$.pipe(
        ofType(init),
        switchMap(
            ()=> {
    const storedCounter = localStorage.getItem('count');
    if(storedCounter)
    {
    return of(set({value:+storedCounter}))
}
return of(set({value:0}));
            }
        )
    ))


-> Thus this effect does the logic of loading data from local storage and 
dispatch an action once it is done 
-> Since the pipeline yields a new action object, which is the default for 
NgRx effects, we should not add dispath: false configuration object 
 to loadCount's createEffect
-> Lastly we need to make sure that this init action gets 
dispatched somewhere, so that the pipeline gets started 


d) We will do: init action to be dispatched somwhere, so that pipeline gets started in :
AppComponent 

eg: 
export class AppComponent implements OnInit{

  constructor(private store: Store)
  {}

  ngOnInit(): void {
    this.store.dispatch(init())  ;
  }
  

e) By the above changing, we are dispatching once the app starts, 
which kicks off this side effect pipeline loadCount defined in CounterEffects 
and then it dispatches another new action, which is then handled by the 
reducer  
-> Reducer which will load any already stored counter when the app runs 

 


168) Core Building blocks of NgRx
-> Until now we learnt the core building blocks of 
NgRx : Store, Selector, Reducer, Action, Effects , Component 

169) Services with RXjs and Subjects Vs NgRx 


170) What is Angular Universal?
a) While building standard angular app, we get 
a client side app which runs in browser 

b) Advantages of client side app:
1) Great user experience 
2) Instant responses and high application reactivity
 
c) Disadvantages of client side app:
Can run code only in browser has some disadvantages
1) It impacts search engine optimization:No or Bad SEO:
Web Crawlers like google crawlers see an empty page
2) Web crawlers just see what we could see in page source like this:

eg:

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>NgrxIntro</title>
  <base href="/">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" type="image/x-icon" href="favicon.ico">
<link rel="stylesheet" href="styles.css"></head>
<body>
  <app-root></app-root>
<script src="runtime.js" type="module"></script><script src="polyfills.js" type="module"></script><script src="styles.js" defer></script><script src="vendor.js" type="module"></script><script src="main.js" type="module"></script></body>
</html>


-> All the content we see in angular application is added by Angular after 
the page was loaded 
-> All content is displayed because of browser-side javascrip 
code being executed 
-> All content are displayed due to angular components 

Since web crawlers dont wait for the scripts to be executed, 
crawlers see an almost empty page, Hence SEO is impacted 
when you use just angular 

-> But this wont be disadvantage for application that has 
authentication and company internal websites 

 
3) Slow Page load 
-> If you are on slow network or on a slow device, loading 
the page and displaying content on the page can take some time 
because all the javascript code must be downloaded 
before something is rendered to the screen 
-> Hence users in slow network or slow devices might 
not see the content 


d) Angular universla helps to solve these problems
-> First page gets pre-rendered on the service and its still a SPA
---> Angular Universal is simply an extra package or 
feature or settings that adds some server side 
functionality to the app
-> With Angular Universal enabled: you get the best of 
both worlds :
1) It will still be Client Side : Default Angular App(SPA)
-> But the very first page that's loaded by a user will 
actually be pre-rendered on the server 
-> Which means that the finished page will be served to the user 
and therefore user or web search crawler does not 
have to wait for the javascript code to be downloaded 
and executed , to see something on the screen 
2) It is only first page load and subsequent navigations on the 
page and so on , will be handled by Angular on the client side 

171) Angular Universal with 16 and 17+ 
a) Angular 16:
ng add @nguniversal/express-engine

b) Angular 17:
1) If you want to create a new Angular project that 
comes with Universal / SSR enabled out of the box, 
you can run: ng new <project-name> --ssr.
2) If you are using Angular 17, running a SSR-enabled project also is easier than doing so with Angular 16 or lower.
-> All you have to do with Angular 17,
 is run ng serve. It'll automatically use SSR 
 if you enabled it via ng add @angular/ssr or ng new <project-name> --ssr.


172) How to convert an Angular app into Angular universal 
app 

1) Run the command: ng add @nguniversal/express-engine 
-> Running this command, installs extra packages,
creates new files and updates  existing files 
2) It updates app-routing.module.ts 
-> It updates extra setting: initialNavigation: 'enabledBlocking'
-> It helps angular router to work properly in Angular Universal App 

 
eg:
@NgModule({
imports: [RouterModule.forRoot(routes, 
{
initialNavigation: 'enabledBlocking'
}
)]


3) It also adds: app.server.module.ts file, which imports 
ServerModule in this imports array 
-> This server module is also needed to make angular 
universal work correctly 

4) We have main.server.ts file, which exports app.server.module.ts 
5) We have extra settings in angular.json, some extra scripts like: 
serve-ssr   
6) We also have server.ts file
-> contains some node js and express code 
a) Node js
-> node js is javascript run time that can be used for running javascript 
code outside the browser 
eg: on a server 

b) Express
-> It is a framework for nodejs which helps to 
build server-side applications 

7) In server.ts file, express powered server side application is built with the 
help of node js  , typescript and some Angular features 

8) Analyzing and running server side code: server.ts file 
server.ts file has Express server 

a) Express is a nodejs framework that is used for 
building webservers with nodejs 
b) This webserver is used for wrapping our angular app, i.e 
for serving the files that are produced when we build our angular app
c) server.ts not only serves the file and acts as webserver, but also 
it makes sure that the very first page we visit is pre-rendered 
on the server 

-> It is this line of code combined with other lines of code
that makes sure that the page is pre-rendered on the server and the 
finished page is served back to the client  

eg:

server.engine('html',ngExpressEngine({
bootstrap: AppServerModule
}));

d) Thereafter on that client/browser, we have a 
single page application  
e) We can take look at server rendered application 
because we can see extra scripts in package.json  which we can 
execute 

eg:
"scripts": {
.....
.....
"dev:ssr": "ng run ng-universal-demo:serve-ssr",
"serve:ssr": "node dist/ng-universal-demo/server/main.js",
"build:ssr": "ng build && ng run ng-universal-demo:server",
"prerender": "ng run ng-universal-demo:prerender"
.....
.....
}


e) "dev:ssr": "ng run ng-universal-demo:serve-ssr"

-> This script runs the angular app in universal mode and in 
development mode 

f) "build:ssr": "ng build && ng run ng-universal-demo:server",

-> This script helps to build in universal mode 
-> So that we can serve in Universal mode thereafter using this command: 

"serve:ssr": "node dist/ng-universal-demo/server/main.js",

g) so to run universal app:
run the following command:  npm run dev:ssr 

-> running this script in turn calls: ng run ng-universal-demo:serve-ssr

h) Now once the app is run, in the browser-> view page source we 
can see the contents of the app 


173) Closer look at the server side code: server.ts file 

a) This line of code is for pre-rendering the angular app
or the first page of the app on the server. 


eg:
server.engine('html',ngExpressEngine({
bootstrap: AppServerModule
}));


b) These lines responsible for serving extra assets, 
including the JavaScript files that contain your 
compiled angular code to the browser 




server.get('*.*,express.static(distFolder,
{
maxAge: '1y'
}));


-> in dist/browser folder we can see all the assets downloaded 


c) 

The below line of code alone with "server.engine('html',ngExpressEngine"
 -> helps to prerender the first page, that the user visits 
-> Below line of code captures requests to different paths of your 
application, so that different first pages can be prerendered 

server.get('*',(req,res) =>
{
res.render(indexHtml, {req, providers: [ 
{
provide: APP_BASE_HREF, useValue: req.baseUrl }]})
})


174) Integrating a rest API - Angular Universal:
a) This line of code in server.ts, if added to project 
we can build a full stack application 
-> this is important until now, we are talking only about client side 
application where the entire code is executed in the browser 

eg:
server.get('/api/**', (req,res) => {});
server.post('/api/**');


b) With angular universal and with this app transformed into 
a universall app, we can build a full stack application, where we can also 
execute some code on the server 
b) Not only for just pre-rendering the first page, we can 
also do this to add an API/Web API/ Rest API to our 
angular app 
c) Instead of using a third party service like firebase, we 
can build our own rest API here. 
d) Only thing to keep in mind here is that the backend routes, the paths 
to which requests need to be sent from Angular app must not 
clash with routes you are using on the front end 
d) So if in route config - if you have paths like 'about', we must not use these same paths
in your server side code 

eg:
{
path: 'about',
component: AboutComponent,
} 

e) Thus from this section, we can understand that using Angular Universal, we can 
build a full stack app with a backend rest API that lives in the same 
project and in the same folder which will be later served by the same host 
as your angular front end 



175) How to Deploy Angular Universal App: 
a) After converting Angular app to Angular Universal App , deployment 
wont work, as it worked before 
b) Because in standard angular app, you can use any static website provider like 
AWS S3,  because in the end you just have to deploy a couple of javascript files 
and  a html file 
c) You dont need a hosting provider that was able to 
execute code on the server 
d) This changes when you have a universal app 
e) Because with a universal app, you do have code that must be 
executed on a server and therefore you now need a hosting 
provider which supports server side code execution 
f) Angular universal app in the end, is a nodejs app using the 
express framework 
h) hence in google we can just search fro 'nodejs hosting provider'  to 
find a broad variety of possible host providers that you can use 
to deploy your application
i) Now we will see, how to prepare this angular universal app for deployment 
and which files you will need in general to deploy to a hosting 
provider 

176) How to prepare angular Universal app to Prepare for deployment into 
a hosting provider:
a) Run this command for build: locally in the system 
npm run build:ssr 
-> need not run this command on the machine to which you wanted to 
deploy your app  to 
b) running this command will give the dist folder which contains both browser and server folders 

eg:
dist/ng-universal-demo/browser
dist/ng-universal-demo/server 

c) It is the dist folder which needs to be uploaded 
to the hosting provider 
d) dist folder + package.json + angular.json 
-> these three files are needed for deployment into the 
hosting provider 
e) dist folder + package.json + angular.json
-> all these three should be put into the machine which 
is going to host this website 
f) now lets imagine that thes three files were deployed to 
the server and we are in that server:

eg:
dist/ng-universal-demo
angular.json
package.json 


g) you will connect to that machine 
h) Then run : npm install 
-> to install all the dependencies that are required by 
that project 
-> this command should be executed once, before you start 
serving the angular application 
i) Then run this command to start serving the application:  

npm run serve:ssr

-> This process must keep up and running, as long as the application 
should be served 
-> Here it serves under this address:
http://localhost:4000 
j) if you are using a real hosting provider, 
we can forward this and map to a different domain if you 
are using a real hosting provider 

k) Thus we served the angular application universal, by deploying in local machine also 

177) 
Angular Universal Gotchas
You typically use Angular Universal to pre-render Angular pages on the server. Once the app then runs on the client, it's a normal SPA again.

Server-side rendering (SSR) can make sense because of SEO considerations (crawler should see what your users see) or because you want to deliver a finished page to your users (rather than creating the page in the browser).

But that also has one important implication: You MUST NOT use any browser-only APIs like document.querySelector()  in your Angular code! 

Simply because it will execute on the server and there, such APIs are not available.

That's why, in this course, I recommended to use Angular features only: These features are safe to use because Angular will check if a certain API can be used before it uses it.


178) Animation triggers and state: 
a) Angular animations will be used in html is set up 
in the app component decorator 
b) We create animations array  as part of 
@Component decorator 
c) in this array we define the animations, that this template 
should be aware of 
d) Each animation has a trigger
-> Trigger is a function defined in ts file and if it is placed in 
html it triggers an animation 
e) We give trigger a name: divState since we need to manipulate
the state of this DIV element  

eg:
@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  animations: [
    trigger['divState']
  ]
})

f) We need to attach some animations to this trigger, for which 
we add the second argument to the trigger function
-> the second argument define the animation 
-> the second argument is an array 
  animations: [
    trigger['divState'],[]
  ]
  
g) Now in html, we can add the trigger to the div element 
-> We do this by adding in square brackets of the div
like we use in property binding, but we will be using 
@

eg:
<div [@divState]=""> 
</div> 

h) We need to bind this to something, because the animation i 
am going to define, should run all the time 
-> we need to bind the condition, on which part of 
animation should run 
--> In angular animation, there will be transititon between two states 
 
-> We will use a simple property name 'state", a property 
which will be created in app.component.ts  

eg:
export class AppComponent {
  state= 'normal';
  
  
i) Since animation is transition between two states, we define 
new state in animation array, which is 
a state() method 
-> in our case we will have two state() methods, to transition between two states 

eg:
  animations: [
    trigger['divState'],[
      state('normal'),
      state('highlighted')
    ]
  ]

j) So how should the normal state look like?  
-> it is the second argument of the state method 
-> style() method is used for the same 

eg:
  animations: [
    trigger['divState'],[
      state('normal', style(
        {
          'background-color':'red',
          transform: 'translateX(0)'
        }
      )),
      state('highlighted')
    ]
  ]
 
  
k) And also make changes in html :

eg:
      <div
      style="width: 100px; height: 100px"
      [@divState]="state"></div>
	  
l) Correspondingly define style for 'highlight" state 

eg:

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  animations: [
    trigger
    ('divState',[
      state('normal', style(
        {
          'background-color':'red',
          transform: 'translateX(0)'
        }
      )),
      state('highlighted',style(
        {
          backgroundColor: 'blue',
          transform: 'translateX(100px)'
        }
      ))
    ]
)
  ]
  
 
179) How to switch between states: Animation?
-> now in application we are in state, where we are able to 
display one state normally 

a) We will use Animate button in ui which triggers the 
onAnimate() method 
-> in onAnimate(), we should change the states 
-> in this method, we toggle between states 

eg:
onAnimate() {
this.state== 'normal'? this.state = 'highlighted': this.state = 'normal';
}

b) Now we will be able to switch between states in UI, on hitting the Animate  button

180) What are transitions in Animation? 
a) In state method, implement the transition method 
-> transition method tells how transition from one 
state to another state should look 
b) Hence transition's first method is starting state 

eg:
animations: [
    trigger
    ('divState',[
      state('normal', style(
        {
          'background-color':'red',
          transform: 'translateX(0)'
        }
      )),
      state('highlighted',style(
        {
          'background-color': 'blue',
          transform: 'translateX(100px)'
        }
      )),transition('normal=> highlighted', animate(300)),
      transition('highlighted => normal', animate(800))
    ]
	
c) thus transition can be viewed in the screen 


181) Advanced transitions:
a) if you want same transition for other state change:we 
can change 

from:
transition('normal=> highlighted', animate(300)),
      transition('highlighted => normal', animate(800))
	  
	  
to:
  transition('normal<=> highlighted', animate(300)),
  
  
b) To control the style during the movement 

i) Create new trigger 

eg:
 trigger
  ('wildState',[
    state('normal', style(
	
	
ii) In html, we can create to new 
div element and  we can bind to new state and assign 
it to new property:

eg:
    <div
    style="width: 100px; height: 100px"
    [@wildState]="wildState"></div>
  </div>
  
  export class AppComponent {

  state= 'normal';
  wildState='normal';
  

ii) We will create another state: shrunken 

eg:
@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  animations: [
    trigger
    ('divState',[
      state('normal', style(
        {
          'background-color':'red',
          transform: 'translateX(0) scale(0)'
        }
      )),
      state('highlighted',style(
        {
          'background-color': 'blue',
          transform: 'translateX(100px) scale(1)'
        }
      )),
      transition('normal<=> highlighted', animate(300)),
  //    transition('highlighted => normal', animate(800))
  
  state('shrunken',style(
    {
      'background-color': 'green',
      transform: 'translateX(0) scale(0.5)'
    }
  )),
  transition('normal=> highlighted', animate(300)),
  transition('highlighted => normal', animate(300)),
]
)
  ]
})


eg:
onAnimate() {
this.state== 'normal'? this.state = 'highlighted': this.state = 'normal';
this.wildState=='normal'?this.wildState='highlighted': this.wildState='normal';
}

c) 

  transition('shrunken <=> *', animate(500)),


-> Here wild card character means: to  any state 
and shrunken from any state will play the same animation here 
-> wild card character gives us the flexisbility that we 
dont manually have to specify any possible state 
-> in applications where the state is dynamic and name is not known,
wild card character is very useful 

182) Transition phases in Animation: 
-> Until now we had only start and end state
-> More on animate function
-> Not only timing, we an also control the whole animation  and 
define styles the animation should take during the animation 
  a) 

eg:
transition('shrunken <=> *', animate(500,style(
{
borderRadius: '50px'
}
))

-> it gives extra style during the animation

b) For smooth transition and other transitions  : 

transition('shrunken <==> *', [
style(
{
'background-color':'orange'
}
),
animate(1000,
style({
borderRadius:'50px'
})),
animate(500)
])

183) The "void" state in Animation: 
a) To animate addition of item to the list or remove animation on 
clicking an item in list 
b) Add a new trigger in app.component.ts 

eg:
trigger(
'list1', [
state(

'in', style(
{
opacity:1,
transform:'translateX(0)'
}
),
transition('normal<=> highlighted', animate(300)),)
)]
)


c) 
'in' -> in state how it should look when it is in there
opacity:1, -> means fully visible and not transparent  

d) First transition when it comes in : 

transition('*void => in', animate(300)),)


-> void is a reserved state name 
-> void is provided by you of four cases ,
where you have an element in end state , which was not 
added to DOM at the beginning 
-> Also we will add void  as the transitionTo state 

183) Using keyframes in animation 

-> More detailed control over the individual steps during the animation 
process 
-> We already defined multiple phases, but each phase gets the same importance 

a) We can use keyframes to say: you animate this 
for one second , after 200 seconds you should have this state  , and after 
500 seconds you should have this state and so on 
b) Create another trigger 
c) in transition -> animate() method 
-> use keyframes method as second argument 
-> keyframes() method in animate function, allows you to be more 
precise on which part of multiple styles i can setup and which occur at which timing 
-> overall animation will happen for one second but i can control which state 
inside of that animation should take how long 


eg:

trigger('list2',[
state('in',style({
opacity:1,
transform:'translateX(0)'
})),
transition('void => *',
[
animate(1000, keyframes(
[
style(
{
transform: 'translateX(-100px)',
opacity:0
offset: 0
}
),
style(
{
transform: 'translateX(-50x)',
opacity : 0.5 
offset:0.3
}),
style(
{
transform: 'translateX(-20x)',
opacity :1 
offset:0.8
}),
style(
{
transform: 'translateX(0px)',
opacity :1 
offset:1
})
])
]
])

-> offset property tells at which timing of these, 1000 
milliseconds in this case 
-> first style  is at beginning of offset 0 
-> second style is 30% of animation time : 300 ms 
-> third style is 80% of animation time : ie 800 ms 
-> then have final style with offset of 1

d) Thus we can use keyframes to control precisely at which 
stage we want to have at which time during the transition 
e) Keyframes are for the time during the transition 


184) Grouping transitions in animation: 
a) Lets say we want to have two different animations 
both of which takes different amount of time 
b) use the group() method for the same 
c) in group() method, we pass the array of animations 
we wanted to perform synchronously

transition(
'* => void', 
[
group([
animate(300, style(
{
color: 'red'
}
)),
animate(300, style(
{
transform: 'translateX(100px)',
opacity:0 

}
])

)),


]

)



185) Animation Call Backs 
a) There are couple of animation callbacks we can listen to 
b) So that when an animation finishes, we can execute 
some other code 
c) eg: in div element of html 
we can listen to those call backs 
d) we can have the start end end trigger, which executes 
when animation starts or ends respectively


eg:
<div
style="width: 100px: height: 100px"
[@divState]="state"
[@divstate.start)="animationStarted($event)"
[@divstate.end)="animationEnded($event)"
>


e) Create those two methods in the AppComponent 



186) Offline Capabilities : Service Worker
a) We can turn an online only application into a 
Offline available one by using a service worker 


187) What are Service Workers  in angular?
a) Javascript code runs in a single thread 
i.e our web application which can consist of multiple pages or in angular a spa , uses 
javascript 
-> This Javascript code i.e the entire angular application 
runs on one single thread and JavaScript has features 
to handle asysnchronous code and not block the execution 
b) Javascript and browser allows us to run one additional 
thread - we can run a web worker 
-> special form of webworker is the service worker on another thread 
-> This thread is different from the thread that executes 
main javascript code 
c) This service worker thread is decoupled from your html pages 
d) This means that it can continue to run in background 
 like mobile phone and do some advanced things like 
 i) receiving push notifications 
e) Service worker can manage all your different pages or spa if an angular app 
and it can listen to outgoing network's request 
-> service worker can listen to outgoing request and catch the 
responses in a special cache storage or 
return these cached responses back to your page, so that it also works when the 
internet connection is down 
f) Thus SERVICE WORKER - can be seen as a proxy between your app  and the http request 
you are sending to the backend 
-> SERVICE WORKER - proxies that request(means it caches it), does 
something with and leave or block it 
h) Configuring such a service worker and writing it from scratch is something 
outside the scope of this course 


*********Service Worker**********
1) Runs on additional thread, decoupled from html pages 
2) Manages all pages of given scope (eg: all pages of a domain) 
*********Service Worker**********


187) How to add SERVICE worker in angular 
a) Hence in this section, lets focus on how angular 
can easily add such a service worker to your angular app 
b) There is a special package we need to add:

eg: 
ng add @angular/pwa 

c) running this command will configure your existing 
project to use the angular service worker package and start with 
a preconfigured service worker 
d) After Adding this package, we can see that certain things are added to our files 
e) In index.html, 
<noscript> section is added, to give a warning when javascript is turned off 

eg: 
<noscript> Please enable javascript to continue using this application.</noscript> 

f) in index.html , it loads the manifest

eg:
<link rel="manifest" href=manifest.json"> 

-> This is important for having a launcher icon for your 
application, if you have it on a mobile phone - you can save it in home screeen and 
start it with that . 

g) We can see manifest.json generated and we can also define which icon to use in manifest.json and 
so on 
h) In app.module.html -> imports array [], we can see
ServiceWorkerModule imported from @angular/service-worker 


eg:
imports: [
BrowserModule,
HttpClientModule,
ServiceWorkerModule.register('/ngsw-worker.json,

]

i) The below line, registers  the service worker and it will be that proxy 
that catches outoing requests : 


ServiceWorkerModule.register('/ngsw-worker.js,
{
enabled: environment.production
})],


-> we use the register method for that and there we 
target the ngsw-worker.js , this file is auto-generated
-> it will be generated during the build process and it will be 
in the dist folder 
-> this file holds the service-worker and it contains lot of 
functionality

j) in package.json, we can see @angular/service-worker and 
@angular/pwa 
being added 
k) we also have ngsw-config.json file being added 
-> in this file we will be configuring the service worker which will be generated 
l) in angular.json also we can see "serviceWorker" set to true 
for production build 
-> this is because serviceworker
 will  cache certain resources - to ensure that the new build 
 updates the service worker - these resources will contain a hash and that will then be injected 
 into service worker 
 
m) Lets build a production build: ng build --prod 
-> this creates angular app in dist folder optimized for prod 
and we will be able to see the service worker there 

dist/angular-project/ngsw-worker.js -> this is the file we 
are imported in app module here 


n) in ngsw-worker.js we can see a lot of code
-> it does caching and all in efficient manner 
o) To see what it does, we need a webserver you can run 
to host your production app 
-> that can be done by: ng serve --prod 
-> but there we cannot see the service worker in action, because it will only build it in memory 
p) hence we need to install a lightweight node server using: 
npm install -g http-server
-> this is the package which we can use to launch a simple 
node based server which will host the content of the folder 
you run the command :

1) navigate to dist project: 
cd dist/angular-project/

2) run the http-server with a port , which brings up the server 
http-server -p 8081 

3) Now only visiting: localhost:8081,we can see the 
angular app coming up 

q) Now in inspect-> application->service worker 
we can find : source : ngsw-worker.js and running 

r) Now if you select offline and reload the page, we can 
see the same content as before, even though we are offline 

s) How does it work:
-> if we go to network tab, we can see that we are making the bunch of requests
and they are served from ng service worker here 
-> Interesting part is that post request here , which connects to the outgoing server 
-> now if we disable wif and see, we can see posts failed

t) but we can still see is that  the harcoded page we added in the html pages 


188) Adding caching assets for offline usage: 

a) ngsw-config.json
-> here "index":"/index.html" indicates the root page of our app that we 
want to cache and load 
b) assetGroups
-> we have two asset groups
-> asset groups are configurations that define which static assets should be cached 
and how they should be cached 
-> dynamic assets are the data from the API 
-> assets how it should be loaded: prefetch.
-> prefetch means that when your page loads, angular will go ahead or the service 
worker will go ahead and prefetch all the assets which are specified  in the assets group
-> it means that it puts them in cache, even if you have not needed them yet 
-> alternate to prefetch is lazy,  : it would only load them once you needed them atleast once 
--> advantage of lazy is: it does not occupy all the bandwidth right at the beginning 
-> downside is: if you need it for the first time it will not be there - so if user lose internet before the asset files is required 
the first time,it will not work - because it will not be cached 
-> downside is that if you need it for the first time, it will not be there 
-> There is also "updateMode", important if you are pushing new 
version of angular app 
-> "resources" contains files array pointing to files you want to cache 

eg:

"assetGroups":
[
{
"name":'app",
"installMode": "prefetch"
"updateMode":"prefetch"
"resources":{
"files": [
"/favicon.ico",
"/index.html",
"/*.css",
"/*.js"
]

}

]

c) static font asset is not included, - its not changing or at least not regularly 
and we can include it in assets manually through urls 


189) How to cache Dynamic assets and urls: 
a) We can also prefetch the api 
-> for that we can add new configuration item : dataGroups 
b) While assetGrops is for static files, dataGroups is for dynamic data 
-> thus dataGroups is for dynamic data or data from api which will change frequently 

c) Configuring a dataGroup: 

"dataGroups":
[
{
"name": "posts",
"urls": [
"https://jsonplaceholder.typicode.com/posts"
],
"cacheConfig": {
"maxSize": 5 ,
"maxAge","12h",
"timeout","10s",
"strategy": "freshness"
}
}
]

}
]
} 

-> cacheConfig is the object, where you can now in detail configure - how 
this data should be cached like setting maxSize - it defines 
how many entries you want to cache 
-> maxSize does not mean 

how many posts, it means how many responses 

-> maxAge: defines how old should the data in the cache be , before we get 
rid of it 
-> timeout : if i want for response from api and if it crosses timeout period
then we can fetch from cache itself 
-> freshness means always try to reach backend first and then only use the cache 
or we can use performance 


190) Analyzing the testing environment: 
a) by default project will contain files like: 
app.component.css
app.component.html
app.component.ts 
app.component.spec.ts 
app.module.ts 
app-routing.module.ts 

b) Of this in app.component.spec.ts, we can find some unit tests :

eg:
describe('AppComponent', () => {
  beforeEach(() => {
    TestBed.configureTestingModule({
      declarations: [
        AppComponent
      ],
    });
    TestBed.compileComponents();
  });
  
  -> before each should be running before running the tests 


c) Each block beginning with it is a test  
d) How should a test work theoretically? 
i) We have angular application with app module and 
the app component in it runs in the browser 
ii) We need to run the same in the testing environment 
iii) Testing environment is just a script running over it 
iv) In order to simulate the same behavior we also need to bootstrap 
our application , need to setup app module , then execute certain tasks that user may do
-> ie what happening here in this spec file 


191) Complete analysis of app.component.spec.ts file:
a) In top we have two imports : TestBed and async

eg: 
import { TestBed, async } from '@angular/core/testing';
import { AppComponent } from './app.component';


b) Then we describe the to be tested unit in this case: 
-> Here we wanted to test the AppComponent and AppModule

eg:
describe('AppComponent', () => {
  beforeEach(() => {
    TestBed.configureTestingModule({
      declarations: [
        AppComponent
      ],
    });
    TestBed.compileComponents();
  });


c) the function in describe will be executed by the test runner - karma 
-> karma is the test runner which is installed and it runs 
our tests 


() => {
  beforeEach(() => {
    TestBed.configureTestingModule({
      declarations: [
        AppComponent
      ],
    });
    TestBed.compileComponents();
  });
  
  ...
  
  
  and all the test cases
  
  .... 
  
  
d) beforeEach block will be executed before running each of the test cases 
mentioned in the 'it' block 

  beforeEach(() => {
    TestBed.configureTestingModule({
      declarations: [
        AppComponent
      ],
    });
    TestBed.compileComponents();
  }
  
e) Though the it blocks are follow one after another, each block is executed, total independent of the block before it 
-> Hence code in one it block is not influenced by another it block code  


eg:
  it('should create the app', async(() => {
    const fixture = TestBed.createComponent(AppComponent);
    const app = fixture.debugElement.componentInstance;
    expect(app).toBeTruthy();
  }));

  it(`should have as title 'app works!'`, async(() => {
    const fixture = TestBed.createComponent(AppComponent);
    const app = fixture.debugElement.componentInstance;
    expect(app.title).toEqual('app works!');
  }));
  
f) hence beforeEach is the only thing which will be executed before each individual block 
g) Here we configure the testing module of the testbed 
-> testbed is the main angular test utility object 
-> this method allows us to configure module for our testing 
-> Here we declare the components, we want to have in the testing environment . in our case it is app component 
-> This looks like the app module with the declarations but it does not have the imports, providers or the bootstrap 
-> We dont have that, because as part of the unit testing, we focus only on the part of the application and we are not really running it 
in the browser and we only wanted to focus on the app component while the rest will be simulated by our testing environment 

-> Hence AppComponent is declared and initialized here 


eg:
  beforeEach(() => {
    TestBed.configureTestingModule({
      declarations: [
        AppComponent
      ],
    });
    TestBed.compileComponents();
  }
  
h) After beforeEach, we have the tests 
-> This tests if the app was properly created 

1) it starts the test case and the "should create the app" describes the test case 

eg:
it('should create the app', async(() => {

1) 
-> We always need to create the component , because each it block is contained in itself 
-> We do this by using createComponent on the test bed and then we store this new component 
-> We store the new component in the fixture variable 
-> Here while creating component, we pass the AppComponent as argument to tell which component we are going to create 

eg:
    const fixture = TestBed.createComponent(AppComponent);
	
2) We can get our app, by using the fixture, which holds the created component 
-> the debugElement is a property which helps to access couple of elements 
-> for eg: instance of the component i.e the application 


eg: 
    const app = fixture.debugElement.componentInstance;
	
3) Then we always end our it block by using the expect method 
-> expect does not come from angular, and it should be karma or jasmine related 
-> karma or jasmine are the testing package and 
-> expect, beforeEach are the testing package related methods 

-> expect tells: we expect whatever we pass as argument, app in our case to be truthy 
-> which means : whether it exists or not 
-> truthy means existent 


    expect(app).toBeTruthy();
	
eg: 
  it('should create the app', async(() => {
    const fixture = TestBed.createComponent(AppComponent);
    const app = fixture.debugElement.componentInstance;
    expect(app).toBeTruthy();
  }));
  
4) In the next block we check 

a) In this block we have the title of the test as: "should have as title 'app works!"
b) here we check for 'app works' ,in title as part of test case 
c) here as part of test case, We create component, 
   const fixture = TestBed.createComponent(AppComponent);
d) we get access to the app instance 
    const app = fixture.debugElement.componentInstance;
e) Then we expect the app to have a title property which equals 'app works!' 
-> here title is the property of the AppComponent and we can access it using the app, which is the app instance for the component 

eg:
  it(`should have as title 'app works!'`, async(() => {
    const fixture = TestBed.createComponent(AppComponent);
    const app = fixture.debugElement.componentInstance;
    expect(app.title).toEqual('app works!');
  }));


5) Finally the third test is, to render h1 tag 
a) Here create fixture instance using createComponent like before 
b) Then we use fixture and call detectChanges
-> You must tell the TestBed to perform data binding by calling fixture.detectChanges().
-> It gives the tester an opportunity to inspect and change the state of the component before Angular initiates data binding and calls lifecycle hooks. 
-> since we dont run in browser, changeDetection or databinding does not happen automatically, hence we need to call it 
-> Thus the template get rendered because of calling: fixture.detectChanges()
c) Then we get access to nativeElement from the fixture and debugElement 
-> nativeElement gives us access to the template 


...
Angular ElementRef is a wrapper around a native element inside of a View. 
It's simply a class that wraps native DOM elements in the browser and allows you to 
work with the DOM by providing the nativeElement object which exposes all the methods 
and properties of the native elements.

....

d) On this compiled html template, using javascript's querySelector  , we check if the h1 element's text content to contain "app works!"


eg:
  it('should render title in a h1 tag', async(() => {
    const fixture = TestBed.createComponent(AppComponent);
    fixture.detectChanges();
    const compiled = fixture.debugElement.nativeElement;
    expect(compiled.querySelector('h1').textContent).toContain('app works!');
  }));




5) These are the three alreday tests and this is the logic how this file and tests get executed
6) it and test are default testing environment variables 


192) Running our tests with cli : 
a) inside project folder run this command to run the tests through cli: ng test 
b) Running this command will do the following 
1) Starts the testing environment 
2) starts up Karma 
3) Starts chrome browser 
4) Executes tests 


193) Adding a component and some fitting tests 
a) Create a user component and its corresponding html
b) By default user.component.spec.ts is created and contains 
a simple test case, to check if the instance is created 
c) Lets write our own test :
d) Declare the module 
-> setup beforeEach() method, which takes a callback 
eg:
beforeEach(() => {

})

-> Simply say TestBed : TestBed is main testing object giving access to all configuring 
Angular testing utilities 
-> call configureTestingModule which expects to get 
a javascript object , where i can add my declarations in NgModule 
-> declarations is an array and we can UserComponent in that 
array , we add UserComponent since that is the 
component we want to test :
e) If you are not using CLI or any web pack based setup,
you then need to compile components thereafter 
-> for that we need to execute compileComponents() to compile them 
-> only when using webpack, this is not needed, because webpack has a 
different workflow build process, which will do this anyways 
-> Because of the way you import your external html files 
or in css files, it will do this while bundling or producing your app 
-> in system chair setup, for example it wont do this automatically 
and we have to do that, since the angular compiler which would do this 
in browser wont run here 

eg:
TestBed.configureTestingModule({
declarations: [UserComponent]
}
)


f) Thus we have the compiled components and next we should 
create a test 
-> we write it and then give it some description 
-> Our test is 'to check if the app was created'
-> Then in function, create the fixture and use TestBed to 
create UserComponent using createComponent 

it('should create the app', () =>
{
let fixture = TestBed.createComponent(UserComponent)

}
 
 
-> Now we created the component in testing environment , it is similar 
to adding the selector for UserComponent in some html template and 
we browsed to this page and Angular would create component in the background 

g) With the fixture, we can get the app , by 
accessing the 'debugElement',which is the element 
asked to expose for testing purposes, where i can access 
-> we can access componentInstance using debugElement

eg:
let app = fixture.debugElement.componentInstance;

h) Then we can expect this app 'toBeTruthy' 
-> toBeTruthy checks whether this kind of exist or the component 
exists 

eg:
expect(app).toBeTruthy();

i) Thus this is a simple test, where we checked if the application 
started up or not 



eg:
describe('Component:User',()=> 
{
beforeEach(() => {

TestBed.configureTestingModule({
declarations: [UserComponent]
}
)

})

it('should create the app', () =>
{
let fixture = TestBed.createComponent(UserComponent)
let app = fixture.debugElement.componentInstance;
expect(app).toBeTruthy();

}
}) 


194) Testing Dependencies: Components and Services 
-> Thus far we had very simple tests, checking if components are 
created and so on 

a) Lets add a service to our user folder :user.service.ts 
b) We can add a test to check if we 
are able to get user name from the service 
c) We will create fixture and componentInstance 

eg:
let fixture = TestBed.createComponent(UserComponent)
let app = fixture.debugElement.componentInstance;


d) Next step is to inject my service 
-> We need to inject UserService into the component  in our 
testing environment
-> We can start by creating userService variable here -> this 
can be done by using fixture->debugElement->injector->get of UserService

eg:
let userService = fixture.debugElement.injector.get(UserService);

-> What it does is: it uses the angular injector which is 
part of the component which we now created and tells pls get the 
instance of this UserService 

e) With userService, we can say that we expect my userService 
username to equal the app user name 

eg:
let userService = fixture.debugElement.injector.get(UserService);

f) Now if we run the tests we will get an error:
"TypeError: Cannot read property 'name' of undefined 

g) What went wrong: 
-> We are getting this property from the service, because we inject it, 
which happens in ngOnInit 
-> But we are missing one thing, which happens automatically 
in the app while running in the browser, but not here 
-> We need to run change detection to update our properties and so 
on 
-> by calling: fixture.detectChanges() , our test will pass now 



eg: fixture.detectChanges();

FULL CODE: 
eg:
it('should use the user name from the service',
()=> {

let fixture = TestBed.createComponent(UserComponent)
let app = fixture.debugElement.componentInstance;
let userService = fixture.debugElement.injector.get(UserService);
fixture.detectChanges();

})


h) Now the test is passing, because now we are trying to access our 
username property on the component after we update it 
-> We need to update it, because it is not in the same state 
as at the beginning . We injected a service and 
got data from there , even though it happened synchronously - but 
it is still not the same state as in well our code here, where it is undefined 
at the beginning :

eg: user: { name:string}

i) Now it will be interesting to see if our ngIf thing in template 
works fine 
-> i.e we want to check if we see the 
username , if we are logged in and  we dont see it, if we are 
not logged in 

eg:
<div *ngIf="isLoggedIn">
 <h1> User logged in </h1>
 <p>User is: {{ user.name }}</p> 
</div> 
<div *ngIf="!isLoggedIn">
 <h1> User not logged in </h1>
 <p>Please log in first</p> 
</div> 

j) for that we can create a new test 
-> lets copy code from previous test until fixture.detectChanges() 
-> Now i want to compile my template code 
via fixture.debugElement.nativeElement

-> here nativeElement is the template 

eg: 
let compiled = fixture.debugElement.nativeElement;

k) Then i wanted to check: i expect my compiled template 
to have a paragraph element and its text content is expected to 
contain the username 

eg:
expect(compiled.querySelector('p').textContent.toContain(app.user.name) ;

-> the above code will work only if it is logged in

l) But now if we try to run this test, it will fail , because we have not logged in 
-> hence we need to change our code for the same
-> We need not access userService like this anymore :
i.e we dont need to retrieve it from the injector 
-> it can be done by angular automatically 

XXX
let userService = fixture.debugElement.injector.get(UserService);

m)  We will access app and set isLoggedIn  to true 

eg: 
app.isLoggedIn = true; 


n) Now if we run the tests, it will get executed successfully 


eg:
it('should display the user name if user is logged in',
()=> {

let fixture = TestBed.createComponent(UserComponent)
let app = fixture.debugElement.componentInstance;
app.isLoggedIn = true; 
fixture.detectChanges();
let compiled = fixture.debugElement.nativeElement;
expect(compiled.querySelector('p').textContent.toContain(app.user.name) ;

})


o) On the otherhand, if the user is not loggied in we should not display the user name 
-> Here we will remove : app.isLoggedIn =true and we will 
still detectChanges and but here will expect testContent not.toContain



XXX
app.isLoggedIn = true; 




eg:
it('shouldn\'t display the user name if user is not logged in',
()=> {

let fixture = TestBed.createComponent(UserComponent)
let app = fixture.debugElement.componentInstance;
app.isLoggedIn = true; 
fixture.detectChanges();
let compiled = fixture.debugElement.nativeElement;
expect(compiled.querySelector('p').textContent).not.toContain(app.user.name) ;

})



195) Simulating async tasks:
-> Until now we got basic introduction to testing services,
injecting services into components and we are yet to see 
about async thing 
-> Our service until now is synchronous, hence we did not 
have any asynchronous test :
-> synchronous tasks including talking to webserver via http
and waiting for response 

a) Now for asynchronous task, we will create a new service :
data.service.ts which will do an asynchronous task
b) Inject the DataService in UserComponent
c) We can access the DataService instance by using the injector like before 
d) Until now we have some tests, which were testing UserService which is 
synchronous 
e) Now with DataService, we want to fetch data asynchronously
-> In our test code, we will copy fixture and app line from
previous tests 

eg:
it('shouldn\'t fetch data successfully if not called asynchronously'),
()=> {
let fixture = TestBed.createComponent(UserComponent)
let app = fixture.debugElement.componentInstance;

f) Now we got app instance, now we need to access getDetails method 
of DataService which fetches data asynchronously 
-> i dont want to execute real getDetails, because this 
method might reach out to a server and in real application 
you dont want to reach out to the server all the time when testing it 
-> Instead of faking it, you can override it and create fake 
implementation which is still asynchronous, but 
does something else 

g) So lets create a new verbal spy and we will use 
spyOn
-> spyOn is a function provided by the testing environment 
and it is not an angular testing function 
-> Here we will first tell on what you want to spy 
-> We wanted to spy : data service , to which we can get access like we 
did for UserService 

eg:
let dataService = fixture.debugElement.injector.get(DataService);

h) Then we will use this dataService to spy on the getDetails()
method, there you pass it as a string 

-> here name of getDetails should match the method which used in 
DataService 

eg:
let spy =spyOn(dataService, 'getDetails')

i) Next what we can do now is change something  
with and then return value 
-> We spy on that means, we get informed whenever getDetails get 
executed 
-> so spyOn means we listen to it and whenever it gets 
executed , When running a test, 
we dont execute it and instead we will return 
a value on our own 
-> The value we will return here is promise,.resolve.data 

..What happens behind the scenes...
-> It will execute the asynchronous code and 
eventually give us back our own data and not what 
this asynchronous task would have given us 
-> It still runs in an asynchronous fashion 

eg:
let spy =spyOn(dataService, 'getDetails')
  .and.returnValue(Promise.resolve('Data') );
  

j) Thus we spy on it and got the data
k) Then we can run the change detection to update component
after we get the data 

eg:
fixture.detectChanges();

l) Then check if it works :
-> expect and i expect my app data field to be undefined
-> Normally i would expect it to be something else 
because in  UserComponent here in ngOnInit , i will 
now use my dataservice to get the details 

#######

eg: UserComponent

ngOnInit()
{
this.user=this.userService.user;
this.dataService.getDetails().then(
data=> this.data=data);
)

}

#########

m) Now we are mentioning as undefined in expect,
-> It is because we know that the spy object will fail 

eg:
expect(app.data).toBe(undefined);

n) Thus if we test it, it will return 'undefined', hence the test will fail
O) Now if we replace undefined with 'Data'
-> our test case will fail since we will get undefined for 'Data' 






eg:
it('shouldn\'t fetch data successfully if not called asynchronously'),
()=> {
let fixture = TestBed.createComponent(UserComponent)
let app = fixture.debugElement.componentInstance;
let dataService = fixture.debugElement.injector.get(DataService);
let spy =spyOn(dataService, 'getDetails')
  .and.returnValue(Promise.resolve('Data') );
fixture.detectChanges();
expect(app.data).toBe('Data');

});


p) Now the challenge is :
Our app.data will be undefined at the beginning and after completing 
the asynchronous task, data will be having a string value at the end 
-> HOW TO TEST SUCH AN ASYNCHRONOUS TASK WHERE THE STATE 
CHANGES DURING THE RUN TIME 

q) We will write a second test for this 

1) We will copy the same test and use it. We will change 
test description 
2) In the existing ES6 function, we will wrap 
the call back of ES6 function within async() function 
3) By wrapping callback of es6 function in async function, 
it creates a kind of asynchronous testing environment for angular,
it fakes it [its not really asynchronous, but it allows 
us to run asynchronous tasks there)
4) Angular is aware that there are asynchronous tasks and is 
able to handle them as if it would handle them a real asynchronous 
task 
5) To do this, we need to add one thing, after detecting changes
-> i Need to use my fixture and execute whenStable 
-> This function on the fixture allows me to react to all
asynchronous tasks that are finished 

eg:
fixture.whenStable();

6) Here i can execute the thenFunction of my promise, which 
takes a callback to be executed, once it is done 
-> Inside of this callback, i will expect something to happen 
-> So once the asynchronous task has been finished , there 
i expect it to be data 

fixture.whenStable().then(()=> 
{
expect(app.data).toBe('Data');
})


7) Now if we run it, we will have 9 successful tasks 




eg:

import {TestBed, async} from '@angular/core/testing';

it('should fetch data successfully if called asynchronously'),
async(()=> {
let fixture = TestBed.createComponent(UserComponent)
let app = fixture.debugElement.componentInstance;
let dataService = fixture.debugElement.injector.get(DataService);
let spy =spyOn(dataService, 'getDetails')
  .and.returnValue(Promise.resolve('Data') );
fixture.detectChanges();

fixture.whenStable().then(()=> 
{
expect(app.data).toBe('Data');
})


expect(app.data).toBe('Data');

}));


196) Using "fakeAsync" and "tick"

-> We have an alternative to the above setup 
--> since it kind of happens synchronously anyways and only theoretically, 
it is asynchronous, we noticed we did not wait 1.5 seconds here 
-> We can call above test and call fakeAsync
a) fakeAsync helps to get rid of whenStable function, instead we will 
execute: expect(app.data).toBe('Data'); instantly 
b) But we will call tick() in between
-> tick() function also needs to be imported from 
angular testing package 
c) tick() means that in a fake asynchronous environment - finish 
all asynchronous tasks now , 
-> when tick is executed, all asynchronous tasks are finished 
immediately , since we resolve it immediately    

eg:
tick();
expect(app.data).toBe('Data');

-> we do this , because we dont want to wait that time when testing 
-> Hence we finished them immediately and we should have access to the 
data 

d) Hence we can use async with whenStable and then in callback you have expectation 
or you use fake async 

-> Both takes same time, but it is just different policy 

eg:

import {TestBed, async,fakeAsync,tick} from '@angular/core/testing';

it('should fetch data successfully if called asynchronously'),
fakeAsync(()=> {
let fixture = TestBed.createComponent(UserComponent)
let app = fixture.debugElement.componentInstance;
let dataService = fixture.debugElement.injector.get(DataService);
let spy =spyOn(dataService, 'getDetails')
  .and.returnValue(Promise.resolve('Data') );
fixture.detectChanges();
tick();
expect(app.data).toBe('Data');
;

}));


197) Isolated and Non Isolated tests:

a) Consider our app, which has UserComponent, UserService and ReversePipe
-> Both UserComponent and UserService  are connected because we 
inject user service in user component 
b) Let our ReversePipe do task of reversing a string.
-> This pipe can be tested, isolated 
c) Pipe can be tested independently of angular 
-> pipe has a transform function where you pass a string inside 
and get a string outside 
d) No need to involve angular for such a basic pipe 
e) if the pipe file is, reverse.pipe.ts - we will create another 
file : reverse.piple.spec.ts for unit testing 
-> we create instance of ReversePipe and then 
write expect() function to reverse the string 

f) Thus for reversing pipe we did not use any testing framework  

eg:

import{ ReversePipe} from "./reverse.pipe";

describe('Component:User',()=>
{
it('should create pipe', 
()=>
{
let reversePipe = new ReversePipe();
expect(reversePipe.transform('hello')).toEqual('olleh');
});
})
}

-------->g)this type of testing is called isolated tests 

198) Non isolated tests 
a) if we have some pipe which is dependant on angular, 
we will have a question: Does the piece which you want to 
test depend on Angular or other pieces of the application 
b) If the answer is yes, then you get these testing utilities 
like TestBed which allows you to create Components , access the injector 
set up the module for testing and so on 
c) Also you get async, fakeAsync and tick to handle asynchronous tasks and so on 
d) if the answer is no,i.e if you dont have dependancy on angular or 
other pieces in the app , an isolated task like this might be what is all 
you need 

199) More resources on testing: 
a) If you want to dive deeper, the official Docs 
actually are a great place to start. 
There you'll also find a Non-CLI Setup!

b) Official Docs: https://angular.io/docs/ts/latest/guide/testing.html
c) I can also recommend the 
following Article: https://semaphoreci.com/community/tutorials/testing-components-in-angular-2-with-jasmine
d) For more Information on how to run Tests with the CLI have a look at their official Docs:

=> Unit Tests: https://github.com/angular/angular-cli/wiki/test

=> E2E Tests: https://github.com/angular/angular-cli/wiki/e2e


200) Angular as a platform 
a) Angular is called a platform since it supports 
CLI and also the entire infrastructure it gives you around 
your project and around your code 
c) Code is the heart. Framework allows us to build 
amazing web applications
d) But with the CLi and the project which is configured, a 
lot of useful tools around the CLI and around your projects - it will be good to do 
building, publishing, deploying and managing angular projects 
e) We will have look on 
1) Understand angular projects and config 
2) How to create and manage projects and many things inside 
of those projects 
3) Schematics and builders 
4) Projects, apps and libraries to build in multiple projects 
5) Deployment
6) Browser support 

201) Closer look at ng new :
a) Install latest version of angular:

eg:  npm install -g @angular/cli@latest 

b) Creating brand new project: ng new 

c) Help: against any command if you use : --help you can 
learn more about the command 

eg: ng new --help 


c) Angular official documentation on cli:
https://angular.io/cli


202) Understanding the config files :
a) .editorConfig 

-> This file is picked up by some IDEs like Visual Studio code 
and it basically tells the editor, how to :
eg:
indent_size=2, tells how to do indentation in this project 
-> this value overrides default ide settings
-> this is a code style thing  

b) .prettierrc

{
"singleQuote":true 
}

-> this file tells the auto formatting tool: prettierrc to 
-> .prettierrc works together along with .editorConfig 


c) .gitignore

-> this file  matters if you are working with Git 
-> gitignore is a file which tells git, which files it can 
ignore, which files which you dont want to manage with git 
-> this is because it will be regenerated frequently 
like node modules which you generate 

d) angular.json 
1) Manages the entire project configuration 


e) browserlist 
1) This file is picked up by angular cli when you 
build your project for production and it basically tells 
the angular CLI which browsers you want to 
support with our project 
2) The file helps to load the right polyfills and 
create the right code bundles 

f) karma.conf.js 
1) file used for unittests where Angular CLI uses Karma
behind the scenes 
2) It helps to fine tune, how your tests are executed and so 
on 


g) package-lock.json:
1) package-lock.json  is a file which is generated based 
on your package.json 
2) -> package-lock.json stores the exact versions of your third 
party dependencies, because in package.json we specify some minimum requiirements 
and some flexibility 

h) package.json 
1) it is a file that 
manages the packages  your project uses and the versions 
of those packages your project uses 
2) package.json has a couple of scripts which we can execute 
3) We have dependencies and devDependencies 
-> dependencies are third party packages our project uses to 
build our application and to run successfully 
4) devDependencies 
-> These are tools which we need only to build our project 
-> So this is not code, which will be part of our running application 
-> These will be tools that help us to 
build the application efficiently. That's Angular CLI 


eg:
@angular/cli 
@angular/compiler-cli -> for compiling the cli and optimizing 
the code 
@angular/language-service 

karma - for testing 

typescript - for compiling Typescript to JavaScript and so on 


i) We will use package.json by running npm install in the 
terminal  
-> running npm install will create node_modules folder based 
on the dependencies mentioned here 

j) This npm install command, also generates a package-lock.json file 
-> package-lock.json stores the exact versions of your third 
party dependencies, because in package.json we specify some minimum requiirements 
and some flexibility 

k) tsconfig.json
-> There are three tsconfig.json files 

1) tsconfig.app.json
-> This file extends the base configuration 
file: tsconfig.json  and used for real app compilation
2) tsconfig.json
-> this file configures the TypeScript compiler 
-> this is the base configuration file 

"angularCompilerOptions":
{
"fullTemplateTypeCheck":true,
"strictInjectionParameters": true 
}

-> Typescript compiler compiles 
typescript code to javascript code 
-> this setting is not used by typescript compiler,
but picked up by Angular compiler 
-> After typescript compiler completes, angular compiler 
will compile your angular application - so that your 
compiled javascript code and your html templates  will be 
converted into instructions that can be executed 
at run time 
eg: instructions to insert buttons to dom, to add event 
listeners and so on 
-> So real dom instructions that the browser understands - 
that is what the angular compiler will do and 
we can configure that compiler as well 

in official docs : https://angular.io/cli
Under DEV WORKFLOW -> Angular Compiler options -> 
We can find detailed angular compiler options 

3) tsconfig.spec.json 
-> This file extends the base configuration 
file: tsconfig.json  and used for testing environment 


l) tslint.json
-> used for linting which checks for code quality and 
tells you whether you are following best code practices 


203) Important CLI commands :https://angular.io/cli
1) ng new -> this command is used outside the project
-> Other commands will be used inside the project 
2) ng help
-> to learn about all commands 
3) ng serve 
-> serves the application 
4) ng serve --prod 
-> serves the application in production mode 
-> this is not production ready and cannot be used in prod 
-> This is just a preview of how production mode will work 
5) ng serve --open
-> This tells the CLI to not only serve the app,
but to open the app in a new browser tabl once it 
is done serving it up so that you dont have to manually open 
it there 
6) ng generate 
-> it helps to generate things in our application 
-> we have used things like: component, directive,services 
guards, services  etc 
-> We can generate the following :
appShell
application
class 
component 
directive 
enum
guard 
interceptor 
interface 
library 
module 
pipe 
service 
serviceworker
webWorker 

7) ng lint 
-> uses tslint file 
-> it goes through the entire setup and tell you 
if you have any linting errors 


8) ng build 
-> to build your project

9) ng build --prod 
-> to build your project for production 
and optimize it as much as possible  

ng build and ng build --prod 
-> will generate a dist folder where you find your generated 
project files, which you can put onto a 
server to serve your application 


204) angular.json - a closer look: 
What is inside of the angular json file 
a) This file is generated automatically when you 
generate a new angular project and this file is 
used by the cli behind the scenes to run 
different cli commands 
b) Basically here you can set some defaults for all 
these flags , otherwise we need to set it 
manually for every command - Hence setting defaults is 
more appropriate 
c) angular.json uses the json data format to store 
its information 
1) schema:
It follows a certain schema developed by the angular 
team and it is stored in this folder: 

eg:
  "$schema": "./node_modules/@angular/cli/lib/config/schema.json",
  
2) version 
-> it is the version of angular.json file 
eg:
"version":1

3) newProjectRoot:
-> This controls where new projects in your project here, 
in the end are added 
-> This wont tell much, what are projects 
-> we can manage more than one project in an 
angular project folder 

eg: "newProjectRoot": "projects"

4) defaultProject 
-> against which our cli commands will run 

5) projects:

eg:
"projects":{
"angular-config":{
"projectType": "application"

6) angular-config - one nested entry per project 
7) projectType 
-> default is application : which means it 
is regular angular application
-> it can be application or library 

eg: 
"projectType": "application"


8) schematics
-> it is a feature of angular ecosystem

eg:
"schematics": {}

9) root 
-> it tells the angular cli, what the root folder of this project is

eg:
"root": ""

 
10) sourceRoot
-> tells where the source files live in 
-> you can change this, if you want to store your code
in a different folder than source  

eg:
"sourceRoot": "src"


11) prefix
-> tells the prefix that is added in front 
of every component 

eg:
"prefix": "app"

12) architect
-> it forms the rest of our project settings 
-> Here different commands you can execute 
can be configured 


eg:
"architect": 
{
"build": {}
}


13) build 

"build":{
"builder": "angular-devkit/build-angular:browser",

here "builder" tells which tool gets used under the hood 
-> this tool is part of angular devkit package, which is 
one of third party dependencies we have added  
-> this builder tool knows how to build an 
angular project, which steps to execute and so on
-> this builder tool can be configured with options 

14) options:
-> the builder tool can be configured with options 
-> these are options or atleast partly we can set with 
these extra configuration flags  on cli commands 

15) aot 
eg: ng build --aot  
-> this command tells that this should be built with 
ahead of time compilation and by default this is 
true  
-> if aot is set to false, all builds would be done 
with aot compilation turned off 

16) outputPath
-> it tells where the project should be output into 
-> here it is specified that output path should be dist->
angular-config 

eg:
"outputPath": "dist/angular-config"

17) index:
-> it tells what should be the root entry file 

eg:
"index": "src/index.html"

18) main 
-> root entry file for angular application 
-> this could be changed as well 

eg:
"main": "src/main.ts"

19) polyfills
-> location where polyfills are managed


eg:
"polyfills": "src/polyfills.ts"


20) tsConfig
-> project specific configuration file 


eg:
"tsConfig": "tsconfig.app.json"


21) assets:
-> assets allow you to configure which files or 
folders should be copied over in the output 
-> images are stored under assets and will be 
referenced by the component html files 
-> After build it will be copied to dist folder
so that it is available in the served app as well 


eg:
"assets": [
"src/favicon.ico",
"src/assets"
],



22) styles:
-> styles used throughout this tutorial to include 
bootstrap
-> we can mention which css files either you own 
or third party package files, should be included in 
application by default 
-> every component has its own style file 
-> but if you have some global application wide 
styles, we can add it here. 

-> these files during build are used and evaluated
by the build workflow and in the end optimized and copied 
over to dist/angular-config/styles.3ffxxxxx  file 

eg:
"styles": [
"src/styles.css",
],


23) scripts:
-> if you have some javascript files, that should be 
copied over, then we can specify it here 
-> We may not need them often, since we might have most of 
our logic in angular files/components and so on 
-> But if you are using third party package like 
google maps or low dash, we can specify it here  
-> if specified, it will be copied over and included 
in your application 


24) More about configuration , can be seen in official 
documentation page: https://angular.io/guide/workspace-config

eg:
"scripts": [

],


25) Now besides the options for commands, we also 
have configurations :
a) While options are default options which are 
always applied  while with configurations you can 
configure different environments for your options 
b) We can say that i can have some option, which 
are only taken into account, if i build for production 
or if build for development 


eg:
"configurations": {
            "production": {
              "fileReplacements": [
			  
			  
c) Here we have some production specific settings:
-> eg in fileReplacements, that a file should be replaced
it tells cli that it should swap the environment.ts with 
environment.prod.ts when it builds for production 
-> This allows you to specify different environment variables 
for different prod or other environment we build 


eg:
"configurations": {
            "production": {
              "fileReplacements": [
                {
                  "replace": "src/environments/environment.ts",
                  "with": "src/environments/environment.prod.ts"
                }
              ],
              "optimization": true,
              "outputHashing": "all",
              "sourceMap": false,
			  
			  
-> in configuation if we need build for production we
specify it as : ng build --production 

this is for production we given in configurations section 

eg: 
"configurations": {
            "production": {
			
-> ng build --production is the shortcut for 
ng build --configuration=production 			


d) similarly if we want to have environment for 
staging we can specify in configurations like this:

g: 
"configurations": {
            "staging": {
			
and run the command:
ng build --configuration=staging 


e) We can also override the default  options specified in 

architect/build/builder/options with options specified in 
configuration 

-> Hence above default options will always be used, 
unless they are overridden there for the environment


26) serve:
-> until now we have seen everything for build 
command, now we are going to see for serve command 
-> options in serve command is much shorter 
-> we have one main option: browserTarget, 
where we tell CLI, that for this serve otpion, we want 
to use the build options, meaning that all options specified
for build will be used for serve as well 


eg:
    "serve": {
          "builder": "@angular-devkit/build-angular:dev-server",
          "options": {
            "browserTarget": "ng-complete-guide-update:build"
          },
		  
-> also we have production specific configuration if we 
run: ng serve --prod 


eg:
  "configurations": {
            "production": {
              "browserTarget": "ng-complete-guide-update:build:production"
            }
          }


-> if we wanted to know which options exist : 
https://angular.io/guide/workspace-config

27) internationalization
-> option for internationalization


eg:
 "extract-i18n": {
          "builder": "@angular-devkit/build-angular:extract-i18n",
          "options": {
            "browserTarget": "ng-complete-guide-update:build"
          }
		  
		  
28) test:
-> test options for running your tests, how 
your code should be compied and used in testing 

eg:
  "test": {
          "builder": "@angular-devkit/build-angular:karma",
          "options": {
            "main": "src/test.ts",
            "polyfills": "src/polyfills.ts",
            "tsConfig": "src/tsconfig.spec.json",
            "karmaConfig": "src/karma.conf.js",
            "styles": [
              "src/styles.css"
            ],
            "scripts": [],
            "assets": [
              "src/favicon.ico",
              "src/assets"
            ]
          }
        },
		
29) lint
-> used for configuring linting 

eg:
        "lint": {
          "builder": "@angular-devkit/build-angular:tslint",
          "options": {
		  
30) e2e testing:

eg:
  "ng-complete-guide-update-e2e": {
      "root": "e2e/",
      "projectType": "application",
      "prefix": "",
      "architect": {
        "e2e": {
          "builder": "@angular-devkit/build-angular:protractor"
		  
		  
31) That's all we are done for angular.json, for more guidance we 
we can use autocompletion or official documentation 
for angular.json



205) Angular CLI schematics :
-> Powerful tool or concept introduced by angular CLI team 
-> They are basically blueprints which certain 
angular commands can pick up 

a) For eg we can have schematics for: ng generate 
to generate new building blocks 
b) ng add - to add libraries and capabilities to a project 
c) ng update -> to keep your project upto date 


-> We can build your own built in schematics 
-> Angular's built in schematics: ng generate, ng add, ng update 

d) also third party libraries can add customm schematics 

206) Angular material

-> third party package maintained by parts of angular 
team but totally optional 
-> it adds components i.e prebuilt components to your 
angular app which follows material design spec 
-> Material design is a design language invented by google 
-> it looks the way this page looks : https://material.angular.io/


-> we can check out the components here and see what it 
offers : https://material.angular.io/components/categories
-> we can get prebuilt components which can be used in our 
application 

-> to add angular material run command:
ng add @angular/material 


207) what does "ng add" do?
a) When we execute for example this command:
ng add @angular/material 
b) First step, it installs packages through npm 
-> it installs all packages which you need , to use 
angular material in this case 
c) Some packages or tools might prompt you to 
make certain choices to make 
d) based on our choices it updates the packages 
-> it updates: package.json file 
--> because it installs more dependencies now 
e) It not only updates package.json, but also it 
updates some other files too 
-> main.ts 
-> app.module.ts 
-> angular.json
-> index.html
-> styles.css  
1) main.ts 
-> in main.ts it added an import for hammer js - third 
party package that helps us with gesture detection 
2) index.html 
-> it included some google fonts corresponding to material 
icons, roboto fonts etc 
3) app.module.ts 
-> added BrowserAnimationsModule from Angular animations 
4) styles.css 
-> sets some default styles corresponding to 
angular material 
5) angular.json
-> Under build command, it has included 
angularmaterial -> prebuilt-themes , so that our 
theme is picked up when we build for production 

208) What does "ng generate" schematics do?
a) It can be used in any angular project
-> because angular and angular cli has some default blueprints 
included 
eg: for generating a component,pipe,service etc 
b) While these are built in schematics or generate, we 
can add our own or add third party packages can have their 
own schematics 

eg: with angular material installed here , we can generate 

ng generate @angular/material:nav main -nav 

209) Smooth updating of projects using: "ng update" 
a) Helps to keep application upto date 
b) if we run the command in project: ng update 
-> it analyses the project and tells if there is 
something that needs to be updated 
-> for that it checks for every package which supports 
the "ng update" schematic  and if everything is updated 

it throws a message at end :
" We analyzed your package.json and everything seems 
to be in order. Good Work!"

-> if something is not upto date, it will show you a table 
and tells you, how you can update now 


....
eg:
PS C:\ExpoNow\maheangularprojects\dec25_ServiceWorker-pwa> ng update 
Using package manager: 'npm'
Collecting installed dependencies...
Found 28 dependencies.
    We analyzed your package.json, there are some packages to update:
    
      Name                               Version                  Command to update
     --------------------------------------------------------------------------------       
      @angular/cli                       13.3.11 -> 14.2.9        ng update @angular/cli@14 
      @angular/core                      13.3.12 -> 14.3.0        ng update @angular/core@14

    There might be additional packages which don't provide 'ng update' capabilities that are outdated.
    You can update the additional packages by running the update command of your package manager.
PS C:\ExpoNow\maheangularprojects\dec25_ServiceWorker-pwa> 
....

-> to update multiple packages:

ng update @angular/core@14 @angular/cli@14 

ng update @angular/core @angular/cli 

210) Builders:
-> While schematics are tools that you run to add something to your project like: adding third party library, generating component
or may be an update 
a) With builders you can build your application for different environments 
b) There are some built in builders. 

ng build/ng test/ng lint 

-> these execute your code, compile your code, analyze your code  and then 
for example  optimize it for production , run tests on it or simply 
tell how good your code quality is 

c) "ng deploy" is another builder 
-> this builds your project for production , then peform certain 
deployment steps and deploy it to a certain host 
-> there needs to be a third party package or tool which needs to 
support ng deploy , so that we can deploy to a host 
d) These are automation commands which you also can customize either 
by writing your own builder or deployment builder or by hooking into 
the configuration and adjusting those builders 

e) Official documentation for the same: https://angular.io/guide/deployment

f) In documentation we can find the currently supported packages 
that support ng deploy command :

eg: 
Firebase hosting	
@angular/fire
Vercel	
vercel init angular
Netlify	
@netlify-builder/deploy
GitHub pages	
angular-cli-ghpages
NPM	
ngx-deploy-npm
Amazon Cloud S3	
@jefiozie/ngx-aws-deploy

g) In angular.json we can configure these builders like the:
ng build command 

h) Now lets use "ng deploy" to firebase 
1) add @angular/fire to project

eg: ng add @angular/fire 

-> only after adding this, deploy command supports angular/fire

-> sometimes if it asks for tools and login follow below and do 
ng add again  

2) install firebase tools globally:

eg: npm install -g firebase-tools

3) firebase login 

4) then try ng add @angular/fire 

5) now run : ng deploy , it will automatically pickup @angular/fire 
as the deployment option 
-> it compiles the code - because it runs the entire build process in production mode 
-> takes build assets to build files 
-> then ships them onto a server 
-> on the process, it uploads files to server 
-> once deployment is done, it shares an application 
link to access the file 

211) Understanding "Differential loading"
-> Until now we talked about deployment
->  Now lets talk about browserslist 
-> this is important for telling angular, which browsers you want to support 
-> this is related to deployment 
-> angular will take the information here to auto 
prefix your css code correctly , but also so that  it knows  
which polyfills to load and which different versions of bundles 
it should generate 

a) Angular has built in feature called "Differential loading" 
-> we have our angular app and we are hosting this , for eg 
on Firebase or AWS S3 or any other hosting provider 
-> If app gets visited by users 
User A may have modern browser 
User B may have legacy browser 
-> User A with modern browser like latest version of 
chrome or firefox, needs no or less polyfills . All features 
we use will work there just fine - Hence we may ship a smaller 
code bundle to the user - This is because our code does not have 
to be compiled down to old versions of java script and also we 
might not need any or all polyfills 
-> User B on other hand, needs a version which is compiled to way older 
code and she needs all/more polyfills and bigger bundle is required 
b) The problem is , we can ship a bigger bundle - so that we 
support both B and A 
-> if we always support the most optimized and smallest bundle possible,
we ignore user B   and user B wont be able to run the application 
c) With differential loading, we do both
-> angular cli produces multiple versions of your app when it 
builds for production 
-> and it produces a small code file which runs 
first when user visits your page , to identify which browser 
this user is using and then this small initial code file, determines 
which bundle gets served to the user 
d) So with differential loading(included in built angular app) , a user 
using a modern browser has to download less code than a user 
using a older browser 
e) This gives us the best of both worlds, where we support 
all users and make sure that every user just has  to download the code that is really needed  
f) This is built into angular in dist folder 
-> We see two versions of every file :
two main, 2 polyfills, 2 runtime files and 
their names are different 
g) es5 is for the users with older browsers , es2015 is for the recent javascript and it will be smaller 
-> for polyfills and runtime also it is the same
h) these are the files we deploy into hosting provider and they will 
be executed automatically 
i) In index.html, runtime file executes first ,
there it then decides which other files it needs to load  

j) thus it concludes the differential loading feature which comes 
out of the box in angular 

k) differential loading is party configured with browserslist file ,
where we tell angular which browsers you wanted to support and 
this tells angular how it should build and optimize these differnt bundles 
l) In addition, you have a setting in tsconfig.json 
where we specify the target javascript version you wanted to 
compile and here its  compiling for moder javascript i.e es2015
-> if you set this to an older one , then you force all users to 
use this older one 
-> thus differential loading is a feature that we need to be 
aware of and its not something where you need to do much 

eg:
"target": "es2015" 

m) polyfills 

-> crucial polyfills like : import 'zone.js/dist/zone 
are included by default, just by this import statement 
-> if you are using animations, then we need to add 
import 'web-animations-js'; so that browser like ie/edge and safari support it 


212) Managing multiple projects in one folder 
a) Inside an angular project, you can have multiple 
projects 
-> you start with one project and then we can use ng generate and 
use one of two project types: library or application 
-> lets start with application using ng generate
-> and then within project if we again use this command: 
eg: ng generate application newprojectwithin 
-> it will ask same questions like routing  and after it is done 
we can see new folder called projects is added 
-> in that projects folder, we can see newprojectwithin folder 
is created - which basically has a new angular project in it 
-> it will be bit slimmer, because they share the same root angular.json 
file and package.json file 

b) But each project will have its own dedicated config file,its own source 
folder etc 
c) Now we can serve this : 
ng server --project=newprojectwithin

c) We can also set the default project which ng serve can use 
in angular.json file in the defaultProject section:

eg:
"defaultProject":"outsideProject"

-> Here if we run the project using: ng serve without any option 
then it will serve this defaultPoject 

d) We can think that having "newprojectwithin" project inside another 
main project "outsideProject" is ugly 
--> we can do something better about it 
1) lets go to the main terminal and to the folder where we 
created our new angular project: 
ng new angular-shop --create-application=false 
-> if we run this - something interesting happens
It now will generate some files but less files than before 
-> it installs some dependencies but it will not create a brand new 
application by default , instead once it finishes it gives us a folder 
that looks like this: 

angular-shop

2) Now we can run : ng generate application newprojectwithin

-> this will create the new projects folder thereafter and 
create it in there 

eg:
angular-shop/projects/newprojectwithin

3) Now we have a cleaner structure which is nice 
Multiple projects in one root folder 


213) Angular libraries - an introduction 
a) To create a library we run: ng generate library my-button 
-> this created library can be used by other projects 
b) A library differs from an application such that you still 
write angular code in there , you still build angular components 
and so on , group them to modules, add directives 
-> But it is not mean to run standalone as a web application 
-> Instead it is meant to have some code that can be 
shared across multiple angular applications 

eg: Angular material 

c) Differences in angular library from angular application 
1) We have ng-package.json file -> which allows us to configure 
this library in a certain way 
2) In src folder we see public-api.ts file , where we export 
different things that make our library 
3) In lib folder , we have some starting files , for eg: 
my-button-component where we can write our own library component 
already added to a module 
-> also a service, which you cannot use 
4) To learn about library creation we can use the official documentation in 
angular page 



214) What is Angular Elements
a) Feature of angular framework that allows you to 
turn normal angular components which you use in your 
Angular app into native web components 
b) Web components are basically custom HTML elements that are
part of dom of javascript api 
-> They are not related to angular and it can be used in vanilla 
JavaScript apps 
c) THus we can create Web Components with angular elements 
d) Webcomponents allows you to dynamically insert HTML code 
holding Angular Components after the angular app has been compiled 
and loaded 
e) eg: if you have a content management system in your backend server 
-> there your editors can create html code 
-> they know how to write html code  and therefore they create 
the content that gets loaded into your angular app in html 
f) if you want to enable them to also to 
use some of your angular components in the html code, they prepare 
g) if they do that, if they use your angular component 
selectors and then you load this content dynamically in your angular app, it will actually not 
work - this is because angular app is compiled ahead of time or even with 
just in time compilation , it is compiled before the 
content is loaded 
h) so if the content contains these selector of a angular component 
this will not work and it will not recognize it 
i) let me show what i mean 
1) Here we have our brand new angular project created with 
angular cli 
2) Lets create new component: alert.component.ts 
-> define selector , template, styles 
-> define message property for alert 
3) Use AlertComponent in declarations array of app.module.ts 
4) Goto app.component.html , use the newly created app-alert component's selector and pass the message 


eg:
<app-alert message="This is normal angular component"></app-alert>


5) now we will be able to see the alert in ui
6) Lets say in the app component, we want to load this component dynamically 
-> we already have content property in AppComponent which is 
null initially 
-> intead of outputting component like this in app.component.html
<app-alert message="This is normal angular component"></app-alert>

-> lets have a div and on this div , we can use the innerHTML 
property binding to bind to the content 

eg:
<div [innerHTML]="content"></div> 

7) In the app component 
-> lets add timeout and get the content like a asynchronous task
...

8) 
@webcomponents/custom-elements": "^1.0.8" in package.json 

also enable custom elemens in polyfills.ts 

specify in entryComponents 

DomSanitizer





